/// <amd-module name="SbisFile/Source/Abstract" />
// @ts-ignore
import SbisService = require("WS.Data/Source/SbisService");
import {IFileModel} from "File/Attach/IModel";
// @ts-ignore
import Deferred = require("Core/Deferred");
// @ts-ignore
import Di = require("WS.Data/Di");
import {Resource} from 'interface';
import 'SbisFile/Source/Provider/Abstract';
import 'File/Attach/Model';

const DEFAULT = {
    provider: 'source.provider.file-abstract',
    model: 'file.model'
};
interface IRemote {
    _$model: string;
    _writable: boolean;
    getAdapter();
    getIdProperty(): string;
    getProvider();
    _createProvider(name: string, opt);
    create(meta): Deferred<IFileModel>;
    _prepareArgumentsForCall(...args): object;
    _$binding: {
        create: string;
    }
    _provider
    _$provider: string;
    _$endpoint;
    _$options;
    _notify(...args);
}
let SbisSource: {
    new(cfg: object): IRemote;
} = SbisService;
/**
 * Абстрактный класс источника данных, позволяющий загружать сущность файлов {@link File/LocalFile} на сервис
 * @class
 * @name SbisFile/Source/Abstract
 * @extends WS.Data/Source/SbisService
 * @public
 * @author Заляев А.В.
 */
// @ts-ignore
abstract class Abstract extends SbisSource/** @lends SbisFile/Source/Abstract.prototype */ {
    constructor(cfg: object) {
        super ({...DEFAULT, ...cfg});
    }
    /**
     * @param {Object | WS.Data/Entity/Record} meta Дополнительные мета данные,
     * которые могут понадобиться для создания модели
     * @param {File/LocalFile | File/Directory} resource Загружаемый файл на бизнес-логику
     * @return {Core/Deferred.<File/Attach/Model>} Асинхронный результат выполнения.
     * @see File/LocalFile
     * @see File/Directory
     * @see File/Attach/Model
     * @override
     */
    create(meta, resource?: Resource): Deferred<IFileModel> {
        // чтобы ничего не сломать при наследовании и модуль мог нормально использоваться, как любой другой ISource
        if (!resource) {
            return super.create(meta);
        }
        return this._upload(resource, meta).addCallback((data) => this._prepareCreateResult(data, resource));
    }
    /**
     * Вызов загрузки файла на сервис
     * @param {File/LocalFile | File/Directory} resource
     * @param {*} meta
     * @return {Core/Deferred}
     * @protected
     * @abstract
     */
    protected abstract _upload(resource: Resource, meta: any): Deferred<any>

    /**
     * @param {*} data Raw data
     * @param {File/LocalFile | File/Directory} resource Origin resource
     * @return {File/Attach/Model}
     * @protected
     * @override
     */
    protected _prepareCreateResult(data, resource) {
        let model = !!resource? this._$model: super['_$model'];
        return Di.create( model, {
            writable: this._writable,
            rawData: data,
            adapter: this.getAdapter(),
            idProperty: this.getIdProperty(),
            origin: resource
        });
    }

    /**
     * @override
     */
    protected getProvider() {
        if (!this._provider) {
            let _this = this;
            this._provider = this._createProvider(this._$provider, {
                endpoint: this._$endpoint,
                options: this._$options,
                onprogress(...args) {
                    _this._notify('onProgress', ...args);
                }
            });
        }
        return this._provider;
    }
}

export = Abstract;
