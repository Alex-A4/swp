/// <amd-module name="SbisFile/Source/Provider/Abstract" />
// @ts-ignore
import SbisBusinessLogic = require("WS.Data/Source/Provider/SbisBusinessLogic");
// @ts-ignore
import ITransport = require("Transport/ITransport");
// @ts-ignore
import Transport = require("Transport/XHRTransport");
// @ts-ignore
import Deferred = require("Core/Deferred");
// @ts-ignore
import Di = require("WS.Data/Di");
import {
    UploadParam,
    RequestParam,
    ProviderConfig,
    ProgressData,
    Resource
} from "SbisFile/Source/Interface";

const DEFAULT = {
    /**
     * @cfg {Function} Конструктор сетевого транспорта для загрузки файлов
     */
    uploadTransport: Transport,
    onprogress(){}
};
interface Provider {
    getEndpoint(): {
        contract: string;
        address: string;
    };
    _nameSpaceSeparator: string;
}
let Provider: {
    new(...args): Provider
} = SbisBusinessLogic;
/**
 * @class
 * @public
 * @name SbisFile/Source/Provider/Abstract
 * @extends WS.Data/Source/Provider/SbisBusinessLogic
 */
abstract class Abstract extends Provider {
    private readonly __transports: {
        [propName: string]: ITransport;
    };
    private _$uploadTransport: {
        new(...args): ITransport;
    };
    protected onprogress: (data: ProgressData, resource: Resource) => void;
    constructor(cfg: Partial<ProviderConfig> = {}) {
        let config = {...DEFAULT, ...cfg};
        super(config);
        this._$uploadTransport = config.uploadTransport;
        this.onprogress = config.onprogress;
        this.__transports = Object.create(null);
    }
    /**
     * Загружает файл на сервис
     * @param {File/LocalFile} localFile Файл загрузки
     * @param {Object} service
     * @param {*} meta Дополнительные данные для загрузки
     * @return {Core/Deferred}
     * @protected
     * @abstract
     */
    abstract upload({resource, service, meta}: UploadParam): Deferred;
    /**
     * Отправка запроса на сервис
     * @param {String} url Адрес сервиса
     * @param {String} method Http метод запроса
     * @param {*} data Тело запроса
     * @param {Object} headers Заголовки запроса
     * @param {String} dataType
     * @return {Core/Deferred}
     * @private
     */
    protected _request({url, method, data, headers, dataType}: Partial<RequestParam>): Deferred<any> {
        let transport = this._getTransport(url, method, dataType);
        return transport.execute(data, headers);
    }
    /**
     * Получение транспорта для общения с сервисом
     * @param {String} url Адрес
     * @param {'POST' | 'PUT'} method Http метод общения
     * @param {String} dataType
     * @return {Transport/ITransport}
     * @private
     */
    protected _getTransport(url: string, method = "POST", dataType?: string): ITransport {
        if (!this.__transports[method]) {
            this.__transports[method] = new this._$uploadTransport({
                contentType: false,
                dataType: 'json',
                method,
                url
            });
        }
        this.__transports[method].setUrl(url);
        /*
         * TODO хак чтобы не хранить отдельный экземпляр транспорта.
         * Поменять, сразу как траспорт перейдёт на передачу всех параметров вызова в аргументы, как в Fetch api
         * https://online.sbis.ru/opendoc.html?guid=c2d85f9e-0839-4c08-a64f-4e32a5d90733
         */
        this.__transports[method]._options.dataType = dataType || "json";

        return this.__transports[method];
    }

}

Di.register('source.provider.file-abstract', Abstract);

export = Abstract;
