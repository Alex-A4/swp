/// <amd-module name="SbisFile/Source/Provider/FileStorage" />
import FileAbstract = require("SbisFile/Source/Provider/Abstract");
// @ts-ignore
import Di = require("WS.Data/Di");
// @ts-ignore
import Deferred = require("Core/Deferred");
// @ts-ignore
import ParallelDeferred = require('Core/ParallelDeferred');
import FileSeparator = require('SbisFile/utils/FileSeparator');
import {
    FileStorageUploadParam as UploadParam,
    FileStorageUploadResult as UploadResult
} from "SbisFile/Source/Interface";
import {
    MB,
    GB,
    MAX_SIZE_FOR_SEND,
    PART_SIZE
} from 'SbisFile/Source/_Const';

/**
 * @class
 * @public
 * @name SbisFile/Source/Provider/FileStorage
 * @extends SbisFile/Source/Provider/Abstract
 */
class FileStorage extends FileAbstract {
    '[SbisFile/Source/Provider/FileStorage' = true;

    /**
     * @param {SbisFile/Source/FileStorageUploadParam} UploadParam
     * @return {Core/Deferred.<SbisFile/Source/FileStorageUploadResult>}
     * @override
     */
    upload({
       resource,
       service,
       meta
    }: UploadParam): Deferred<UploadResult>  {
        let _meta = {
            ...meta,
            ...resource.getMeta()
        };
        let headers = this._getHeaders({
            meta: _meta,
            resource
        });
        let file = resource.getData();
        let uploadConfig = {
            url: `${service.url}${service.storage}/`,
            headers,
            file,
            resource
        };
        if (file.size >= MAX_SIZE_FOR_SEND) {
            return this._uploadByParts(uploadConfig);
        }
        return this._upload(uploadConfig);
    }

    /**
     * Загрузка файла целиком
     * @param {String} url
     * @param {File} file
     * @param {Object} headers
     * @return {Core/Deferred.<SbisFile/Source/FileStorageUploadResult>}
     * @private
     */
    private _upload({file, url, headers}): Deferred<UploadResult> {
        return this._request({
            url,
            method: "POST",
            headers,
            data: file
        });
    }

    /**
     * Загрузка файла частями
     * @param {String} url
     * @param {File} file
     * @param {Object} headers
     * @return {Core/Deferred.<SbisFile/Source/FileStorageUploadResult>}
     * @private
     */
    private _uploadByParts({url, file, headers, resource}): Deferred<UploadResult> {
        let uploadUrl; // Ссылка загрузки
        return this._getUploadPartUrl(url, headers).addCallback((href) => {
            uploadUrl = href;
            let uploadSize = 0;
            let percent = file.size / 100;
            let steps = FileSeparator.split(file, PART_SIZE).map((part: Blob) => {
                return () => {
                    return this._uploadPart(part, href).addCallback((result) => {
                        uploadSize += part.size;
                        let uploadPercent = Math.floor(uploadSize/percent);
                        this.onprogress({
                            totalSize: file.size,
                            uploadSize,
                            uploadPercent
                        }, resource);
                        return result;
                    });
                }
            });
            return new ParallelDeferred({
                steps,
                stopOnFirstError: true,
                maxRunningCount: 1
            }).done().getResult();
        }).addCallback(() => {
            return this._unionParts(uploadUrl);
        });
    }

    /**
     * Загрузка куска файла
     * @param {Blob} part
     * @param {String} url
     * @return {Core/Deferred.<void>}
     * @private
     */
    private _uploadPart(part: Blob, url: string): Deferred<void> {
        return this._request({
            url,
            method: 'PUT',
            data: part,
            dataType: "text"
        })
    }

    /**
     * Завершение загрузки составного файла
     * @param {String} url Адрес загрузки
     * @return {Core/Deferred.<SbisFile/Source/FileStorageUploadResult>}
     * @private
     */
    private _unionParts(url): Deferred<UploadResult> {
        return this._request({
            url,
            method: 'POST'
        });
    }

    /**
     * Получение ссылки для загрузки состаыного файла
     * @param {String} url Адрес загрузки
     * @param {Object} headers Объект заголовков
     * @return {Core/Deferred.<String>}
     * @private
     */
    private _getUploadPartUrl(url, headers): Deferred<string> {
        return this._request({
            url: `${url}upload`,
            headers,
            method: 'GET'
        }).addCallback((res) => {
            return res.href;
        });
    }

    /**
     * Получение объекта заголовков для загрузки
     * @param {File/LocalFile} resource
     * @param {SbisFile/Source/FileStorageMeta} meta
     * @return {Object}
     * @private
     */
    private _getHeaders({resource, meta}): object {
        let headers = {
            'Content-Disposition': "attachment; filename*=utf-8''" + encodeURI(resource.getName()),
            'Content-Type': resource.getData().type || 'application/octet-stream'
        };
        if (meta.newFileName) {
            headers['X-Object-Filename'] = meta.newFileName;
        }
        if (meta.publicAccess) {
            headers['X-Object-Access'] = 'public';
        }
        if (meta.deleteAfter) {
            headers['X-Object-Delete-After'] = true;
        }
        if (meta.deleteAfterPermanently) {
            headers['X-Object-Delete-After-Permanently'] = true;
        }
        return headers;
    }
}

Di.register('source.provider.file-storage', FileStorage);

export = FileStorage;
