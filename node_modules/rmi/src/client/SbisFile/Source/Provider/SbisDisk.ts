/// <amd-module name="SbisFile/Source/Provider/SbisDisk" />
import FileAbstract = require('SbisFile/Source/Provider/Abstract');
// @ts-ignore
import Di = require('WS.Data/Di');
// @ts-ignore
import Deferred = require('Core/Deferred');
// @ts-ignore
import ParallelDeferred = require('Core/ParallelDeferred');
import FileSeparator = require('SbisFile/utils/FileSeparator');
import {
    Resource,
    SbisDiskUploadParam as UploadParam,
    SbisDiskMeta as Meta,
    SbisDiskService as Service,
    SbisDiskResult as Result
} from 'SbisFile/Source/Interface';
import Directory = require("File/Directory");
import {MB, GB, MAX_SIZE_FOR_SEND, PART_SIZE} from 'SbisFile/Source/_Const'

const PART_SIZE_BIG = 75 * MB; // размер куска для файлов > 1GB
const SEND_LIMIT = 5; // количество попыток дослать запрос, при ошибке
const RESEND_TIMEOUT = 10 * 1000; // таймут повторной попытки запроса, при ошибке

type UploadConfig = {
    resource: Resource;
    serviceUrl: string;
    url: string;
    name: string;
    file: File;
    method: 'POST' | 'PUT';
    newName?: string;
    publicAccess?: boolean;
}
/**
 * Объект подготовленных параметров загрузки, для внутреннего взаимодействия
 * @typedef {Object} UploadConfig
 * @property {String} serviceUrl Адрес сервиса
 * @property {String} url Конечный адрес загрузки файла (serviceUrl + каталог загрузки или fileId заменяемого файла)
 * @property {String} name Конечное имя загружаемого файла
 * @property {File} file Загружаемый файл
 * @property {'POST' | 'PUT'} method Http метод запроса (POST для новый файлов, PUT для заменяемых)
 * @property {String} [newName] Новое имя файла для ревизии
 */

/**
 * @class
 * @public
 * @name SbisFile/Source/Provider/SbisDisk
 * @extends SbisFile/Source/Abstract
 */
class Provider extends FileAbstract {
    '[SbisFile/Source/Provider/SbisDisk' = true;

    /**
     * Загружает файл на СБИС-Диск
     * @param {SbisFile/Source/SbisDiskUploadParam} param
     * @return {Core/Deferred}
     */
    // @ts-ignore
    upload({resource, service, meta, catalog, publicAccess}: UploadParam): Deferred {
        if (resource instanceof Directory) {
            return this._uploadDirectory(<Directory>resource, service, meta, catalog)
        }

        let _meta = {
            ...meta,
            ...resource.getMeta()
        };
        let file = resource.getData();
        let uploadConfig: UploadConfig = {
            resource,
            name: encodeURIComponent(_meta.newFileName || _meta.fileName || resource.getName()),
            method: _meta.fileId ? "PUT" : "POST",
            serviceUrl: service.url,
            url: service.url + (_meta.fileId || catalog || service.catalog),
            newName: _meta.fileId && _meta.newFileName,
            // @ts-ignore
            file,
            publicAccess
        };
        if (file.size >= MAX_SIZE_FOR_SEND) {
            return this._uploadByParts(uploadConfig);
        }
        return this._upload(uploadConfig);
    }
    /**
     * Загрузка цельного файла
     * @param {UploadConfig} cfg
     * @return {Core/Deferred}
     * @private
     */
    private _upload({name, method, url, file, newName, publicAccess}: UploadConfig): Deferred {
        let headers = {
            'Content-Type': file.type || 'application/octet-stream',
            'Content-Disposition': "attachment; filename*=UTF-8''" + name
        };
        if (newName) {
            headers['X-OBJECT-FILENAME'] = newName;
        }
        if (publicAccess) {
            headers['X-Object-Access-Public'] = true;
        }
        return this._request({
            url,
            data: file,
            method,
            headers
        });
    }

    /**
     * Загрузка файла частями
     * @param {UploadConfig} cfg
     * @return {Core/Deferred}
     * @private
     */
    private _uploadByParts(cfg: UploadConfig): Deferred {
        let uploadUrl; // Ссылка загрузки
        let file = cfg.file;
        return this._getUploadPartUrl(cfg).addCallback((href) => {
            uploadUrl = href;
            let uploadPartUrl = uploadUrl + '&part=new'; // ссылка, по которой загружаем куски файла
            let size = file.size >= GB ? PART_SIZE_BIG : PART_SIZE;
            let uploadSize = 0;
            let percent = file.size / 100;
            /*
             * Разделяем файл на массив из Blob и преобразуем его в массив функций,
             * которые вызывают загрузку соответствующего куска
             * необходимо чтобы построить очередь загрузки
             */
            let steps = FileSeparator.split(file, size).map((part: Blob) => {
                return () => {
                    return this._uploadPart(part, uploadPartUrl).addCallback((result) => {
                        uploadSize += part.size;
                        let uploadPercent = Math.floor(uploadSize/percent);
                        this.onprogress({
                            totalSize: file.size,
                            uploadSize,
                            uploadPercent
                        }, cfg.resource);
                        return result;
                    });
                }
            });
            return new ParallelDeferred({
                steps,
                stopOnFirstError: true,
                maxRunningCount: 1
            }).done().getResult();
        }).addCallback(() => {
            return this._unionParts(uploadUrl, cfg.method, cfg.newName);
        });
    }

    /**
     * Отправка куска файла, с возможностью переотправки, при возникновении ошибки
     * @param {Blob} part Часть загружаемого файла
     * @param {String} url Адрес загрузки
     * @param {Number} [attempt] Номер попытки
     * @return {Core/Deferred}
     * @private
     */
    private _uploadPart(part: Blob, url: string, attempt?: number): Deferred {
        return this._request({
            url,
            method: 'PUT',
            data: part,
            dataType: "text"
        }).addErrback((error) => {
            /**
             * Если возникла ошибка при отправке куска файла, то попытаемся ещё, через определённый таймаут
             * Сомнительный кусок, но отдел СБИС Диск'а грузит с попытками догрузить, если где-то оборвалось,
             * пока эмулируем тоже
             */
            attempt = attempt || 0;
            if (attempt < SEND_LIMIT) {
                let def = new Deferred();
                setTimeout(() => {
                    def.callback(this._uploadPart(part, url, ++attempt));
                }, RESEND_TIMEOUT);
                return def;
            }
            return error;
        });
    }

    /**
     * Получение ссылки, по которой будет загружаться файл кусками
     * @param {UploadConfig} cfg Параметры загрузки
     * @return {Core/Deferred.<String>} Адрес, на которой необходимо загружать части файлов
     * @private
     */
    private _getUploadPartUrl({serviceUrl, file, url, name, newName}: UploadConfig): Deferred<string> {
        let headers = {
            'Content-Type': 'application/json;charset=utf-8',
            'Content-Disposition': "attachment; filename*=UTF-8''" + name,
            'X-Upload-Content-Type': file.type || 'application/octet-stream',
            'X-Upload-Content-Length': file.size
        };
        // для новых файлов X-OBJECT-FILENAME должен быть при формировании адреса
        if (newName) {
            headers['X-OBJECT-FILENAME'] = newName;
        }
        return this._request({
            url: serviceUrl + 'upload',
            headers,
            data: JSON.stringify({href: 'https://' + location.hostname + url})
        }).addCallback((res) => {
            return res.href;
        });
    }

    /**
     * Объединение кусочков файлов на сервере через отсылку манифеста
     * @param {String} url - адрес, который пришел с сервера, на который надо грузить куски
     * @param {'POST' | "PUT"} method Http-метод. POST для новый файлов, PUT для обновления старого файла
     * @param {String} [newName] Новое имя файла для ревизии.
     */
    private _unionParts(url, method, newName): Deferred<object> {
        let headers = {};
        // для новый ревизий X-OBJECT-FILENAME должен быть при объединении
        if (newName) {
            headers['X-OBJECT-FILENAME'] = newName;
        }
        return this._request({url, method, headers});
    }
    private _uploadDirectory(
        directory: Directory,
        service: Service,
        meta: Partial<Meta>,
        catalog: string
    ) {
        let createdFolder: Result;
        return this._createFolders(
            service.url,
            directory.getName(),
            catalog || service.catalog
        ).addCallback((folder: Result) => {
            createdFolder = folder;
            let entries = directory.getEntries().map((resource: Resource, index: number) => {
                return () => {
                    return this.upload({
                        resource,
                        service,
                        meta,
                        catalog: folder.fileid
                    })
                }
            });
            return new ParallelDeferred({
                steps: entries,
                stopOnFirstError: false,
                maxRunningCount: 1
            }).done().getResult();
        }).addCallback(() => {
            return createdFolder;
        })
    }

    /**
     * Создание папки на сервисе
     * @param {String} serviceUrl Адрес сервиса
     * @param {String} name Ммя создаваемой папки
     * @param {String} root Корневая директория
     * @private
     */
    private _createFolders(
        serviceUrl: string,
        name: string,
        root: string
    ): Deferred<Result> {
        return this._request({
            headers: {
                'X-OBJECT-FOLDER': true,
                'Content-Disposition': "attachment; filename*=UTF-8''" + encodeURIComponent(name)
            },
            method: 'POST',
            url: serviceUrl + root
        });
    }
}

Di.register('source.provider.sbis-disk', Provider);

export = Provider;
