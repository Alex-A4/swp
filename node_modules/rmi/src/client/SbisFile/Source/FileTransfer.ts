/// <amd-module name="SbisFile/Source/FileTransfer" />
import FileAbstract = require("SbisFile/Source/Abstract");
import BL = require("SbisFile/Source/BL");
// @ts-ignore
import Deferred = require("Core/Deferred");
import LocalFile = require("File/LocalFile");
import FileSeparator = require("SbisFile/utils/FileSeparator");
// @ts-ignore
import ParallelDeferred = require('Core/ParallelDeferred');
// @ts-ignore
import Model = require("WS.Data/Entity/Model");
// @ts-ignore
import DataSet = require("WS.Data/Source/DataSet");
import {FileTransferConfig as SourceConfig} from "Interface";

const KB = 1024;
const MB = KB * KB;
const MAX_SIZE = 25 * MB;
const PART_SIZE = 5 * MB;

const ENDPOINT = {
    contract: "FileTransfer"
};
const SOURCE_OPTIONS = {
    binding: {
        create: "Upload"
    },
    fileProperty: "file"
};
const PART_SOURCE_OPTIONS = {
    binding: {
        create: "UploadPart"
    },
    fileProperty: 'data',
    rpcBinary: true
};
const CREATE_METHOD = "Create";

type UploadResult = {
    id: string;
    name: string;
}
/**
 * Результат загрузки файла в FileTransfer
 * @typedef {Object} UploadResult
 * @property {String} id Идентификатор файла на сервисе
 * @property {String} name Имя файла
 */

const DEFAULT = {
    adapter: 'adapter.json',
    /**
     * @cfg {String} serviceUrl Адрес сервиса FileTransfer
     */
    serviceUrl: '/file-transfer/service/',
    /**
     * @cfg {String} storage Используемое хранилище
     * @see {@link https://online.sbis.ru/shared/disk/862e8a62-ff97-41b0-8311-29d4f87d1f3d}
     */
    storage: ''
};
/**
 * Класс источника данных для работы с сервисом FileTransfer
 * @class
 * @name SbisFile/Source/FileTransfer
 * @extends SbisFile/Source/Abstract
 * @public
 * @author Заляев А.В.
 */
class Source extends FileAbstract /** @lends SbisFile/Source/FileTransfer.prototype */ {
    private _$storage: string;
    private _$serviceUrl: string;
    private _source;
    private _partSource;

    constructor(cfg: Partial<SourceConfig>) {
        let config = {...DEFAULT, ...cfg};
        super(config);
        this._$storage = config.storage;
        this._$serviceUrl = config.serviceUrl;
        if (!this._$storage) {
            throw new Error('argument "storage" is required');
        }
        let endpoint = {
            address: this._$serviceUrl,
            ...ENDPOINT
        };

        this._source = new BL({
            endpoint,
            ...SOURCE_OPTIONS
        });
        this._partSource = new BL({
            endpoint,
            ...PART_SOURCE_OPTIONS
        });
    }
    /**
     * Вызов загрузки файла на сервис FileTransfer
     * @param {File/LocalFile} resource
     * @param {*} meta
     * @return {Core/Deferred.<UploadResult>}
     * @protected
     * @override
     */
    protected _upload(resource: LocalFile, meta: any): Deferred<UploadResult> {
        let file = resource.getData();
        if (file.size >= MAX_SIZE) {
            return this._uploadByPart(resource, meta);
        }
        return this._source.create({
            storage: this._$storage
        }, resource).addCallback((model: Model) => ({
            id: model.getRawData(),
            name: resource.getName()
        }));
    }

    /**
     * Загрузка файла кусками
     * @param {LocalFile} resource
     * @param {*} meta
     * @return {Core/Deferred.<UploadResult>}
     * @private
     */
    private _uploadByPart(resource: LocalFile, meta: any): Deferred<UploadResult> {
        let name = resource.getName();
        let id;
        return this._partSource.call(CREATE_METHOD, {
            name,
            storage: this._$storage
        }).addCallback((dataSet: DataSet) => {
            id = dataSet.getRawData();
            let fileParts = FileSeparator.split(resource.getData(), PART_SIZE);
            let lastIndex = fileParts.length - 1;
            let steps = fileParts.map((part: Blob, index: number) => {
                return () => {
                    return this._partSource.create({
                        id,
                        storage: this._$storage,
                        finish: index === lastIndex
                    }, new LocalFile(part, {}, name))
                }
            });
            return new ParallelDeferred({
                steps,
                stopOnFirstError: true,
                maxRunningCount: 1
            }).done().getResult();
        }).addCallback(() => ({
            id,
            name
        }));
    }
}

export = Source;
