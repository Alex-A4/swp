/// <amd-module name="Data/_source/Base" />
/**
 * Базовый источник данных.
 * Это абстрактный класс, не предназначенный для создания самостоятельных экземпляров.
 * @class WS.Data/Source/Base
 * @extends WS.Data/Entity/Abstract
 * @implements WS.Data/Source/IData
 * @mixes WS.Data/Entity/OptionsMixin
 * @mixes WS.Data/Entity/SerializableMixin
 * @mixes WS.Data/Source/OptionsMixin
 * @mixes WS.Data/Source/LazyMixin
 * @mixes WS.Data/Source/DataMixin
 * @ignoreOptions options.writable
 * @public
 * @author Мальцев А.А.
 */

import IData from './IData';
import SourceOptionsMixin, {IOptions as IDefaultOptions} from './OptionsMixin';
import LazyMixin from './LazyMixin';
import DataMixin, {IOptions as IDataOptions} from './DataMixin';
import {Abstract, OptionsMixin, SerializableMixin, adapter} from '../type';
import {mixin} from '../util';

export interface IOptions extends IDefaultOptions, IDataOptions {
}

export default abstract class Base extends mixin(
   Abstract, OptionsMixin, SerializableMixin, SourceOptionsMixin, LazyMixin, DataMixin
) implements IData /** @lends WS.Data/Source/Base.prototype */{
   protected constructor(options?: IOptions) {
      options = Object.assign({}, options || {});

      super(options);
      SourceOptionsMixin.constructor.call(this, options);
      OptionsMixin.call(this, options);
      SerializableMixin.constructor.call(this);
      DataMixin.constructor.call(this, options);
   }

   // region IData

   readonly '[Data/_source/IData]': boolean;

   getAdapter: () => adapter.IAdapter;
   getIdProperty: () => string;
   setIdProperty: (name: string) => void;
   getModel: () => Function | string;
   setModel: (model: Function) => void;
   getListModule: () => Function | string;
   setListModule: (listModule: Function | string) => void;

   // endregion
}

Base.prototype._moduleName = 'Data/source:Base';
Base.prototype['[Data/_source/Base]'] = true;
// @ts-ignore
Base.prototype['[Data/_source/IData]'] = true;
