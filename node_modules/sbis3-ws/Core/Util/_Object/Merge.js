define('Core/Util/_Object/Merge', [
    'require',
    'exports'
], function (require, exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function isMergeableObject(o) {
        return o && (o.constructor === Object && !('$constructor' in o) || o.constructor === Array);
    }
    function cloneOrCopy(hash, hashExtender, key, cfg, path) {
        if (typeof hashExtender[key] === 'object' && hashExtender[key] !== null && cfg.clone) {
            if (isMergeableObject(hashExtender[key])) {
                hash[key] = merge(hashExtender[key] instanceof Array ? [] : {}, hashExtender[key], cfg, key, path);
            } else {
                hash[key] = hashExtender[key];
            }
        } else if (!(hashExtender[key] === null && cfg.noOverrideByNull)) {
            hash[key] = hashExtender[key];
        }
    }
    function merge(hash, hashExtender, cfg, currentKey, path) {
        if (cfg === undefined) {
            cfg = {};
        }
        cfg.preferSource = cfg.preferSource !== undefined ? cfg.preferSource : false;
        cfg.rec = cfg.rec !== undefined ? cfg.rec : true;
        cfg.clone = cfg.clone !== undefined ? cfg.clone : false;
        cfg.create = cfg.create !== undefined ? cfg.create : true;
        cfg.noOverrideByNull = cfg.noOverrideByNull !== undefined ? cfg.noOverrideByNull : false;
        if (hashExtender instanceof Date) {
            if (cfg.clone) {
                return new Date(hashExtender);
            }
            hash = hashExtender;
            return hash;
        }
        if (!path) {
            path = path || {
                keys: [],
                objects: []
            };
        }
        if (typeof hash === 'object' && hash !== null && typeof hashExtender === 'object' && hashExtender !== null) {
            path.keys.push(currentKey === undefined ? '.' : currentKey);
            if (path.objects.indexOf(hashExtender) > -1) {
                throw new Error('Recursive traversal detected for path "' + path.keys.join(' -> ') + '" with ' + hashExtender);
            }
            path.objects.push(hashExtender);
            for (var i in hashExtender) {
                if (!hashExtender.hasOwnProperty(i)) {
                    continue;
                }
                if (cfg.ignoreRegExp && cfg.ignoreRegExp.test(i)) {
                    continue;
                }
                if (hash[i] === undefined) {
                    if (cfg.create) {
                        if (hashExtender[i] === null) {
                            hash[i] = null;
                        } else {
                            cloneOrCopy(hash, hashExtender, i, cfg, path);
                        }
                    }
                } else if (!cfg.preferSource) {
                    if (hash[i] && typeof hash[i] === 'object' && typeof hashExtender[i] === 'object') {
                        if (hash[i] instanceof Date) {
                            if (hashExtender[i] instanceof Date) {
                                if (cfg.clone) {
                                    hash[i] = new Date(+hashExtender[i]);
                                } else {
                                    hash[i] = hashExtender[i];
                                }
                                continue;
                            } else {
                                hash[i] = hashExtender[i] instanceof Array ? [] : {};
                            }
                        } else if (hashExtender[i] instanceof Date) {
                            if (cfg.clone) {
                                hash[i] = new Date(+hashExtender[i]);
                            } else {
                                hash[i] = hashExtender[i];
                            }
                            continue;
                        }
                        if (cfg.rec && (isMergeableObject(hashExtender[i]) || hashExtender[i] === null) && Object.keys(hash[i]).length > 0) {
                            hash[i] = merge(hash[i], hashExtender[i], cfg, i, path);
                        } else {
                            hash[i] = hashExtender[i];
                        }
                    } else {
                        cloneOrCopy(hash, hashExtender, i, cfg, path);
                    }
                } else if (typeof hash[i] === 'object' && typeof hashExtender[i] === 'object' && cfg.rec) {
                    if (isMergeableObject(hashExtender[i]) || hashExtender[i] === null) {
                        hash[i] = merge(hash[i], hashExtender[i], cfg, i, path);
                    } else {
                    }
                }
            }
            path.keys.pop();
            path.objects.pop();
        } else if (!(hashExtender === null && cfg.noOverrideByNull) && !cfg.preferSource) {
            hash = hashExtender;
        }
        return hash;
    }
    exports.default = merge;
});