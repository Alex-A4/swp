define('Core/_Entity/Deferred', [
    'require',
    'exports',
    'Core/Util',
    'Core/Debug'
], function (require, exports, Util_1, Debug_1) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function DeferredCanceledError(message) {
        this.message = message;
        this.canceled = true;
    }
    DeferredCanceledError.prototype = Object.create(Error.prototype);
    var global = function () {
        return this || (0, eval)('this');
    }();
    global.DeferredCanceledError = DeferredCanceledError;
    var WAITING = -1, SUCCESS = 0, FAILED = 1, CANCELED = 2, CHAIN_INDEXES = [
            0,
            1,
            1
        ], STATE_NAMES = {};
    STATE_NAMES[WAITING] = 'waiting';
    STATE_NAMES[SUCCESS] = 'success';
    STATE_NAMES[FAILED] = 'failed';
    STATE_NAMES[CANCELED] = 'canceled';
    var Deferred = function () {
        function Deferred(cfg) {
            if (cfg) {
                if (cfg.cancelCallback) {
                    this._cancelCallback = cfg.cancelCallback;
                }
            }
            this._chained = false;
            this._chain = [];
            this._fired = WAITING;
            this._paused = 0;
            this._results = [
                null,
                null
            ];
            this._running = false;
        }
        Deferred.prototype.cancel = function () {
            if (this._fired === WAITING) {
                this._fired = CANCELED;
                this._results[CHAIN_INDEXES[this._fired]] = new DeferredCanceledError('Cancel');
                if (this.__parentPromise && this.__parentPromise.abort) {
                    this.__parentPromise.abort();
                }
                if (this._cancelCallback) {
                    var cbk = this._cancelCallback;
                    this._cancelCallback = null;
                    try {
                        cbk();
                    } catch (err) {
                        Util_1.IoC.resolve('ILogger').error('Deferred', 'Cancel function throwing an error: ' + err.message, err);
                    }
                }
                this._fire();
            }
            return this;
        };
        Deferred.prototype.callback = function (res) {
            if (!isCanceled(this)) {
                this._resback(this._check(res));
            }
            return this;
        };
        Deferred.prototype.errback = function (res, checkCallback) {
            if (!isCanceled(this)) {
                this._resback(this._check(res, true, checkCallback));
            }
            return this;
        };
        Deferred.prototype._resback = function (res) {
            this._cancelCallback = null;
            this._fired = resultToFired(res);
            this._results[CHAIN_INDEXES[this._fired]] = res;
            this._fire();
        };
        Deferred.prototype._check = function (res, isError, checkCallback) {
            var result = res;
            if (this._fired !== WAITING) {
                throw new Error('Deferred is already fired with state "' + STATE_NAMES[this._fired] + '"');
            }
            if (isDeferredValue(result)) {
                throw new Error('Deferred instances can only be chained if they are the result of a callback');
            }
            if (isError) {
                if (checkCallback !== false && Util_1.constants.isNodePlatform && !this._chain.some(function (pair) {
                        return typeof pair[1] === 'function';
                    })) {
                    Util_1.IoC.resolve('ILogger').error('Deferred', 'There is no callbacks attached to handle error');
                }
                if (!isErrorValue(result)) {
                    result = new Error(result);
                    if (result.number !== undefined && !Number.isNaN(result.number) && !result.message) {
                        result.message = '' + result.number;
                    }
                }
            }
            return result;
        };
        Deferred.prototype.addBoth = function (fn) {
            if (arguments.length !== 1) {
                throw new Error('No extra args supported');
            }
            return this.addCallbacks(fn, fn);
        };
        Deferred.prototype.finally = function (onFinally) {
            var callback = function () {
                return res;
            };
            var errback = function () {
                return err;
            };
            var promise = new Promise(function (resolve, reject) {
                callback = resolve;
                errback = reject;
            }).then(onFinally, onFinally);
            this.addCallbacks(function () {
                return callback();
            }, function () {
                return errback();
            });
            return promise;
        };
        Deferred.prototype.addCallback = function (fn) {
            if (arguments.length !== 1) {
                throw new Error('No extra args supported');
            }
            return this.addCallbacks(fn, null);
        };
        Deferred.prototype.then = function (onFulfilled, onRejected) {
            var callback = function (res) {
                return res;
            };
            var errback = function (err) {
                return err;
            };
            var promise = new Promise(function (resolve, reject) {
                callback = resolve;
                errback = reject;
            }).then(onFulfilled, onRejected);
            this.addCallbacks(function (res) {
                return callback(res);
            }, function (err) {
                return errback(err);
            });
            return promise;
        };
        Deferred.prototype.addErrback = function (fn) {
            if (arguments.length !== 1) {
                throw new Error('No extra args supported');
            }
            return this.addCallbacks(null, fn);
        };
        Deferred.prototype.catch = function (onRejected) {
            var errback = function (err) {
                return err;
            };
            var promise = new Promise(function (resolve, reject) {
                errback = reject;
            }).catch(onRejected);
            this.addErrback(function (err) {
                return errback(err);
            });
            return promise;
        };
        Deferred.prototype.addCallbacks = function (cb, eb) {
            if (this._chained) {
                throw new Error('Chained Deferreds can not be re-used');
            }
            if (cb !== null && typeof cb !== 'function' || eb !== null && typeof eb !== 'function') {
                throw new Error('Both arguments required in addCallbacks');
            }
            var fired = this._fired, waiting = fired === WAITING || this._running || this._paused > 0;
            if (waiting || cb && fired === SUCCESS || eb && (fired === FAILED || fired === CANCELED)) {
                this._chain.push([
                    cb,
                    eb
                ]);
                if (!waiting) {
                    this._fire();
                }
            }
            return this;
        };
        Deferred.prototype._fire = function () {
            var chain = this._chain;
            var fired = this._fired;
            var res = this._results[CHAIN_INDEXES[fired]];
            var self = this;
            var cb = null;
            while (chain.length > 0 && this._paused === 0) {
                var pair = chain.shift();
                var f = pair[CHAIN_INDEXES[fired]];
                if (f === null) {
                    continue;
                }
                try {
                    this._running = true;
                    res = Debug_1.Debug.methodExecutionTime(f, this, [res]);
                    fired = resultToFired(res);
                    if (isDeferredValue(res)) {
                        cb = function (cbRes) {
                            self._paused--;
                            self._resback(cbRes);
                        };
                        this._paused++;
                    }
                } catch (err) {
                    fired = FAILED;
                    res = isErrorValue(err) ? err : new Error(err);
                    Util_1.IoC.resolve('ILogger').error('Deferred', 'Callback function throwing an error: ' + err.message, err);
                } finally {
                    this._running = false;
                }
            }
            this._fired = fired;
            this._results[CHAIN_INDEXES[fired]] = res;
            if (cb && this._paused) {
                res.addBoth(cb);
                res._chained = true;
            }
        };
        Deferred.prototype.dependOn = function (master) {
            var _this = this;
            master.addCallbacks(function (v) {
                _this.callback(v);
                return v;
            }, function (e) {
                _this.errback(e);
                return e;
            });
            return this;
        };
        Deferred.prototype.createDependent = function () {
            var dependent = new Deferred();
            return dependent.dependOn(this);
        };
        Deferred.prototype.isReady = function (withChain) {
            return this._fired !== WAITING && (withChain ? !this._paused : true);
        };
        Deferred.prototype.isCallbacksLocked = function () {
            return this._chained;
        };
        Deferred.prototype.isSuccessful = function () {
            return this._fired === SUCCESS;
        };
        Deferred.prototype.getResult = function () {
            if (this.isReady()) {
                return this._results[CHAIN_INDEXES[this._fired]];
            }
            throw new Error('No result at this moment. Deferred is still not ready');
        };
        Deferred.fromTimer = function (delay) {
            var d = new Deferred();
            setTimeout(d.callback.bind(d), delay);
            return d;
        };
        Deferred.success = function (result) {
            return new Deferred().callback(result);
        };
        Deferred.fail = function (result) {
            var err = result instanceof Error ? result : new Error(result ? String(result) : '');
            return new Deferred().errback(err, false);
        };
        Deferred.nearestOf = function (steps) {
            var dResult = new Deferred();
            steps.forEach(function (step, key) {
                step.addBoth(function (r) {
                    if (!dResult.isReady()) {
                        if (r instanceof Error) {
                            var res = new Error();
                            res.from = key;
                            res.data = r;
                            dResult.errback(res);
                        } else {
                            dResult.callback({
                                from: key,
                                data: r
                            });
                        }
                    }
                    return r;
                });
            });
            if (steps.length === 0) {
                dResult.callback();
            }
            return dResult;
        };
        Deferred.callbackWrapper = function (deferred, callback) {
            if (deferred && deferred instanceof Deferred) {
                return deferred.addCallback(callback);
            }
            return callback(deferred);
        };
        Deferred.fromPromise = function (promise) {
            var def = new Deferred();
            def.__parentPromise = promise;
            promise.then(function (res) {
                def.callback(res);
            }).catch(function (err) {
                def.errback(err);
            });
            return def;
        };
        Deferred.toPromise = function (def) {
            return new Promise(function (resolve, reject) {
                def.createDependent().addCallbacks(function (res) {
                    resolve(res);
                }, function (err) {
                    reject(err);
                });
            });
        };
        return Deferred;
    }();
    function isCanceled(dfr) {
        return dfr._fired === CANCELED;
    }
    function isCancelValue(res) {
        return res instanceof DeferredCanceledError;
    }
    function isErrorValue(res) {
        return res instanceof Error;
    }
    function isDeferredValue(res) {
        return res instanceof Deferred;
    }
    function resultToFired(res) {
        return isCancelValue(res) ? CANCELED : isErrorValue(res) ? FAILED : SUCCESS;
    }
    exports.default = Deferred;
});