define('View/Runner/vdomutils', [
   'View/Runner/Vdom/third-party/inferno',
   'View/Runner/expressions/contextResolver',
   'View/Runner/Vdom/utils/optionsResolver',
   'View/Request',
   'View/Logger'
], function(
   Inferno,
   contextResolver,
   optionsResolver,
   Request,
   Logger
) {
   'use strict';

   var
      receivedName = '',
      configName = 'cfg-';

   /**
    * Для того чтобы всегда брать верхний компонент из конфига
    * @param configId
    * @returns {*}
    */
   function findTopConfig(configId) {
      return (configId + '').replace(configName, '').split(',')[0];
   }

   function fillCtx(control, vnode, resolvedCtx) {
      control._saveContextObject(resolvedCtx);
      control.saveFullContext(contextResolver.wrapContext(control, vnode.context || {}));
   }

   /**
    * Для того что бы звать сам метод, если он есть или с готовым состоянием
    * @param stateVar
    * @param control
    * @param vnode
    * @param serializer
    * @returns {*}
    */
   function getStateReadyOrCall(stateVar, control, vnode, serializer) {
      var data,
         srec = Request.getCurrent().stateReceiver;

      if (srec && srec.register) {
         srec.register(stateVar, {
            setState: function (rState) {
               data = rState;
            },
            getState: function () {
               return '';
            }
         });
      }


      /* Compat layer. For page without Controls.Application */
      if (!data && window["inline" + stateVar]) {
         data = JSON.parse(window["inline" + stateVar], serializer.deserialize);
         if (window["inline" + stateVar]) {
            window["inline" + stateVar] = undefined;
         }
      }

      var ctx = contextResolver.resolveContext(control.constructor, vnode.context || {}, control),
         res;

      try {
         res = data ? control._beforeMount(
            vnode.controlProperties,
            ctx,
            data
         ) : control._beforeMount(vnode.controlProperties, ctx);
      } catch (error) {
         Logger.catchLifeCircleErrors('_beforeMount', error);
      }

      if (res && res.callback) {
         res.addCallback(function(resultDef) {
            fillCtx(control, vnode, ctx);
            return resultDef;
         });
      } else {
         fillCtx(control, vnode, ctx);
      }

      if (!vnode.inheritOptions) {
         vnode.inheritOptions = {};
      }
      optionsResolver.resolveInheritOptions(vnode.controlClass, vnode, vnode.controlProperties);
      control.saveInheritOptions(vnode.inheritOptions);

      if (srec && srec.unregister) {
         srec.unregister(stateVar);
      }

      return res;
   }


   var VDomUtils = /** @lends $ws.proto.VDomUtils.prototype */{

      htmlNode: function(tagName, props, children, key, ref) {
         var vnode = Inferno.createVNode(VDomUtils.getFlagsForElementVnode(tagName),
            tagName,
            (props && props.attributes && props.attributes.class) || '',
            children,
            children && children.length ? (key ? 8 : 4) : 0,
            props.attributes,
            key,
            ref);
         vnode.hprops = props;
         return vnode;
      },

      textNode: function(text, key) {
         return Inferno.createTextVNode(text, key);
      },


      controlNode: function(controlClass, controlProperties, key) {
         return {
            controlClass: controlClass,
            controlProperties: controlProperties,
            key: key,
            controlNodeIdx: -1
         };
      },

      isVNodeType: function(vnode) {
         return vnode && (typeof vnode.children !== 'string' && typeof vnode.children !== 'number') && vnode.hasOwnProperty('dom');

         // return vnode && typeof vnode === 'object' && vnode.type === 'VirtualNode';
      },

      isTextNodeType: function(vnode) {
         return vnode && (typeof vnode.children === 'string' || typeof vnode.children === 'number') && vnode.hasOwnProperty('dom');

         // return vnode && typeof vnode === 'object' && vnode.type === 'VirtualText';
      },

      isControlVNodeType: function(vnode) {
         return vnode && typeof vnode === 'object' && 'controlClass' in vnode;
      },

      isTemplateVNodeType: function isTemplateVNodeType(vnode) {
         return vnode && typeof vnode === 'object' && vnode.type === 'TemplateNode';
      },

      /**
       * Получаем state из сгенерированного script
       * @param controlNode
       * @param vnode
       * @param Slr
       * @returns {*}
       */
      getReceivedState: function getReceivedState(controlNode, vnode, srlz) {
         var control = controlNode.control,
            rstate = controlNode.key ? findTopConfig(controlNode.key) : '';
         if (control._beforeMount) {
            return getStateReadyOrCall(rstate, control, vnode, srlz);
         }
      },

      getFlagsForElementVnode: function getFlagsForElementVnode() {
         return Inferno.getFlagsForElementVnode.apply(Inferno, [].slice.call(arguments));
      },

      patch: function patch() {
         return Inferno.patch.apply(Inferno, [].slice.call(arguments));
      },

      render: function render() {
         return Inferno.render.apply(Inferno, [].slice.call(arguments));
      },

      createRenderer: function() {
         return Inferno.createRenderer.apply(Inferno, [].slice.call(arguments));
      }

   };

   return VDomUtils;
});
