define('View/Runner/Text/markupGenerator', [
   'require',
   'View/Runner/markupGenerator',
   'View/Runner/common',
   'View/Runner/expressions/attr',
   'Core/helpers/Number/randomId',
   'Core/helpers/Hcontrol/configStorage',
   'View/Runner/Vdom/utils/optionsResolver',
   'View/Runner/expressions/subscriber',
   'Core/IoC',
   'View/Logger',
   'Core/constants',
   'View/Runner/expressions/scope',
   'Core/ParallelDeferred',
   'Core/Deferred',
   'View/Request',
   'Core/Serializer',
   'View/Runner/expressions/contextResolver',
   'View/Runner/focusHelper',
   'View/Runner/expressions/decorate',
   'View/Runner/requireHelper',
   'View/Runner/Text/templates/objectFunctionHeaderTemplate'
], function (
   require,
   MarkupGenerator,
   utils,
   attrExpressions,
   randomId,
   configStorage,
   optionsResolver,
   eventSubscriber,
   IoC,
   Logger,
   cConstants,
   scopeUtils,
   PDeferred,
   Deferred,
   Request,
   Serializer,
   contextResolver,
   FocusHelper,
   decorate,
   requireHelper
) {
   'use strict';

   var textMarkupGenerator = Object.create(MarkupGenerator);

   var voidElements = [
      'area',
      'base',
      'basefont',
      'br',
      'col',
      'command',
      'embed',
      'frame',
      'hr',
      'img',
      'input',
      'isindex',
      'keygen',
      'link',
      'meta',
      'param',
      'source',
      'track',
      'wbr',

      //common self closing svg elements
      'path',
      'circle',
      'ellipse',
      'line',
      'rect',
      'use',
      'stop',
      'polyline',
      'polygon'
   ];

   var
      isInstOfDeferred = function isInstOfDeferred(entity) {
         return entity instanceof Deferred;
      };


   function resolveControlName(controlData, attributes) {
      var attr = attributes || {};
      if (controlData && controlData.name) {
         attr.name = controlData.name;
      } else {
         if (attributes && attributes.name) {
            controlData.name = attributes.name;
         }
      }
      return attr;
   }

   function getDepsFromSerializer(slr) {
      var moduleInfo;
      var deps = [];
      var modules = slr._linksStorage;
      var parts;
      for(var key in modules) {
         if(modules.hasOwnProperty(key)) {
            moduleInfo = modules[key];
            if(moduleInfo.module) {
               parts = Serializer.parseDeclaration(moduleInfo.module);
               deps.push(parts.name);
            }
         }
      }
      return deps;
   }

   function buildForNewControl(scope, cnstr, decOptions) {
      var _options = scope.user;

      var dfd, result;

      _options['class'] = decOptions['class'];

      var eventsList = eventSubscriber.getEventsListFromOptions(_options);
      for (var key in eventsList) {
         if (eventsList.hasOwnProperty(key)) {
            delete _options[key];
         }
      }

      // не регаем тут контрол в паренте, потому что этот контрол нужен только для построения верстки, реальный контрол создастся при первой же синхронизации
      var doNotSetParent = _options.doNotSetParent;
      _options.doNotSetParent = true;

      var parentName = (_options._logicParent && _options._logicParent._moduleName) || '';
      optionsResolver.resolveOptions(cnstr, _options, parentName);

      var
         inst = new cnstr(_options),
         actualOptions = _options;

      actualOptions.doNotSetParent = doNotSetParent;

      /**
       * TODO: удалить это. По идее, VDOM контролы не должны генерировть строку если они в window
       */
      if (typeof window !== 'undefined') {
         eventSubscriber.subscribeEvents(inst, scope.internal.logicParent, eventsList);
      }
      if (inst._template) {
         /**
          * Сделать final проверку
          */
         if (inst.saveOptions) {
            inst.saveOptions(actualOptions);
         } else {
            inst._options = actualOptions;
         }

         try {
            dfd = inst._beforeMountLimited && inst._beforeMountLimited(actualOptions, scope.templateContext || {});
         } catch (error) {
            Logger.catchLifeCircleErrors('_beforeMount', error);
         }

         //TODO пропустить через contextResolver(где взять класс?)

         inst.saveInheritOptions(scope.inheritOptions || {});

         /**
          * Понимаем асинхронная ветка или нет
          */
         if (dfd && isInstOfDeferred(dfd)) {
            var def = new Deferred();
            dfd.addCallbacks(function (receivedState) {
               inst._saveContextObject(contextResolver.resolveContext(cnstr, scope.templateContext || {}));
               inst.saveFullContext(contextResolver.wrapContext(inst, scope.templateContext || {}));

               /*Ждем контролы*/
               inst = utils.plainMerge(inst, receivedState);
               _options.__$receivedState = receivedState;

               if (scope.templateContext.headData && scope.templateContext.headData.needObjects && receivedState && scope.templateContext.headData.addReceivedState) {
                  scope.templateContext.headData.addReceivedState(scope.key.replace('cfg-', ''), receivedState);
               } else if (scope.templateContext.headData && receivedState && scope.templateContext.headData.addReceivedState) {
                  var slr = new Serializer(),
                     serializedState = JSON.stringify(receivedState, slr.serialize);
                  utils.componentOptsReArray.forEach(function (re) {
                     serializedState = serializedState.replace(re.toFind, re.toReplace);
                  });
                  var deps = getDepsFromSerializer(slr);
                  for (var i = 0; i < deps.length; i++) {
                     scope.templateContext.headData.pushDepComponent(deps[i], true);
                  }
                  scope.templateContext.headData.addReceivedState(scope.key.replace('cfg-', ''), serializedState);
               }

               Request.getCurrent().stateReceiver.register(scope.key, {
                  getState: function() {
                     return receivedState;
                  }
               });

               result = inst._template ? inst.render(null, decOptions) : '';
               if (result.callback) {
                  result.addCallbacks(function (res) {
                     if(!scope.templateContext.headData) {
                        res = textMarkupGenerator.makeInlineConfigs(res, scope.key, receivedState);
                     }
                     def.callback({
                        result: res,
                        receivedState: receivedState
                     });
                  }, function (err) {
                     utils.asyncRenderErrorLog(err);
                     def.callback({
                        result: asyncRenderErrorTag(inst),
                        receivedState: undefined
                     });
                  });
               } else {
                  if(!scope.templateContext.headData) {
                     result = textMarkupGenerator.makeInlineConfigs(result, scope.key, receivedState);
                  }
                  def.callback({
                     result: result,
                     receivedState: receivedState
                  });
               }
            }, function (err) {
               utils.asyncRenderErrorLog(err);
               def.callback({
                  result: asyncRenderErrorTag(inst),
                  receivedState: undefined
               });
            });
            return def;
         } else {
            inst._saveContextObject(contextResolver.resolveContext(cnstr, scope.templateContext || {}));
            inst.saveFullContext(contextResolver.wrapContext(inst, scope.templateContext || {}));
         }
      }
      result = inst._template ? inst.render(undefined, decOptions) : '';
      return result;
   }

   function buildMarkupForClass(cnstr, scope, context, varStorage, decOptions) {
      var _options = scope.user, result;
      decOptions = resolveControlName(_options, decOptions);
      result = buildForNewControl({
         user: _options,
         internal: scope.internal,
         templateContext: scope.templateContext,
         inheritOptions: scope.inheritOptions,
         key: scope.key
      }, cnstr, decOptions);

      return result;
   }


   /**
    * Если существует другой разрешатель имен в config.js. Мы его найдем и используем для подключения.
    * @param tpl
    * @param includedTemplates
    * @param _deps
    * @param config
    * @returns {*}
    */
   function stringTemplateResolver(tpl, includedTemplates, _deps, config) {
      var resolver = config && config.resolvers ? utils.findResolverInConfig(tpl, config.resolvers) : undefined;
      if (resolver) {
         return resolver(tpl);
      } else {
         return utils.depsTemplateResolver(tpl, includedTemplates, _deps, config);
      }
   }

   /**
    * Создаем строку с тегом для повторного выполнения
    * _beforeMount на клиенте и обработки ошибок
    * @param inst
    * @returns {string}
    */
   function asyncRenderErrorTag(inst) {
      var decoratorObject = {}, options;
      if (inst && inst._options) {
         options = inst._options;
         decoratorObject = decorate.createRootDecoratorObject(
            options['__$config'],
            true,
            options['data-component'],
            {}
         );
      }
      return textMarkupGenerator.createTag('div', {attributes:decoratorObject}, []);
   }

   textMarkupGenerator.createController = function () {
      /**
       * В VDom идеологии контроллер - это пустая текстовая нода. И она имеет смысл только в VDom
       * Получается, для экономии ресурсов нам не надо вызвать конструктор компонента здесь,
       * ведь результат все равно никак не сохранить
       * Нужно ли здесь вызывать beforeMount? Такой задачи не известно, ведь обращаться к данным,
       * которые может вернуть контрол в beforeMount может только он сам.
       * А если он не визуальный, зачем тогда ему какие-то данные проксировать через текстовый вид?
       */
      return '';
   };

   textMarkupGenerator.createEmptyText = function(){
      return '';
   };

   textMarkupGenerator.createWsControl = function createWsControl(tpl, scope, attributes, context, _deps) {

      var data = this.prepareDataForCreate(tpl, scope, attributes, _deps);

      var dataComponent = data.dataComponent;
      Logger.log('createWsControl', [dataComponent, data.controlProperties]);
      Logger.log('Context for control', ['', attributes.context]);
      Logger.log('Inherit options for control', ['', attributes.inheritOptions]);

      var varStorage = null,
         cnstr = data.controlClass,
         resultingFn = cnstr && cnstr.prototype._template;

      if (!cnstr && !resultingFn){
         return '';
      }

      if (cnstr && !resultingFn) {
         return textMarkupGenerator.createController(cnstr, scope, attributes, context, _deps);
      }

      var _options = data.controlProperties;
      if (!_options['data-component']) {
         _options['data-component'] = dataComponent;
      }

      /**
       * Опции для dirtyChecking будем прокидывать только в VDOM
       */
      for (var di = 0; _options.hasOwnProperty("__dirtyCheckingVars_" + di); di++) {
         delete _options["__dirtyCheckingVars_" + di];
      }

      return buildMarkupForClass(cnstr, {
         user: _options,
         internal: data.internal,
         templateContext: attributes.context,
         inheritOptions: attributes.inheritOptions,
         key: attributes.key
      }, context, varStorage, attributes);
   };
   textMarkupGenerator.createTemplate = function createTemplate(name, scope, attributes, context, _deps, config) {

      var resultingFn,
         resolver = utils.hasResolver(name, config && config.resolvers);
      if (utils.isString(name)) {
         if (resolver) {
            resultingFn = config.resolvers[resolver](name);
         } else {
            resultingFn = _deps && _deps[name] || require(name);
            if (resultingFn && utils.isOptionalString(name) && !utils.isTemplateString(name)) {
               return this.createWsControl(name.split('js!')[1], scope, attributes, context, _deps);
            }
         }
      } else {
         resultingFn = name;
      }

      var data = this.prepareDataForCreate(name, scope, attributes, _deps );

      var parent = data.parent,
         resolvedScope = data.controlProperties;

      Logger.log('createTemplate', [utils.isString(name)?name:'InlineFunction', data.controlProperties, resultingFn]);
      Logger.log('Context for template', ['', attributes.context]);
      Logger.log('Inherit options for template', ['', attributes.inheritOptions]);
      // Здесь можем получить null  в следствии !optional. Поэтому возвращаем ''
      return resultingFn === null ? '' : (parent ? resultingFn.call(parent, resolvedScope, attributes, context):resultingFn(resolvedScope, attributes, context));
   };
   function decorateAttrs(attr1, attr2) {
      function wrapUndef(value) {
         if (value === undefined || value === null) {
            return "";
         } else {
            return value;
         }
      }

      var attrToStr = function (attrs) {
         var str = '';
         for (var attr in attrs) {
            if (attrs.hasOwnProperty(attr)) {
               str += (wrapUndef(attrs[attr]) !== '' ? ' ' + (attr + '="' + attrs[attr] + '"') : '');
            }
         }
         return str;
      };
      return attrToStr(textMarkupGenerator.joinAttrs(attr1, attr2));
   }

   textMarkupGenerator.resolver = function resolver(tpl, preparedScope, decorAttribs, context, _deps, includedTemplates, config, defCollection) {

      var isTplString = typeof tpl === "string",
         fn = isTplString ? stringTemplateResolver(tpl, includedTemplates, _deps, config) : tpl,
         // нужно для того чтобы не запускать генерацию шаблона на имени модуля
         notModuleString = !(isTplString && utils.isStringModules(tpl)),
         resolvedScope;
      var data = this.prepareDataForCreate(tpl, preparedScope, decorAttribs, _deps, includedTemplates );
      resolvedScope = data.controlProperties;

      if (utils.isControlClass(fn)) {
         /**
          * Сейчас оживление контролов построено на атрибуте data-component
          * и если вдруг мы туда запишем неправильный moduleName то все упадет
          * Контрол будет создан не от того класса, поэтому для решения проблем такой
          * совместимости пропатчим _moduleName правильным значением
          */
         if (isTplString && tpl.indexOf('js!') !== -1 && !requireHelper.defined(fn.prototype._moduleName)) {
            fn.prototype._moduleName = tpl.split('js!')[1];
         }
         if (fn.prototype._template) {
            return textMarkupGenerator.createWsControl(fn, preparedScope, decorAttribs, context, _deps);
         }
      } else {
         Logger.log('Resolver', [isTplString?tpl:'InlineFunction', data.controlProperties, fn]);
         Logger.log('Context for template', ['', decorAttribs.context]);
         Logger.log('Inherit options for template', ['', decorAttribs.inheritOptions]);

         var r;
         if (typeof fn === 'function') {
            r = preparedScope&&data.parent?fn.call(data.parent, resolvedScope, decorAttribs, context, false):
               fn(resolvedScope, decorAttribs, context, false);
         } else if (fn && typeof fn.func === 'function') {
            r = preparedScope&&data.parent?fn.func.call(data.parent, resolvedScope, decorAttribs, context, false):
               fn.func(resolvedScope, decorAttribs, context, false);
         } else if (utils.isArray(fn)) {
            r = preparedScope && data.parent ?
               fn.map(function (template) {
                  if (typeof template === 'function') {
                     return template.call(data.parent, resolvedScope, decorAttribs, context, false);
                  } else if (typeof template.func === 'function') {
                     return template.func.call(data.parent, resolvedScope, decorAttribs, context, false);
                  }
                  return template;
               })
               :
               fn.map(function (template) {
                  if (typeof template === 'function') {
                     return template(resolvedScope, decorAttribs, context, false);
                  } else if (typeof template.func === 'function') {
                     return template.func(resolvedScope, decorAttribs, context, false);
                  }
                  return template;
               });
            r = textMarkupGenerator.joinElements(r, undefined, defCollection);
         } else {
            if (tpl === undefined) {
               IoC.resolve('ILogger').error('Undefined component error', 'Попытка использовать компонент/шаблон, ' +
                  'но вместо компонента в шаблоне был передан undefined! ' +
                  'Если верстка строится неправильно, нужно поставить точку останова и исследовать стек вызовов. ' +
                  'По стеку будет понятно, в каком шаблоне и в какую опцию передается undefined'
               );
               return '';
            } else {
               r = tpl;
            }
         }
         return r;
      }
   };

   textMarkupGenerator.joinElements = function joinElements(elements, key, defCollection) {
      if (Array.isArray(elements)) {
         var res = '';
         elements.forEach(function joinOneElement(element) {
            var id;
            if (Array.isArray(element)) {
               element = textMarkupGenerator.joinElements(element, undefined, defCollection);
            }
            if (element && isInstOfDeferred(element)) {
               id = randomId('def-');
               if (!defCollection.def) {
                  defCollection.def = new PDeferred({stopOnFirstError: false});
               }
               defCollection.def.push(element);
               element = '[' + id + ']';
               defCollection.id.push(element);
            }
            res += (element || '');
         });
         
         return res;
      } else {
         throw new Error('joinElements: elements is not array');
      }
   };
   /**
    *
    * @param tag
    * @param attrs Собственные атрибуты
    * @param children
    * @param attr
    * @param defCollection
    * @returns {string}
    */
   textMarkupGenerator.createTag = function createTag(tag, attrs, children, attrToDecorate, defCollection) {
      if (!attrToDecorate){
         attrToDecorate = {};
      }
      if (!attrs){
         attrs = {};
      }

      var mergedAttrs = attrExpressions.processMergeAttributes(attrToDecorate.attributes, attrs.attributes, true);

      FocusHelper.prepareTabindex(mergedAttrs);
      // remove focus attributes from object
      textMarkupGenerator.cutFocusAttributes(mergedAttrs);

      var mergedAttrsStr = mergedAttrs
         ? decorateAttrs(mergedAttrs, {})
         : '';

      if (~voidElements.indexOf(tag)) {
         return '<' + tag + mergedAttrsStr + ' />';
      }
      return '<' + tag + mergedAttrsStr + '>' + textMarkupGenerator.joinElements(children, undefined, defCollection) + '</' + tag + '>';
   };
   textMarkupGenerator.createText = function createText(text) {
      return text;
   };
   textMarkupGenerator.createDirective = function createDirective(text) {
      return '<' + text + '>';
   };
   textMarkupGenerator.createComment = function createComment(text) {
      return '<!--' + text + '-->';
   };
   textMarkupGenerator.makeInlineConfigs = function makeInlineConfigs(res, optionsConfig, receivedState) {
      var ser = textMarkupGenerator.serializeReceivedState(receivedState);
      return res +
         '<script type="text/javascript" data-vdomignore="true">window.inline' +
         optionsConfig.replace('cfg-', '') +
         '=\'' +
         ser +
         '\';</script>';

   };
   textMarkupGenerator.serializeReceivedState = function serializeReceivedState(receivedState) {
      var slr = new Serializer(),
         ser = JSON.stringify(receivedState, slr.serialize);

      // заменяем опасные символы, коотрые могут привести к синтаксическим ошибкам
      utils.componentOptsReArray.forEach(function (re) {
         ser = ser.replace(re.toFind, re.toReplace);
      });
      return ser;
   };
   textMarkupGenerator.saveConfig = function saveConfig(configId, inst) {
      /**
       * Сохраним инстанс в configStorage
       */
      if (typeof window !== "undefined") {
         var configObj = {};
         configObj[configId] = inst;
         configStorage.merge(configObj);
      }
   };
   textMarkupGenerator.calculateScope = function calculateScope(scope) {
      return scopeUtils.calculateScope(scope, scopeUtils.controlPropMerge);
   };

   textMarkupGenerator.buildMarkupForClass = buildMarkupForClass;

   textMarkupGenerator.escape = utils.escape;

   // TODO удалить когда слой совместимости будет не нужен

   if (cConstants.isBrowserPlatform && cConstants.compat) {
      require(['View/Runner/Text/markupGeneratorCompatible']); // compatible behavior is initialised in markupGeneratorCompatible
   }

   return textMarkupGenerator;
});
