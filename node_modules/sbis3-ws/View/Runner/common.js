define('View/Runner/common', [
   'require',
   'Core/constants',
   'Core/RightsManager',
   'Core/helpers/Object/isPlainObject',
   'View/Runner/expressions/attr',
   'Core/IoC',
   'View/Runner/requireHelper'
], function utilsLoader(require,
                        constants,
                        RightsManager,
                        isPlainObject,
                        attrExpressions,
                        IoC,
                        requireHelper) {
   'use strict';

   var plainMergeContext = function plainMergeContext(inner, object){
      if (!inner) {
         inner = {};
      }
      if (!object){
         object = {};
      }
      var controlKey;
      if (object.attributes && object.attributes['attr:key']) {
         controlKey = object.attributes['attr:key'];
      }
      controlKey = controlKey || object.key || inner.key;

      return {
         attributes: object.attributes || {},
         events: object.events || {},
         inheritOptions: inner.inheritOptions,
         internal: inner.internal,
         context: inner.context,
         key: controlKey
      };
   };

   var plainMerge = function plainMerge(inner, object, cloneFirst) {
         var copyInner = {},
            prop;
         if (!inner) {
            inner = {};
         }
         if (!object){
            object = {};
         }

         if (cloneFirst) {
            for (prop in inner) {
               if (inner.hasOwnProperty(prop)) {
                  copyInner[prop] = inner[prop];
               }
            }
         } else {
            copyInner = inner;
         }
         for (prop in object) {
            if (object.hasOwnProperty(prop)) {
               copyInner[prop] = object[prop];
            }
         }
         return copyInner;
      },
      plainMergeAttr = function plainMergeAttr(inner, object) {
         var copyInner = {},
            prop;
         if (!inner) {
            inner = {};
         }
         if (!object){
            object = {};
         }

         /*
          * Атрибуты из шаблона не нужны в VDom контролах
          * */
         var isBadOldAttrs = false;
         if (object.attributes && Object.keys(object.attributes).length === 2 && object.attributes['name']===object.attributes['sbisname']
            && object.attributes['sbisname'] !== undefined){
            object = {};
         }

         var controlKey;
         if (object.attributes && object.attributes['attr:key']) {
            controlKey = object.attributes['attr:key'];
         }
         controlKey = controlKey || object.key || inner.key;

         copyInner = {
            inheritOptions: object.inheritOptions,
            context: inner.context,
            internal: inner.internal,
            systemOptions: {},
            domNodeProps: {},
            key: controlKey
         };
         copyInner.attributes = attrExpressions.processMergeAttributes(inner.attributes, object.attributes);
         copyInner.events = attrExpressions.processMergeAttributes(inner.events, object.events);
         return copyInner;

      },
      isFunction = function isFunction (fn) {
         return (Object.prototype.toString.call(fn) === '[object Function]');
      },
      isProtoSupported = function isProtoSupproted() {
         return Object.__proto__;
      },
      // Если есть prototype будем идти как для всех
      // При отсутствии поддержки __proto__ отдаем ссылку
      isNewObject = function isNewObject(scope) {
         return (scope && scope.prototype) || isProtoSupported();
      },
      /**
       * Для поиска резолвера имен в конфине, если он есть.
       * @param name
       * @param resolvers
       * @returns {*}
       */
      hasResolver = function hasResolver(name, resolvers) {
         for (var resolver in resolvers)  {
            if (resolvers.hasOwnProperty(resolver)) {
               return name.indexOf(resolver) === 0 ? resolver : undefined;
            }
         }
      },
      requireIfDefined = function requireIfDefined(tpl) {
         return requireHelper.defined(tpl) && requireHelper.require(tpl);
      },
      tryLoadLibraryModule = function tryLoadLibraryModule(tpl, _deps) {
         if (utils.isLibraryModuleString(tpl)) {
            // if tpl is a library module name, check if the library is already loaded in _deps
            // or already defined with require
            var
               libPath = utils.splitModule(tpl),
               library = _deps && _deps[libPath.library] || requireIfDefined(libPath.library);

            // if the library was found, return the requested module from it
            return library && library[libPath.module];
         }
         return null;
      },
      /**
       * Стандартный резолвер для имен, которые передают в partial.
       * @param tpl
       * @param includedTemplates
       * @param _deps
       * @returns {*}
       */
      checkExistingModule =  function checkExistingModule(tpl, includedTemplates, _deps) {
         return includedTemplates && includedTemplates[tpl]
            || _deps && (_deps[tpl] || _deps['optional!'+tpl])
            || requireIfDefined(tpl)
            || tryLoadLibraryModule(tpl, _deps);
      },
      moduleNameCheckProceed = function maxNameLengthCheck(tpl, includedTemplates, _deps, config) {
         if (config && config.moduleMaxNameLength) {
            if (tpl.length > config.moduleMaxNameLength) {
               return false;
            }
         }
         return checkExistingModule(tpl, includedTemplates, _deps);
      },
      conventionalStringResolver = function conventionalStringResolver(tpl, includedTemplates, _deps, config) {
         if (tpl && tpl.length) {
            return moduleNameCheckProceed(tpl, includedTemplates, _deps, config);
         }
      };

   var entityRightsHandlers = {
      object: {
         getMinAccessLevel: function(object, minLevelDefault) {
            var minAccessLevel;

            if (typeof object['data-access-min-level'] !== 'undefined') {
               minAccessLevel = object['data-access-min-level'];
            } else if (typeof object['dataAccessMinLevel'] !== 'undefined') {
               IoC.resolve('ILogger').info('entityHelpers', 'Для задания минимального уровня доступа для опции, используйте data-access-min-level вместо dataAccessMinLevel.');
               minAccessLevel = object['dataAccessMinLevel'];
            }

            if (typeof minAccessLevel === 'string') {
               minAccessLevel = parseInt(minAccessLevel, 10);
            }
            if (typeof minAccessLevel !== 'number' || isNaN(minAccessLevel)) {
               // если полученный minAccessLevel - не число, возвращаемся ко значению по умолчанию
               minAccessLevel = minLevelDefault;
            }

            return minAccessLevel;
         },
         isAccessible: function (object, minLevel) {
            var
               accessString,
               access;

            if (typeof minLevel === 'undefined') {
               minLevel = 1;
            }
            access = minLevel;

            if (typeof object['data-access'] !== 'undefined') {
               accessString = object['data-access'];
            } else if (typeof object['dataAccess'] !== 'undefined') {
               IoC.resolve('ILogger').info('entityHelpers', 'Для задания зоны доступа для опции, используйте data-access вместо dataAccess.');
               accessString = object['dataAccess'];
            }

            if (typeof accessString === 'string') {
               access = RightsManager.checkAccessRights(accessString.split(','));
            }

            return access >= minLevel;
         },
         iterate: function (object, callback) {
            for (var key in object) {
               if (object.hasOwnProperty(key)) {
                  callback(object[key], key, object);
               }
            }
            return object;
         },
         remove: function (object, key) {
            delete object[key];
         }
      },
      array: {
         getMinAccessLevel: function(array, minLevel) {
            return minLevel;
         },
         isAccessible: function () {
            return true;
         },
         iterate: function (array, callback) {
            for (var i = array.length - 1; i >= 0; i--) {
               callback(array[i], i, array);
            }
            return array;
         },
         remove: function (array, index) {
            array.splice(index, 1);
         }
      }
   };

   var utils = {
      mapForLoop: function mapForLoop(array, mapFunction) {
         var arrayLen = array.length,
            newArray = new Array(arrayLen),
            i;
         for (i = 0; i < arrayLen; i++) {
            newArray[i] = mapFunction(array[i], i, array);
         }
         return newArray;
      },
      eachObject: function eachObject(object, modifier) {
         var value;
         for (value in object) {
            if (object.hasOwnProperty(value)) {
               object[value] = modifier(object[value], value);
            }
         }
         return object;
      },
      inArray: function inArray(array, needle) {
         var i;
         for (i = 0; i < array.length; i++) {
            if (array[i] === needle) {
               return true;
            }
         }
         return false;
      },
      isNode: function isNode() {
         return (typeof global !== 'undefined' && Object.prototype.toString.call(global.process) === '[object process]');
      },
      isNumber: function isNumber(string) {
         return /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*)(?:[eE][+-]?\d+)?)$/.test(string.trim());
      },
      isString: function isString(string) {
         return (Object.prototype.toString.call(string) === '[object String]');
      },
      isFunction: isFunction,
      isArray: function isArray(array) {
         return (Object.prototype.toString.call(array) === '[object Array]');
      },
      removeAllSpaces: function removeAllSpaces(string) {
         return string.replace(/\s/g, "");
      },
      notUndefOrNull: function notUndefOrNull(value) {
         return value || value === 0 || value === '' || value === false;
      },
      checkProp: function checkProp(object, prop) {
         return object && object[prop] !== undefined;
      },
      isEmpty: function isEmpty(obj) {
         for(var prop in obj) {
            if(obj.hasOwnProperty(prop))
               return false;
         }
         return true;
      },
      clone: function clone(src) {
         function mixin(dest, source, copyFunc) {
            var name, s, i, empty = {};
            for (name in source) {
               s = source[name];
               if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                  dest[name] = copyFunc ? copyFunc(s) : s;
               }
            }
            return dest;
         }

         if (!src || typeof src != "object" || Object.prototype.toString.call(src) === "[object Function]") {
            return src;
         }
         if (src.nodeType && "cloneNode" in src) {
            return src.cloneNode(true);
         }
         if (src instanceof Date) {
            return new Date(src.getTime());
         }
         if (src instanceof RegExp) {
            return new RegExp(src);
         }
         var r, i, l;
         if (src instanceof Array) {
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
               if (i in src) {
                  r.push(clone(src[i]));
               }
            }
         } else {
            r = src.constructor ? new src.constructor() : {};
         }
         return mixin(r, src, clone);
      },
      plainMergeAttrs: function plainMergeAttrs(inner, attrs) {
         return plainMerge(inner, attrs);
      },

      escape: function escape(entity) {
         if (entity && typeof entity === 'string') {
            var tagsToReplace = {
               '<'   : '&lt;',
               '>'   : '&gt;',
               "'"   : '&apos;',
               "\""  : '&quot;',
               '{{'   : '&lcub;&lcub;',
               '}}'   : '&rcub;&rcub;'
            };
            entity = entity.replace(/&([^#])/g, function escapeReplace(tag, suffix) {
               return '&amp;' + suffix;
            });

            return entity.replace(/({{)|(}})|([<>'"])/g, function escapeReplace(tag) {
               return tagsToReplace[tag] || tag;
            });
         }
         return entity;
      },
      // Для того чтобы при прогоне второй раз в dot, все конструкции эскейпились
      escapeParenthesis: function escapeParenthesis(entity) {
         if (entity && typeof entity === 'string') {
            var tagsToReplace = {
               '{{'   : '&lcub;&lcub;',
               '}}'   : '&rcub;&rcub;'
            };
            return entity.replace(/({{)|(}})/g, function escapeReplace(tag) {
               return tagsToReplace[tag] || tag;
            });
         }
         return entity;
      },
      createNewScope: function createNewScope(object) {
         return  { __rootScope: object };
      },
      bindingArrayHolder: function bindingArrayHolder(bindings, value) {
         if (!bindings) {
            bindings = [];
         }
         bindings.push(value);
         return bindings;
      },
      toEqual: function toEqual(eq, to) {
         return eq === to;
      },
      hasResolver: hasResolver,
      /**
       * Для использования найденного резолвера имен для partial
       * @param name
       * @param resolvers
       * @returns {*}
       */
      findResolverInConfig: function findResolverInConfig(name, resolvers) {
         var resolverName = hasResolver(name, resolvers);
         if (resolverName) {
            return resolvers[resolverName];
         }
      },
      plainMerge: plainMerge,
      plainMergeAttr: plainMergeAttr,
      plainMergeContext: plainMergeContext,
      addArgument: function (value, args) {
         var argArr = Array.prototype.slice.call(args);
         if (argArr[0] === undefined) {
            argArr[0] = undefined;
         }
         if (argArr[1] === undefined) {
            argArr[1] = undefined;
         }
         if (argArr[2] === undefined) {
            argArr[2] = undefined;
         }

         // опция isVdom. если true - будет строить vdom.
         // если ПП, то в любом случае false
         argArr[3] = argArr[3] && !constants.isBuildOnServer;

         argArr.push(value);
         return argArr;
      },
      capitalize: function capitalize(string) {
         return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
      },
      findInArray: function findInArray(needle, arr) {
         return arr && ~arr.indexOf(needle);
      },
      applyRights: function applyRights(attrs, controlData) {
         var attr = attrs && attrs['data-access'],
            rightsNeeded = RightsManager.rightsNeeded();
         if (attr && rightsNeeded) {
            switch (RightsManager.checkAccessRights(attr.split(','))) {
               case 0:
                  return false;
               case 1:
                  // Меняем права если "только для чтения", иначе отдадим как есть
                  var displayNode = controlData['display'];
                  if (displayNode) {
                     controlData['readOnly'] = true;
                     controlData['enabled'] = true;
                     controlData['allowChangeEnable'] = false;
                  } else {
                     controlData['enabled'] = false;
                     controlData['allowChangeEnable'] = false;
                  }
                  return true;
            }
         }
         this.applyRightsToEntity(controlData, 1);

         // Если по правам были удалены какие-то опции контрола, проверим, нет ли биндинга на эти опции. При обнаружении таких связей - удалим.
         this.removeBindCutOption(controlData);
         return true;
      },
      applyRightsToEntity: function applyRightsToEntity(entity, minAccessLevel) {
         var
            self = this,
            typeHandler;

         if (Array.isArray(entity)) {
            typeHandler = entityRightsHandlers.array;
         } else if (isPlainObject(entity)) {
            typeHandler = entityRightsHandlers.object;
         } else {
            return entity;
         }

         minAccessLevel = typeHandler.getMinAccessLevel(entity, minAccessLevel);
         if (!typeHandler.isAccessible(entity, minAccessLevel)) {
            return undefined;
         }

         entity = typeHandler.iterate(entity, function(value, index, scope) {
            if (value && value['__isRightsChecked']){
               return;
            }

            if (isPlainObject(value)){
               /**
                * Патчим объект "незаметно" для других.
                * Методы перебора не заметят нового свойства, а по прямому прозвону мы его увидим
                * в ИЕ работает :)
                */
               Object.defineProperty(value, '__isRightsChecked', {enumerable: false, value: true});
            }
            scope[index] = self.applyRightsToEntity(value, minAccessLevel);
            if (scope[index] === undefined) {
               typeHandler.remove(scope, index);
            }
         });

         return entity;
      },
      /**
       * Обходим существующие бинды контрола. Ищем связи с опциями. Если есть бинд на опцию, а опции нет - удалим такой бинд.
       * Исключниями являются бинды которые не смотрят на опции контрола.
       * Опция компонента может быть вырезана правами.
       */
      removeBindCutOption: function removeBindCutOption(controlData){
         var isPath = false,
            whiteList = [],
            pathTemp,
            bindings,
            bindItem,
            urlBind;

         if (controlData && controlData.bindings && controlData.bindings.length) {
            bindings = controlData.bindings;
            // Осуществляем обход по биндам контрола
            for (var bindNumber = 0, bindlength = bindings.length; bindNumber < bindlength; bindNumber++ ) {
               isPath = false;
               pathTemp = controlData;
               bindItem = bindings[bindNumber];
               // Если есть путь до опции, разберем его на массив
               if ( bindItem.propPath && bindItem.propPath.length ) {
                  urlBind = bindItem.propName.split('/');
               } else {
                  urlBind = [];
               }

               // Отсутствие пути у бинда значит, что он забинден не на опцию компонента. Такой бинд сразу пропускаем.
               if (urlBind.length) {
                  // Пытаемся пройти по опциям контрола используя путь который вытащили из бинда
                  for (var i = 0, urlLength = urlBind.length; i < urlLength; i++) {
                     if (pathTemp.hasOwnProperty(urlBind[i])) {
                        pathTemp = pathTemp[urlBind[i]];
                        if (i + 2 === urlLength) {
                           // Удалось пройти по пути, опция не удалена.
                           isPath = true;
                        }
                     } else {
                        break;
                     }
                  }
               } else {
                  isPath = true;
               }

               if (isPath) {
                  // Если опция не удалена или бинд смотрит не на опцию контрола - добавляем бинд в белый список
                  whiteList.push(bindings[bindNumber]);
               }
            }
            // Заменим массив биндов на "проверенный" массив биндов
            controlData.bindings = whiteList;
         }
      },
      isTemplateString: function isTemplateString(str) {
         return str.indexOf('wml!') === 0 || str.indexOf('tmpl!') === 0 || str.indexOf('html!') === 0 || str.indexOf('optional!tmpl!') === 0;
      },
      isControlString: function isControlString(str) {
         return str.indexOf('js!') === 0;
      },
      isOptionalString: function isOptionalString(str) {
         return str.indexOf('optional!') === 0;
      },
      isLibraryModuleString: function isLibraryModuleString(str) {
         // library module string example: SomeStorage.Library:Module
         var name = str.indexOf('ws:') === 0 ? utils.splitWs(str) : str;
         return name.indexOf(':') >= 0 && name.indexOf('<') === -1 && name.indexOf(' ') === -1;
      },

      // для обработки контролов без js, через partial
      isSlashedControl: function isSlashedControl(str) {
         return str.split('/').length > 1 && !utils.isTemplateString(str) && str.indexOf('<') === -1 && str.indexOf(' ') === -1;
      },
      isStringModules: function isStringModules(str, config) {
         return utils.isOptionalString(str) || utils.isTemplateString(str) || utils.isControlString(str) || utils.isSlashedControl(str) || utils.hasResolver(str, config && config.resolvers);
      },
      isControlClass: function isControlClass(controlClass) {
         var prototype = controlClass && controlClass.prototype;
         // Проверка на typeof добавлена в следствии странной ошибки https://inside.tensor.ru/opendoc.html?guid=872a7e36-7487-4362-88d0-eaf0e66cb6b6
         // По какой-то причине проверка controlClass && controlClass.prototype проходила и свойство $constructor вызывалось на undefined.
         if (prototype && typeof prototype !== 'undefined') {
            return prototype.$constructor || prototype._template;
         }
         return false;
      },
      splitModule: function splitModule(string) {
         var
            moduleName = string.indexOf('ws:') === 0 ? utils.splitWs(string) : string,
            moduleSplit = moduleName.split(':');
         return {
            library: moduleSplit[0],
            module: moduleSplit[1]
         };
      },
      splitOptional: function splitOptional(string) {
         var ws;
         ws = string.split('optional!');
         return ws[1];
      },
      splitJs: function splitJs(string) {
         var ws;
         ws = string.split('js!');
         return ws[1];
      },
      splitWs: function splitWs(string) {
         var ws;
         if (string !== undefined && string.indexOf('ws:')===0) {
            ws = string.split('ws:');
            return ws[1];
         }
         return undefined;
      },
      correctName: function(name) {
         var newName = utils.splitWs(name);
         if (newName) {
            return newName;
         }
         return name;
      },
      getConstructor: function(_deps, name) {
         var res = _deps && _deps['js!' + name] || requireHelper.defined('js!' + name) ? require('js!' + name) : require(name);
         if(!res && /optional!/.test(name)) {
            var optionalRequireName = name.split('optional!')[1];
            if(requireHelper.defined(optionalRequireName)) {
               res = require(optionalRequireName);
            }
         }
         return res;
      },
      isCompound: function(ctor){
         //CompoundControl на прототипе не имеет $constructor, и контролы, унаследовавшиеся от него и не переопределившие
         //$constructor не пройдут эту проверку. Поэтому добавлено поле _isCoreCompound.
         return (ctor.prototype.$constructor && !ctor.prototype._template) || ctor.prototype._dotTplFn || ctor.prototype._isCoreCompound;
      },
      isNewControl: function(ctor) {
         return !utils.isCompound(ctor);
      },
      asyncRenderErrorLog: function asyncRenderErrorLog(err) {
         IoC.resolve('ILogger').error('ASYNC RENDER ERROR', err.stack || err);
      },
      /**
       * Если результат с optional === false, попробуем без optional!
       * @param tpl
       * @param includedTemplates
       * @param _deps
       * @returns {*}
       */
      depsTemplateResolver: function depsTemplateResolver(tpl, includedTemplates, _deps, config) {
         var result = conventionalStringResolver(tpl, includedTemplates, _deps, config);
         if (utils.isOptionalString(tpl) && !result) {
            result = conventionalStringResolver(utils.splitOptional(tpl));
         }
         return result;
      },
      getNamespace: function getNamespace(attributes) {
         var nsName = attributes.xmlns || 'http://www.w3.org/1999/xhtml';
         return nsName;
      },
      isCompat: function() {
         if (constants.isNodePlatform) {
            return !process.domain || process.domain.req && process.domain.req.compatible !== false;
         } else {
            return constants.compat;
         }
      },
      componentOptsReArray: [{
         toFind: /\\/g, // экранируем слеш первым
         toReplace: '\\\\'
      }, {
         toFind: /<\/(script)/gi,
         toReplace: '<\\/$1'
      }, {
         toFind: /'/g,
         toReplace: '\\u0027'
      }, {
         toFind: /\u2028/g,
         toReplace: '\\u000a'
      }, {
         toFind: /\u2029/g,
         toReplace: '\\u000a'
      }, {
         toFind: /\n/g,
         toReplace: '\\u000a'
      }, {
         toFind: /\r/g,
         toReplace: '\\u000d'
      }]

   };
   return utils;
});
