define('View/Runner/markupGenerator', [
   'View/Runner/config/resolver',
   'View/Runner/common',
   'View/Runner/expressions/scope',
   'View/Runner/focusHelper',
   'View/Runner/Vdom/utils/optionsResolver',
   'View/Runner/expressions/attr',
   'View/Runner/expressions/event',
   'Core/core-debug',
   'Core/constants',
   'Core/IoC',
   'View/Logger',
   'View/Runner/requireHelper'
], function(configResolver,
            utils,
            scopeHelpers,
            FocusHelper,
            optionsResolver,
            attrExpressions,
            eventExpressions,
            timing,
            cConstants,
            IoC,
            Logger,
            requireHelper) {
   'use strict';

   var cacheModules = {};
   var MarkupGenerator = {};
   var defRegExp = /(\[def-[\w\d]+\])/g;

   MarkupGenerator.createWsControl = function createWsControl(name, scope, attributes, context, _deps) {
      throw new Error('MarkupGenerator.joinElements not realized');
   };
   MarkupGenerator.createTemplate = function createTemplate(name, scope, attributes, context, _deps, config) {
      throw new Error('MarkupGenerator.joinElements not realized');
   };
   MarkupGenerator.createController = function createController(name, scope, attributes, context, _deps) {
      throw new Error('MarkupGenerator.joinElements not realized');
   };
   MarkupGenerator.resolver = function resolver(tpl, preparedScope, decorAttribs, context, _deps, includedTemplates) {
      throw new Error('MarkupGenerator.joinElements not realized');
   };

   MarkupGenerator.joinElements = function joinElements(elements, _preffix) {
      throw new Error('MarkupGenerator.joinElements not realized');
   };
   MarkupGenerator.createTag = function createTag(tagName, attrs, children, attrToDecorate, tagKey) {
      throw new Error('MarkupGenerator.createTag not realized');
   };
   MarkupGenerator.createText = function createText(text) {
      throw new Error('MarkupGenerator.createText not realized');
   };
   MarkupGenerator.createDirective = function createDirective(text) {
      throw new Error('MarkupGenerator.createDirective not realized');
   };
   MarkupGenerator.chain = function chain(out, defCollection) {
      return defCollection.def.done().getResult().addCallbacks(function chainTrace(defObject) {
         return out.replace(defRegExp, function (key) {
            var valKey = defCollection.id.indexOf(key);
            if (defCollection.id[valKey]) {
               return defObject[valKey].result ? defObject[valKey].result : defObject[valKey];
            }
            return '';
         });
      }, function (err) {
         utils.asyncRenderErrorLog(err);
      });
   },

   MarkupGenerator.createControl = function createControl(type, name, data, attrs, templateCfg, context, deps, includedTemplates, config, contextObj, defCollection) {
      var res;
      data = configResolver.resolveControlCfg(data, templateCfg, attrs);
      data.internal.logicParent = data.internal.logicParent || templateCfg.viewController;
      data.internal.parent = data.internal.parent || templateCfg.viewController;

      attrs.internal = data.internal;
      data = data.user;

      // Здесь можем получить null  в следствии !optional. Поэтому возвращаем ''
      if (name === null) {
         return this.createText('', attrs.key);
      } else {
         // тип контрола - компонент с шаблоном
         if (type === 'wsControl') {
            if (Logger.getLoggerStatus() || utils.isCompat()) {
               res = timing.methodExecutionTime(this.createWsControl, this, [name, data, attrs, context, deps]);
            } else {
               res = this.createWsControl(name, data, attrs, context, deps);
            }
         }
         // типа контрола - шаблон
         if (type === 'template') {
            if (Logger.getLoggerStatus() || utils.isCompat()) {
               res = timing.methodExecutionTime(this.createTemplate, this, [name, data, attrs, context, deps, config]);
            } else {
               res = this.createTemplate(name, data, attrs, context, deps, config);
            }

         }
         // тип контрола - компонент без шаблона
         if (type === 'controller') {
            if (Logger.getLoggerStatus() || utils.isCompat()) {
               res = timing.methodExecutionTime(this.createController, this, [name, data, attrs, context, deps]);
            } else {
               res = this.createController(name, data, attrs, context, deps);
            }
         }
         // когда тип вычисляемый, запускаем функцию вычисления типа и там обрабатываем тип
         if (type === 'resolver') {
            var handl, i;
            if (attrs.events){
               for (i in attrs.events) {
                  if (attrs.events.hasOwnProperty(i)) {
                     for (handl = 0; handl < attrs.events[i].length; handl++) {
                        if (!attrs.events[i][handl].fn.isControlEvent) {
                           attrs.events[i][handl].toPartial = true;
                        }
                     }
                  }
               }
            }
            if (Logger.getLoggerStatus() || utils.isCompat()) {
               res = timing.methodExecutionTime(this.resolver, this, [name, data, attrs, context, deps, includedTemplates, config, defCollection]);
            } else {
               res = this.resolver(name, data, attrs, context, deps, includedTemplates, config, defCollection);
            }
         }
         if (res !== undefined) {
            return res;
         } else {
            /**
             * Если у нас есть имя и тип, значит мы выполнили код выше
             * Функции шаблонизации возвращают undefined, когда работают на клиенте
             * с уже построенной версткой
             * А вот если нам не передали каких-то данных сюда, то мы ничего не строили,
             * а значит это ошибка и нужно обругаться.
             */
            if (name && type) {
               return this.createText('', attrs.key);
            }
            if (typeof name === 'undefined') {
               IoC.resolve('ILogger').error('Undefined component error', 'Попытка использовать компонент/шаблон, ' +
                  'но вместо компонента в шаблоне в опцию template был передан undefined! ' +
                  'Если верстка строится неправильно, нужно поставить точку останова и исследовать стек вызовов. ' +
                  'По стеку будет понятно, в каком шаблоне и в какую опцию передается undefined');
               return this.createText('', attrs.key);
            }
            throw new Error('MarkupGenerator: createControl type not resolved');
         }
      }
   };


   MarkupGenerator.prepareDataForCreate = function prepareDataForCreate(tpl, scope, attrs, deps, includedTemplates) {
      var controlClass,
         logicParent,
         dataComponent,
         isSlashes,
         wasOptional,
         parent;
      if (typeof tpl === 'function') {
         controlClass = tpl;
         dataComponent = tpl.prototype?tpl.prototype._moduleName:'';
      }
      if (typeof tpl === 'string') {
         if (utils.isLibraryModuleString(tpl)) {
            // if this is a module string, it probably is from a dynamic partial template
            // (ws:partial template="{{someString}}"). Split library name and module name
            // here and process it in the next `if tpl.library && tpl.module`
            tpl = utils.splitModule(tpl);
         } else {
            var newname = utils.splitWs(tpl);
            if (newname) {
               tpl = newname;
            }

            if (tpl.indexOf('/')>-1){
               isSlashes = true;
               if (tpl.indexOf('optional!')>-1){
                  wasOptional = true;
               }
            }

            tpl = tpl.replace('optional!', '');
            if (includedTemplates && includedTemplates[tpl]) {
               controlClass = includedTemplates[tpl];
            }

            if (!controlClass) {
               controlClass = deps && (deps[tpl] || deps['optional!'+tpl]);
            }

            if (!controlClass) {
               if (!isSlashes || wasOptional || cConstants.compat) {
                  /*
                     * it can be "optional"
                     * can be tmpl!
                     * */
                  if (requireHelper.defined(tpl)) {
                     controlClass = requireHelper.require(tpl);
                  }
               } else {
                  try {
                     controlClass = cacheModules[tpl];
                     if (!controlClass) {
                        controlClass = requireHelper.require(tpl);
                        cacheModules[tpl] = controlClass;
                     }
                  }catch(e){
                     IoC.resolve('ILogger').warn('Create component', e, e.stack);
                  }
               }
            }
            dataComponent = tpl;
         }
      }
      if (typeof tpl === 'object' && tpl && tpl.library && tpl.module) {
         // module type: { library: <requirable module name>, module: <field to take from the library> }
         var moduleName = tpl.library + ':' + tpl.module;
         if (deps && deps[tpl.library]) {
            controlClass = deps[tpl.library][tpl.module];
         } else if (requireHelper.defined(tpl.library)) {
            controlClass = requireHelper.require(tpl.library)[tpl.module];
         } else {
            var mod = cacheModules[tpl.library];
            if (mod) {
               controlClass = cacheModules[tpl.library][tpl.module];
            } else {
               moduleName = undefined;
            }
         }
         if (controlClass && controlClass.prototype && !controlClass.prototype.hasOwnProperty('_moduleName')) {
            // Patch controlClass prototype, it won't have a _moduleName the first time it is
            // created, because it was exported in a library
            controlClass.prototype._moduleName = moduleName;
         }
         dataComponent = moduleName;
      }


      var fromOld = controlClass && controlClass.prototype && utils.isCompound(controlClass);

      var controlProperties = scopeHelpers.calculateScope(scope, utils.plainMerge) || {};
      if(fromOld) {
         for (var key in attrs.events) {
            controlProperties[key] = attrs.events[key];
         }
      }

      if (!attrs.attributes){
         attrs.attributes = {};
      }
      FocusHelper.prepareAttrsForFocus(attrs.attributes, controlProperties);
      logicParent = (attrs.internal&&attrs.internal.logicParent) ? attrs.internal.logicParent: null;
      parent = (attrs.internal&&attrs.internal.parent) ? attrs.internal.parent: null;
      optionsResolver.resolveInheritOptions(controlClass, attrs, controlProperties);


      if (cConstants.compat) {
         if (controlProperties && controlProperties.enabled === undefined) {
            var internal = attrs.internal;
            if (internal && internal.parent && fromOld) {
               if (internal.parentEnabled !== undefined && controlProperties.allowChangeEnable !== false) {
                  controlProperties.enabled = internal.parentEnabled;
               } else {
                  controlProperties.enabled = true;
               }
            } else if (fromOld && internal.parentEnabled === false) {
               controlProperties.__enabledOnlyToTpl = internal.parentEnabled;
            }
         }

         if (fromOld) {
            var objForFor = attrs.attributes;
            for (var i in objForFor) {
               if (objForFor.hasOwnProperty(i) && eventExpressions.isEvent(i)) {
                  controlProperties[i] = objForFor[i];
               }
            }
         }
      }

      return {
         logicParent: logicParent,
         parent: parent,
         attrs: attrs.attributes,
         controlProperties: controlProperties,
         dataComponent: dataComponent,
         internal: attrs.internal,
         controlClass: controlClass,
         compound: !(controlClass && controlClass.prototype && controlClass.prototype._template)
      };
   };

   MarkupGenerator.getScope = function(data){
      return data;
   };

   MarkupGenerator.joinAttrs = attrExpressions.joinAttrs;
   MarkupGenerator.escape = function(value){
      throw new Error('MarkupGenerator.escape not realized');
   };
   MarkupGenerator.createEmptyText = function(){
      throw new Error('MarkupGenerator.escape not realized');
   };

   var focusAttrs = ['ws-creates-context', 'ws-delegates-tabfocus', 'ws-tab-cycling', 'ws-no-focus',
      'attr:ws-creates-context', 'attr:ws-delegates-tabfocus', 'attr:ws-tab-cycling', 'attr:ws-no-focus'];

   // remove focus attributes from object and call function with this attributes
   MarkupGenerator.cutFocusAttributes = function cutFocusAttributes(attributes, fn, node) {
      focusAttrs.forEach(function (focusAttr) {
         if (attributes.hasOwnProperty(focusAttr)) {
            fn && fn(focusAttr, attributes[focusAttr]);
            delete attributes[focusAttr];
            if (node) {
               node.removeAttribute(focusAttr);
            }
         }
      });
   };

   return MarkupGenerator;
});
