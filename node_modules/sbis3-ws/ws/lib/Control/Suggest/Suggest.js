/**
 * Created with JetBrains PhpStorm.
 * User: tm.baeva
 * Date: 17.04.13
 * Time: 17:02
 * To change this template use File | Settings | File Templates.
 */
/**
 * Модуль "Компонент Автодополнение".
 *
 * @description
 * @deprecated Используйте класс {@link SBIS3.CONTROLS/SwitchableArea}.
 */
define('Lib/Control/Suggest/Suggest',
   [
   'require',
   "Deprecated/Controls/FieldFormatAbstract/FieldFormatAbstract",
   "Core/core-instance",
   "Core/core-merge",
   "Deprecated/Record",
   "Deprecated/RecordSet",
   'Core/helpers/Function/callNext',
   'Core/helpers/Object/find',
   'Core/helpers/String/diffAt',
   'Core/helpers/i18n/wordCaseByNumber',
   'Core/helpers/Hcontrol/getScrollWidth',
   'Core/helpers/Hcontrol/trackElement',
   'Core/helpers/Hcontrol/isElementVisible',
   "Core/helpers/getType",
   "Core/WindowManager",
   "Core/UserConfig",
   "Core/ParallelDeferred",
   "Core/Deferred",
   "Core/constants",
   "Lib/Control/Control",
   "Deprecated/Controls/DialogSelector/DialogSelector",
   "Deprecated/Controls/TableView/TableView",
   "Lib/Type/TDataSource/TDataSource",
   "Deprecated/Controls/DialogSelector/FloatAreaSelector",
   "Deprecated/Controls/Button/Button",
   "Lib/KbLayoutRevert/KbLayoutRevert",
   "Core/detection",
   "is!browser?/cdn/jquery-ui/1.12.1.2/jquery-ui-position-min.js",
   "css!Lib/Control/Suggest/Suggest",
   "Lib/KbLayoutRevert/KbLayoutRevert",
   'Core/helpers/Object/isEmpty',
   "Deprecated/res/wsmodules/SuggestShowAllDialog/SuggestShowAllDialog",
   "i18n!Lib/Control/Suggest/Suggest"
],
   function(
      require,
      CFieldFormatAbstract,
      cInstance,
      cMerge,
      dTransportRecord,
      dTransportRecordSet,
      callNext,
      objectFind,
      diffAt,
      wordCaseByNumber,
      getScrollWidth,
      trackElement,
      isElementVisible,
      getType,
      WindowManager,
      UserConfig,
      cParallelDeferred,
      cDeferred,
      cConstants,
      Control,
      DialogSelector,
      TableView,
      TDataSource,
      FloatAreaSelector,
      Button,
      KbLayoutRevert,
      objIsEmpty
   ) {

   'use strict';

   var SuggestTableView = TableView.extend({
      $protected: {
         _options: {
            parentSuggest: null,
            editDialogTemplate: '',
            editBranchDialogTemplate: '',
            minWidth: MIN_WIDTH,
            display: {
               showRecordsCount: false,
               showRoot: false,
               showPaging: false,
               showTiming: false,
               reload: false,
               autoResize: false,
               rootNode: null
            },
            dataSource: {
               firstRequest: false
            }
         }
      },
      $constructor: function() {
         if (!(cInstance.instanceOfModule(this._options.parentSuggest,'Lib/Control/Suggest/Suggest'))) {
            throw new Error('Параметр parentSuggest должен содержать экземплар класса $ws.proto.Suggest');
         }
      },
      canAcceptFocus: function() {
         return this._options.parentSuggest.isVisible();
      },
      _notifyOnSizeChanged: function() {},
      getParentSuggest: function() {
         return this._options.parentSuggest;
      },
      getOpener: function() {
         return this._options.parentSuggest.getOpener();
      }
   });

   var
   //Количество записей, отображаемых в браузере со всеми вариантами на одной странице.
      SHOW_ALL_ROWS_PER_PAGE = 20,
   //Задержка скрытия окна после ухода фокуса с поля ввода
      HIDE_TIMEOUT = 200,
   //Минимальная ширина контейнера
      MIN_WIDTH = 150,
   //Диалог по-умолчанию. В старом Джине если опция showAllTemplate не задана, то в опциях передается showAllTemplate == ''
   //Поэтому вводим константу, чтобы старый джин не перебивал дефолтный шаблон.
      SHOW_ALL_TEMPLATE = 'Deprecated/res/wsmodules/SuggestShowAllDialog/SuggestShowAllDialog',
      ICON_WIDTH = 16;

   /**
    * @class Lib/Control/Suggest/Suggest
    * @extends Lib/Control/Control
    * @control
    * @public
    * @author Крайнов Д.О.
    * @category Select
    * @ignoreOptions filterParams
    * @nonVisual
    * @deprecated
    */
   var Suggest = Control.Control.extend(/** @lends Lib/Control/Suggest/Suggest.prototype */{
      /**
       * @event onDataLoaded После загрузки данных
       *
       * Происходит после загрузки данных при поиске
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    suggest.subscribe('onDataLoaded', function(event){
       *       //по окончанию загрузки сменим ее статус
       *        Control.ControlStorage.getByName('load status').html('Выберите значение');
       *    });
       * </pre>
       */
      /**
       * @event onSuggest При выборе значения.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {dTransportRecord} Выбранная запись
       * @param {Object} values Ассоциативный массив по типу 'имя поля': 'значение поля из записи'
       * @return Можно вернуть:
       * <ol>
       *    <li>false - выбор не будет обработан, значения из выбранной записи не будут проставлены, подстрочное поле не
       *    будет закрыто.</li>
       *    <li>true - выбор не будет обработан, но подстрочное поле будет закрыто.</li>
       * </ol>
       * @example
       * <pre>
       *    suggest.subscribe('onSuggest', function(event, record, values){
       *       if (record.get('Сотрудник.@Телефон') === null){
       *          CoreFunctions.alert('Переназначить задание можно только сотруднику, у которого есть телефон.');
       *          event.setResult(false);
       *       } else if (values['Телефон'].indexOf("(") !== 0){
       *          // если в начале номера не указан код города, то считаем, что допишем код Ярославля
       *          event.setResult(true);
       *           Control.ControlStorage.getByName("Телефон").setValue('(852)' + values['Телефон']);
       *       }
       *    });
       * </pre>
       */
      /**
       * @event onDataLoadStarted При начале загрузки данных
       *
       * Происходит в момент начала загрузки данных.
       * Данное событие носит информационный характер. В нём нельзя поменять параметры вызова, т.к. они уже сформированы.
       * Также нельзя прервать загрузку.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    suggest.subscribe('onDataLoadStarted', function(event){
       *       //в начале загрузки напишем ее статус
       *        Control.ControlStorage.getByName('load status').html('Идет загрузка...');
       *    });
       * </pre>
       */
      /**
       * @event onMenuOpen При открытии меню
       * <wiTag
       * Происходит в момент появленя подстрочного поля автодополнения
       * В этом событии нельзя повлиять на скрытие подстрочного поля.
       * @param {Core/EventObject} eventObject Дескриптор события
       * @example
       * <pre>
       *    suggest.subscribe('onMenuOpen', function(event){
       *       // по открытию подстрочного поля выбора скроем кнопку поиска
       *        Control.ControlStorage.getByName('search').hide();
       *    });
       * </pre>
       */
      /**
       * @event onMenuHide При скрытии меню
       *
       * Происходит в момент скрытия подстрочного поля автодополнения.
       * В этом событии нельзя повлиять на скрытие подстрочного поля.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    suggest.subscribe('onMenuHide', function(event){
       *       // по закрытию подстрочного поля выбора покажем кнопку поиска
       *        Control.ControlStorage.getByName('search').show();
       *    });
       * </pre>
       */
      /**
       * @event onBeforeShowAll Перед открытием диалога со всеми записями
       * <wiTag
       * Происходит перед открытием диалога со всеми записями
       * В этом событии можно повлиять на открытие диалога
       * @param {Core/EventObject} eventObject Дескриптор события
       * @example
       * <pre>
       *    suggest.subscribe('onBeforeShowAll', function(event){
       *       //По клику не будем показывать все записи
       *       event.setResult(false)
       *    });
       * </pre>
       */
      $protected: {
         _options: {
            tabindex : false,
            /**
             * @cfg {Number} Количество отображаемых записей
             *
             * Задаёт сколько будет выведено результатов поиска.
             * @group Display
             */
            rowsCount: 5,
            /**
             * @cfg {String[]} Имена параметров фильтрации
             *
             * Задает с какими именами попадут в фильтр метода значения полей ввода
             * <pre>
             *    filter: [ 'ФильтрФИО', 'СтрокаПоиска' ]
             * </pre>
             * @group Data
             * @editor InternalMultipleComponentChooser
             */
            filter: [],
            /**
             * @cfg {Number} Задержка
             *
             * Задержка перед началом поиска.
             */
            delay: 0,
            /**
             * @cfg {Number} Минимальная длина значения
             *
             * Минимальная длина введённого значения, при которой следует начать поиск.
             */
            startChar: 3,
            /**
             * @cfg {String[]} Источники фильтров
             *
             * Массив идентификаторов полей, ввод в которые необходимо обрабатывать
             * <pre>
             *    sourceField: [  Control.ControlStorage.getByName('Поиск').getId() ]
             * </pre>
             * @group Data
             * @editor InternalMultipleComponentChooser
             */
            sourceField: [],
            /**
             * @cfg {String[]} Результирующие поля
             *
             * Массив идентификаторов полей, в которые необходимо проставить результат выбора
             * <pre>
             *    resultField: [  Control.ControlStorage.getByName('ФИО').getId() ]
             * </pre>
             * @group Data
             * @editor InternalMultipleComponentChooser
             */
            resultField: [],
            /**
             * @cfg {String[]} Поля выборки
             *
             * Массив имен полей выборки, значения из которых необходимо проставить в результирующие поля
             * <pre>
             *    processField: [ 'РП.ФИО' ]
             * </pre>
             * @group Data
             */
            processField: [],
            /**
             * @cfg {Object} Источник данных
             *
             * Описание метода бизнес-логики, с помощью которого осуществляется поиск
             * Необходимо для работы без связанного браузера.
             * <pre>
             *    dataSource: {
             *       readerParams: {
             *          linkedObject: 'Пользователь',
             *          queryName: 'СписокПоСтруктуреПредприятияДляАвтодополнения'
             *       }
             *    }
             * </pre>
             * @group Data
             * @editor TDataSourceEditorNoMethods
             */
            dataSource: TDataSource,
            /**
             * @cfg {Object} Дополнительные параметры фильтрации
             *
             * Дополнительные параметры, которые должны уйти в фильтре для метода помимо значений полей
             * Задаются аналогично параметрам фильтрации выборки
             *
             * <pre>
             *    filterParams: {
             *       // параметр фильтрации выводить ли заблокированных пользователей задается значением
             *       'Заблокированные': null,
             *       // параметр фильтрации Дата берется из функции
             *       'Дата': function(){
             *          return new Date();
             *       },
             *       // а подразделение, в котором нужно искать пользователей берется из поля контекста
             *       'Подразделение': {
             *          fieldName: 'Документ.НашаОрганизация'
             *       }
             *    }
             * </pre>
             * Дополнительные параметр фильтрации можно получить методом getParams и установить методом setParams
             * <pre>
             *    var params = suggest.getParams();
             *    if (params["Подразделение"] === null){
             *       params["Подразделение"] = GlobalContext().getValue("Организация");
             *       suggest.setParams(params);
             *    }
             * </pre>
             * @group Data
             */
            filterParams: {},
            /**
             * @cfg {array|string} Связанное/ые представление/я данных
             *
             * Идентификатор представления данных, в котором следует проводить поиск
             * <pre>
             *    linkedBrowser:  Control.ControlStorage.getByName("TableView").getId()
             * </pre>
             * @group Browser
             * @editor InternalMultipleBrowserChooser
             */
            linkedBrowser: [],
            /**
             * @cfg {Boolean} Сохранять фильтр связанного представления
             *
             * Сохранять фильтр связанного представления, добавляя параметры поиска или сбрасывать.
             * Этот параметр поможет, если у связанного представления данных есть какие-то параметры, о которых не знает автодополнение.
             * @group Browser
             */
            useBrowserFilter: false,
            selectionType: 'all',
            /**
             * @typedef {String} UsePagingConfig
             * @variant 'parts' Сокращенный - по результатам загрузки узнаёт, есть ли следующая страница, в hasNextPage boolean.
             * @variant 'full' Полный - грузит информацию об общем количестве страниц, в hasNextPage number.
             */
            /**
             * @typedef {Object} DisplayOptions
             * @property {Deprecated/Controls/FieldLink/FieldLink/Columns.typedef[]} columns Устанавливает конфигурацию колонок, которые нужно показать в подстрочном поле.
             * Опцию устанавливают аналогично описанию колонок в табличном представлении.
             * <pre>
             *    columns: [
             *       {
             *          title: 'ФИО',
             *          field: 'РП.ФИО',
             *          width: 256
             *       },
             *       {
             *          title: 'Должность',
             *          field: 'Должность'
             *       }
             *    ]
             * </pre>
             * @property {Boolean} [highlight=true] Устанавливает подсветку введенной строки среди отображаемых данных подстрочного поля.
             * @property {Boolean} [showHead=false] Устанавливает отображение заголовка колонок в подстрочном поле.
             * @property {String} rowRender Устанавливает функцию отображения каждой строки данных подстрочного поля.
             * В качестве аргументов приходит jQuery-элемент строки и запись {dTransportRecord} выборки.
             * @example
             * <pre>
             *    rowRender: function(row, record){
             *       if (record.get('Сотрудник.Уволен') === true)
             *          row.addClass('employee-fail');
             *    }
             * </pre>
             * @property {Boolean} [partiallyLoad=false] Устанавливает для иерархических списков загрузку данных по частям.
             * Возможные значения:
             * <ol>
             *    <li>true - использовать загрузку по частям. Содержимое узлов подгружается только при их раскрытии.</li>
             *    <li>false - использовать полную загрузку. Содержимое узлов подгружается сразу.</li>
             * </ol>
             * @property {String} viewType Устанавливает вид представления данных.
             * Возможно отображение в виде таблицы (table), иерархии, дерева и дерева папок.
             * @property {String} [hierColumn='Раздел'] Устанавливает название поля иерархии. В этом поле хранятся данные о положении записи в общей иерархии. Опция актуальна только для иерархических представлений данных.
             * @property {Boolean} [cutLongRows=false] Устанавливает поведение, при котором будут обрезаны строки в колонках таблицы, если их содержимое не помещается по ширине.
             * @property {Boolean} [hasZebra=true] Устанавливает отображение строк таблицы черезполосицу.
             * @property {UsePagingConfig} [usePaging='full'] Устанавливает использование постраничной навигации среди отображаемых данных подстрочного поля.
             * @property {Boolean} [useAddMoreButton=false] Устанавливает отображение кнопки 'Добавить'.
             * @property {String} [hasMoreLinkText='Показать все'] Устанавливает текст кнопки-ссылки "Показать всё".
             * @editorConfig itemCaption title
             * @translatable hasMoreLinkText
             */
            /**
             * @cfg {DisplayOptions} Устанавливает конфигурацию отображения подстрочного поля.
             */
            display: {
               columns : [],
               highlight: true,
               showHead : false,
               rowRender : '',
               partiallyLoad: false,
               viewType: '',
               hierColumn: 'Раздел',
               cutLongRows: false,
               hasZebra: true,
               usePaging: 'full',
               useAddMoreButton: false,
               hasMoreLinkText: rk('Показать все')
            },
            /**
             * @cfg {Function} Обработчик, срабатывающий при активации кнопки 'Добавить'
             */
            addMoreButtonHandler: '',
            /**
             * @cfg {Boolean}
             * автодополнение всегда лежит в body, а не в родительском контейнере.
             * при изменении размеров родителя автодополнение пересчитывать не надо
             */
            isContainerInsideParent: false,
            /**
             * @cfg {String} Ширина браузера
             * @group Browser
             */
            browserWidth: '500',
            /**
             * @cfg {Boolean} Выделять первую строку после загрузки
             * Важно! Если включена история при поиске,
             * то строка при показе истории не будет выделена,
             * когда показывается только история!
             * @group Browser
             */
            selectOnLoad: true,
            /**
             * @cfg {Boolean} Нужно ли распахивать дерево при использовании фильтра
             * @group Browser
             */
            expandTree: false,
            /**
             * @cfg {String} Максимальная высота браузера
             * @group Browser
             * @editor UnitEditor
             */
            maximumHeight: 'auto',
            /**
             * @cfg {Boolean} Автоматически показывать варианты при приходе фокуса
             */
            autoShow: false,
            /**
             * @cfg {Boolean} Автоматически подстраивать ширину
             * @group Display
             */
            browserAutoWidth: false,
            /**
             * @cfg {String} Шаблон диалога показа всех записей
             * @editor ExternalComponentChooser
             */
            showAllTemplate: '',
            /**
             * @cfg {Boolean} При заходе в иерархическом браузере очищает поля ввода и фильтрацию
             */
            clearOnOpen: false,
            /**
             * @cfg {Boolean} Очищать результаты при невозможности поиска
             *
             * Очищать ли браузер при недостатке букв в строке поиска
             */
            clearBrowser: false,
            /**
             * @cfg {Boolean} Сбрасывать ли текущую папку при поиске в иерархии
             * @group Browser
             */
            resetRoot: false,
            /**
             * @cfg {String} Режим выбора записей при клике во вспывашке на "показать все"
             * В новом диалоге или во всплывающей панели.
             * @variant newDialog в новом диалоге
             * @variant newFloatArea во всплывающей панели
             */
             selectRecordsMode : 'newDialog',
             /**
              * @cfg {Boolean} Задает необходимость использовать выбор из таблицы, настроенной пользователем
              * Если будет установлен в true, то набор данных автдополнения не будет установлен в таблицу, также не будет перенесена функция рендеринга
              */
             useUserBrowser: false,
            /**
             * @cfg {Boolean} Использовать механизм смены неверной раскладки {@link Lib/KbLayoutRevert/KbLayoutRevert}
             * Если будет установлен, то при неудачном поиске раскладка изменится.
             */
             useKbLayoutRevert : false,
            /**
             * @cfg {String} Задаёт необходимость использования истории при поиске
             * В качестве значения принимает имя метода поиска в истории.
             * Концепция метода:
             * <ol>
             *    <li>Получить список истории выбора автодополнения по его привязке. Привязка - это путь до автодополнения вида "имя шаблона родителя автодополнения/имя автодополнения". Это сделано для большей уникальности ключа, чтобы несколько автодополнений на странице корректно сохраняли историю.
             *
             *    Получить список истории в методе БЛ можно используя метод пользовательских параметров "ПользовательскиеПараметры.ПолучитьСписокЗначений" этот метод принимает на вход параметр Путь, на выходе отдаёт ключи, по которым будут отбираться нужные записи.
             *
             *    Полученные выше значения, а их может быть не более 10, можно отфильтровать. Так как по сигнатуре метод истории аналогичен простому списочному методу, то в его параметрах есть Фильтр, который можно применить.</li>
             *    <li>Вернуть на выход список записей истории.</li>
             * </ol>
             * @example
             * <pre>
             *    historyMethod: 'Пользователь.СписокДляИстории'
             * </pre>
             * @see historyKeyField
             * @group Data
             * @editor MethodBLChooser
             */
             historyMethod: '',
             /**
              * @cfg {String} Ключ поля для истории
              * Ключ поля, которое нужно отобразить в историю. Актуально при использовании поля связи.
              * @see historyMethod
              * @group Data
              * @editor BLFieldsChooser
              */
             historyKeyField: '',
             /**
              * @cfg {String} Имя поля для описания в контексте
              */
             definition : false,
            /**
             * @cfg {Boolean} Разрешён ли множественный выбор записей в представлении данных, открываемом кликом на "Показать все"
             *
             * @remark
             * При начале ввода текста в поле ввода средствами автодополнения открывается представление данных для выбора значения.
             * По умолчанию можно выбрать только одно значение. При задании данной опции в true в этом представлении данных
             * можно будет выбрать несколько значений установкой флагов.
             * Возможные значения:
             * <ul>
             *    <li>'true' - множественный выбор включён.</li>
             *    <li>'false' - множественный выбор выключен.</li>
             * </ul>
             * @example
             * <pre>
             *    <option name="showAllMultiSelect">true<option>
             * </pre>
             * @see multiSelect
             */
            showAllMultiSelect: false,
            /**
             * @cfg {Boolean} Использовать постраничную навигацию настроеную пользователем для браузера на диалоге "Показать всё".
             *
             * @example
             * <pre>
             *    <option name="useBrowserPaging">true<option>
             * </pre>
             * @see paging
             */
            useBrowserPaging: false
         },
         _useDefinition: false,
         _currentInputValue: undefined,
         _currentBrowser: [],
         _currentRecordSet: null,
         _sources: [],
         _sourcesNames: {},
         _results : undefined,
         _keysWeHandle: [
            cConstants.key.enter,
            cConstants.key.down,
            cConstants.key.up,
            cConstants.key.left,
            cConstants.key.right,
            cConstants.key.esc,
            cConstants.key.space,
            cConstants.key.tab
         ],
         _timer: undefined,            //Таймер, по истечении которого отправляется запрос
         _filter: undefined,           //Заготовленный запрос для браузера, когда он подгрузится. После загрузки браузера не используется
         _hasMoreLabel: undefined,     //Элемент с информацией о том, что есть ещё записи
         _browserContainer: undefined, //Элемент, содержащий в себе браузер
         _hideTimer: undefined,        //Таймер на скрытие окна
         _isVisible: false,            //Показывается ли в данный момент автодополнение
         _loading: undefined,          //Индикатор загрузки
         _hasFocus: false,             //Имеют ли поля фокус
         _clearButtons: [],            //Кнопки для очистки полей
         _loaded: false,               //Флаг того, что запрос по последнему фильтру был полностью выполнен
         _currentField: 0,             //Номер текущего поля, именно около него нужно показывать меню
         _browserInit: [],             //Был ли проинициализирован браузер
         _containerConnectedToLinkedBrowser: false,
         _browserHandlers: [],          //Обработчики браузера
         _kbReverted : false,           // Флаг повторного запроса при автосмене раскладки
         _historyRecordSet: null,       //Набор данных для получения истории
         _historyBrowserContainer: undefined, // Контейнер для браузера истории
         _historyBlock: undefined,
         _ownerName: '',
         _sourcesOwner: {},              //Владелец/владельцы для полей ввода
         _windowChangeHandler: undefined,//Обработчик на изменение окна(scroll/resize)
         _addMoreButton: undefined,      //кнопка 'Добавить' у выпадающего меню
         _revertedValues: {},            //Объект, содержащий в себе значения после изменения раскладки
                                         //в виде 'номер поля: изменённое значение'
         _onTabClickLastActiveRecord: undefined,//Последняя активная запись, которая была при нажатии на 'Tab'
         _setDefinitionValueHandler: undefined,
         _onMouseWheelHandler: undefined, //Обработчик на событие скрола колёсиком мыши
         _hiddenRowsHeight: 0,            //высота скрытых строк у выпадающего меню
         _historyBrowser: undefined,
         _activeBrowser: undefined,        //текущий активный браузер(может быть браузер истории, а может быть обычный браузер саггеста)
         _needShowHistory: true,
         _wasLoadError: false
      },
      $constructor : function() {
         var self = this;
         this._options.linkedBrowser = Array.isArray(this._options.linkedBrowser) ? this._options.linkedBrowser : [this._options.linkedBrowser];
         this._ownerName = this.makeOwnerName();
         this._initPublishEvents();
         this._loading = $('<div class="ws-ajax-loader-16 ws-hidden"/>');

         if (this._options.useKbLayoutRevert && this._options.delay < 500) {
            this._options.delay = 500;
         }

         if (!this._container) {
            if (this._options.linkedBrowser.length) {
               for (var k = 0, browserLen = self._options.linkedBrowser.length; k < browserLen; k++) {
                  //TODO избавиться от @deprecated метода waitWithParentName(нужно поправить тесты)
                  var browserName = this._options.linkedBrowser[k];
                  (browserName.indexOf('/') === -1 ?
                        new cDeferred().callback(this.getTopParent().getChildControlByName(browserName)) :
                         Control.ControlStorage.waitWithParentName(browserName)
                  ).addCallback(function (browser) {
                     self._container = browser.getContainer();
                     self._containerConnectedToLinkedBrowser = true;
                     return browser;
                  });
               }
            }
            if (!this._container) {
               this._container = $('<div></div>');
               this._container[0].wsControl = this;

               if (this._options.className) {
                  this._container.addClass(this._options.className);
               }
            }
         }
         this._container.addClass('ws-hidden');
         if (this._options.linkedBrowser.length) {
            this._width = 0;
            this._height = 0;
         } else {
            this._container.css('z-index','');//Отпиливаем z-Index, потому что он почему то стал приходить из Джина
            this._container.addClass('ws-suggest-container')
                           .bind('focus', this._moveFocus.bind(this))
                           .width(parseInt(this._options.browserWidth, 10));

            if (this._options.maximumHeight !== 'auto') {
               this._options.maximumHeight = parseInt(this._options.maximumHeight, 10);
               this._container.height(this._options.maximumHeight + 'px');
               this._container.addClass('ws-suggest-withMaxHeight');
            }

            this._container.css('right', 'auto !important');
            this._container.append(this._browserContainer = $('<div class="ws-suggest-browser"/>').width(parseInt(this._options.browserWidth, 10)));

            if (this._options.maximumHeight !== 'auto') {
               this._browserContainer.height(self._options.maximumHeight + 'px');
            }

            if (this._options.display.useAddMoreButton && typeof this._options.addMoreButtonHandler == 'function') {
               this._container.append(this._addMoreButton = $('<div class="ws-suggest-addMoreContainer ws-hidden"/>'));
            }
            this._container.append(this._hasMoreLabel = $('<div class="ws-suggest-hasmore ws-hidden"></div>')).appendTo('body');
         }

         var controlsReady = new cParallelDeferred();
         if (!(this._options.filter instanceof Array &&
            this._options.filter.length === this._options.sourceField.length)) {
            throw new Error('filter must be an array with the same size, as sourceFiled');
         }
         this._initFields(this._options.sourceField, true, controlsReady);
         if (this._options.resultField.length) {
            this._results = [];
            if (this._options.processField.length !== this._options.resultField.length)
               throw new Error('processField must be an array with the same size, as resultFiled');
            this._initFields(this._options.resultField, false, controlsReady);
         }

         controlsReady.done().getResult().addCallback(function() {
            self._reloadControls(self._sources, true);
            if (self._results === undefined) {
               self._results = self._sources;
            }
            else {
               self._reloadControls(self._results, false);
            }

            if (!self._options.filter)
               throw new Error('filter option must be set');
            if (!self._options.dataSource && !self._options.linkedBrowser.length)
               throw new Error('dataSource option must be set');

            if (!self._options.processField)
               self._options.processField = self._options.filter;

            if (!!self._options.linkedBrowser.length && !self._browserInit.length) {
               for (var k = 0, browserLen = self._options.linkedBrowser.length; k < browserLen; k++) {
                  self._init(k);
               }
            }
         });
         this._initSuggestEvents();
      },
      _initPublishEvents: function() {
         this._publish(
            'onDataLoaded',
            'onSuggest',
            'onDataLoadStarted',
            'onMenuHide',
            'onMenuOpen',
            'onBeforeShowAll'
         );
      },

      /**
       * Заменяет строки из массива контролами, айдишники которых равны этим самым строкам
       * @param {Array}    array    Массив с контролами/строками
       * @param {Boolean}  isSource Нужно ли подписываться на события контрола
       */
      _reloadControls: function(array, isSource) {
         var setSource = function() {
            if (isSource) {
               this._sourcesNames[this._options.filter[i]] = true;
               this._sourcesOwner[i] = array[i].getOwner ? array[i].getOwner() : undefined;
               this._initSourceEvents(i, array[i], this._options.linkedBrowser.length);
            }
         }.bind(this);

         for (var i = 0, len = array.length; i < len; ++i) {
            if (typeof(array[i]) === 'string') {
               try {  //здесь могут доставаться контролы, которые уже уничтожены
                  array[i] =  Control.ControlStorage.getWithParentName(array[i]);
                  setSource();
               }
               catch (e) {
               }
            } else if (cInstance.instanceOfModule(array[i], 'Deprecated/Controls/FieldAbstract/FieldAbstract')) {
               setSource();
            }
         }
      },

      /**
       * Инициализирует массив с полями
       * @param {Array} array Массив с идентификаторами полей или с контролами полей
       * @param {Boolean} isSource Нужно ли подписываться на события полей
       * @param {cParallelDeferred} deferred Деферред готовности всех полей
       */
      _initFields: function(array, isSource, deferred) {
         for (var i = 0, len = array.length; i < len; ++i) {
            var field = array[i];
            if (typeof(field) === 'string') {
               this[isSource ? '_sources' : '_results'].push(array[i]);
               //TODO избавиться от @deprecated метода waitWithParentName(нужно поправить тесты)
               if (field.indexOf(':') !== -1 || field.indexOf('/') !== -1) {
                  deferred.push( Control.ControlStorage.waitWithParentName(field));
               } else {
                  deferred.push(new cDeferred().callback(this.getTopParent().getChildControlByName(field)));

               }
            }
            else if (field instanceof Control.Control) {
               this[isSource ? '_sources' : '_results'].push(field);
               if (isSource) {
                  this._initSourceEvents(i, field, this._options.linkedBrowser.length && isSource);
               }
            }
            else if (isSource) {
               throw new Error('$ws.proto.Suggest: sourceField has illegal control with id = "' +
                  array[i] + '"');
            }
         }
      },
      /**
       * Обработчик на изменение размеров окна браузера
       */
      _moveMenuOnResize: function() {
         if (this._isVisible) {
            this._moveMenuToField(this._sources[this._currentField].getContainer());
         }
      },
      /**
       * Обработчик на скролл колёсиком мыши
       */
      _onMouseWheel: function(e) {
         if (this._isVisible) {
            var brContainer = this._browserContainer.find('.ws-browser-container'),
                scrollTop = brContainer[0].scrollTop,
                scrollHeight = brContainer[0].scrollHeight,
                height = brContainer.height(),
                delta = (e.type === 'DOMMouseScroll' ? e.originalEvent.detail * -40 : e.originalEvent.wheelDelta),
                up = delta > 0;

            if (!up && -delta > scrollHeight - height - scrollTop) {
               brContainer.scrollTop(scrollHeight);
               e.stopPropagation();
               e.preventDefault();
               return false;
            } else if (up && delta > scrollTop) {
               brContainer.scrollTop(0);
               e.stopPropagation();
               e.preventDefault();
               return false;
            }
         }
      },
      _initSuggestEvents: function() {
         var self = this,
             currSource, changesChannel;

         this._windowChangeHandler = this._moveMenuOnResize.bind(this);
         this._onMouseWheelHandler = this._onMouseWheel.bind(this);

         if (this._options.definition) {
            this._definitionValueHandler();
         }

         if (!this._options.linkedBrowser.length) {
            this.subscribe('onMenuOpen', function () {
               currSource = this._sources[this._currentField].getInputContainer();
               changesChannel = trackElement(currSource);

               changesChannel.subscribe('onMove', self._windowChangeHandler);
               changesChannel.subscribe('onVisible', function(e, isVisible) {
                  if (!isVisible) {
                     self._hideMenu();
                  }
               });

               self._browserContainer.find('.ws-browser-container')
                                     .bind('DOMMouseScroll mousewheel', this._onMouseWheelHandler);
               if (cConstants.browser.isMobileSafari) {
                  cConstants.$body.bind('gestureend', this._windowChangeHandler);
               }
            });

            this.subscribe('onMenuHide', function () {
               trackElement(currSource, false);
               self._browserContainer.find('.ws-browser-container')
                                     .unbind('DOMMouseScroll mousewheel', this._onMouseWheelHandler);
               if (cConstants.browser.isMobileSafari) {
                  cConstants.$body.unbind('gestureend', this._windowChangeHandler);
               }
            });
         }
      },
      /**
       * Подписывается на события поля ввода
       * @param {Number} number Номер поля
       * @param {Deprecated/Controls/FieldAbstract/FieldAbstract} source Поле, на которое подписываемся
       * @param {Boolean} drawClearButton Нужно ли рисовать кнопку очистки поля
       */
      _initSourceEvents: function(number, source, drawClearButton) {
         var self = this,
            isFormat = (CFieldFormatAbstract && source instanceof CFieldFormatAbstract),
            input = this._findInput(source),
            owner = this._sourcesOwner[number];

         //проверяем поле ввода, поля связи на видимость после удаления записи
         if (cInstance.instanceOfModule(owner, 'Deprecated/Controls/FieldLink/FieldLink')) {
            this.subscribeTo(owner, 'onAfterDelete', function() {
               if (self._isCurrentSourceVisible(false)) {
                  self._focusIn(source);
               }
            });
            this.subscribeTo(owner, 'onBeforeDictionaryOpen', function() {
               self._hideMenu();
            });
            this.subscribeTo(owner, 'onLinkRemove', function() {
               if (self._options.historyMethod) {
                  if (!owner.getSelectedRecords().length) {
                     self._needShowHistory = true;
                  }
                  self._showMenu();
               }
            });
         }
         if (cInstance.instanceOfModule(source, 'Deprecated/Controls/SearchString/SearchString')) {
            source.setSuggest(this);
         }
         if (drawClearButton) {
            this.subscribeTo(source, isFormat ? 'onChangePure' : 'onValueChange', function(event, newValue) {
               var
                  value = isFormat ? this.getStringValue() : newValue,
                  offset = input.position(),
                  parentWidth = input.parent().outerWidth(),
                  right = parentWidth - input.width() - offset.left,
                  top = offset.top + (input.height() - ICON_WIDTH)/2;
               if (!self._clearButtons[number]) {
                  self._clearButtons[number] = $('<div class="ws-suggest-clear" />').click(function() {
                     self._currentInputValue = source._curval;
                     source.setValue(null);
                     source.setActive(true);
                     self._clearButtons[number].hide();
                     self.show();
                     if (self._options.useKbLayoutRevert) {
                        self._revertedValues = {};
                     }
                  });
                  self._clearButtons[number].appendTo(input.parent());
                  input.addClass('ws-no-default-clear-button');
               }
               self._clearButtons[number]
                  .css({'top': top, 'right': right})
                  .toggle(self.isEnabled() && !!value);
            });
         }
         this.subscribeTo(source, isFormat ? 'onChangePure' : 'onChange', function(event, newValue) {
            var value = isFormat ? this.getStringValue() : newValue,
               startProcessChanges = function() {
                  self._processChanges(self._findInput(this), !(self._options.linkedBrowser.length && value + '' === '' && !self._options.clearBrowser), false, value);
               };
            if (self._options.useKbLayoutRevert && (value === null || value.trim() === '')) {
               self._revertedValues = {};
            }
            /* Сбросим флаг о ошибке, т.к. пользователь сознательно продолжает вводить текст в поле ввода */
            this._wasLoadError = false;
            if (self._options.enabled) {
               if (self._options.delay) {
                  if (self._timer) {
                     clearTimeout(self._timer);
                  }
                  self._timer = setTimeout(startProcessChanges.bind(this), self._options.delay);
               } else {
                  startProcessChanges.call(this);
               }
            }
         });
         this.subscribeTo(source, 'onKeyPressed', function(event, e) {
            //TODO временное решение. по уму автодополнение в момент своего разрушения должно отписываться не только от событий браузера, но и от событий полей ввода
            if (!self._isDestroyed) {
               self._initKeyboardMonitor(source, event, e);
            }
         });
         this.subscribeTo(source, 'onFocusIn', function() {
            self._focusIn(this);
         });
         this.subscribeTo(source, 'onFocusOut', this._focusOut.bind(this));
         if (source.isActive()) {
            this._focusIn(source);
         }
         // TODO переделать на другой механизм перемещение наверх панелек на окнах.
         var parent = source.findParent(function (parent) {
            return (parent && parent.moveToTop && !!objectFind(cConstants.WINDOW_CLASSES, cInstance.instanceOfModule.bind(undefined, parent)));
         });
         if (parent) {
            if (cInstance.instanceOfModule(parent, 'Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace') && !self._options.linkedBrowser.length) {
               this.subscribeTo(parent, 'onCancel', function() {
                  self._hideMenu(0);
               });
            }
            parent.moveToTop = callNext.call(parent.moveToTop, function () {
               if (!this.isDestroyed() && this._isVisible && this._currentField === number) {
                  this._acquireZIndex();
               }
            }.bind(this));
         }
      },
      forceClearValue: function() {
         //Да, грязный хак, ставим значение, которое было при создании
         this._currentInputValue = undefined;
      },
      /**
       * Находит элемент, к которому нужно цеплять индикатор загрузки и кнопку очистки
       * @param {Deprecated/Controls/FieldAbstract/FieldAbstract} field Поле, которое нужно обработать
       * @private
       */
      _findInput: function(field) {
         var isFormat = CFieldFormatAbstract && field instanceof CFieldFormatAbstract,
            container = field.getContainer();
         return isFormat ? container.find('.input-field:first') : container.find('.ws-field input');
      },
      /**
       * @param {Number} numberOfBrowser Номер браузера, с которым ведём раборту на данный момент
       *
       * Создаёт рекордсет, находит/создаёт нужный браузер и т. д.
       */
      _init: function(numberOfBrowser) {
         var self = this,
            columns = self._options.display.columns;

         if (this._options.display.highlight) {
            $.each(columns, function(i, column) {
               column.highlight = true;
            });
         }

         // браузер, принимая пустой массив в display.columns, не рисует ни одной колонки.
         if ((getType(columns) === 'array') && (!columns.length)) {
            columns = '';
         }
         if (!self._options.linkedBrowser.length) {
            //если нет свзяного браузера, то создаём браузер
            return this._browserInit[0] = self._getRecordSet().addCallback(function (instance) {
               self._currentRecordSet = instance;

               var vertAlignment = self._options.maximumHeight === 'auto' ?  "Top" : "Stretch",
                   horzAlignment = self._options.browserAutoWidth ? "Left" : "Stretch",
                   browserConfig = {
                        parentSuggest: self,
                        verticalAlignment: vertAlignment,
                        horizontalAlignment: horzAlignment,
                        element: self._browserContainer,
                        //Прописываю без привязки к опциям Suggest, потому что если suggest disabled, то он даже не откроет браузер
                        allowChangeEnable: false,
                        enable: true,
                        isContainerInsideParent: self._isContainerInsideParent(),
                        parent: self.getParent(),
                        filterParams: self._options.filterParams,
                        autoWidth: self._options.browserAutoWidth,
                        autoHeight: self._options.maximumHeight === 'auto',
                        setCursorOnLoad: self._options.historyMethod ? false : self._options.selectOnLoad,
                        cssClassName: 'ws-browser-ignore-local-page-size',
                        display: {
                           columns: columns,
                           height: self._options.height,
                           width: self._options.width,
                           cutLongRows: self._options.display.cutLongRows,
                           //Вот тут костылина, потому что прикладникам лень переделывать кучу полей связи
                           showHead: self._options.display.showHead ? columns.length > 1 : false,
                           hasZebra: self._options.display.hasZebra,
                           viewType: self._options.display.viewType,
                           hierColumn: self._options.display.hierColumn,
                           rowRender: self._options.display.rowRender,
                           partiallyLoad: self._options.display.partiallyLoad,
                           allowHorizontalScroll: !self._options.display.cutLongRows,
                           usePaging: self._options.display.usePaging,
                           recordsPerPage: self._options.rowsCount
                        },
                        handlers: {
                           'onRowActivated': self._onRowActivated.bind(self),
                           'onRowDoubleClick': self._onRowActivated.bind(self)
                        }
                     },
                     browserInstance = new SuggestTableView(cMerge({
                      handlers: {
                         'onAfterRender': function() {
                            var searchResults = this,
                                count = 0,
                                visibleFlag,
                                row;
                            if (self._options.historyMethod && self._historyRecordSet) {
                               //уберем строки, которые уже есть в истории
                               self._historyRecordSet.each(function(record) {
                                  row = searchResults.getContainer().find('[rowkey="' + record.getKey() + '"]');
                                  if (row.length) {
                                     self._hiddenRowsHeight += row.get(0).clientHeight;
                                     row.addClass('ws-hidden');
                                     count++;
                                  }
                               });
                               visibleFlag = count === searchResults.getRecordSet().getRecordCount();
                               //скроем не только надпись но и браузер, если у нас все записи в истории
                               self._browserContainer.toggleClass('ws-hidden', visibleFlag);
                               if (!visibleFlag) {
                                  self._updateContainerSize();
                                  if (!self._historyRecordSet.getRecordCount()) {
                                     browserInstance.setActiveElement(self.getContainer().find('[rowkey]:first'));
                                  }
                               }
                            }
                         },
                         'onSetCursor': function() {
                            if (self._options.historyMethod && self._historyBrowser) {
                               self._historyBrowser.setActiveElement(null);
                            }
                         }
                      }
                   }, browserConfig));

               if (self._options.historyMethod) {
                  self._historyBlock = $('<div />', {
                     'class': 'ws-suggest-history-block'
                  }).prependTo(self._container);
                  //TODO отрефакторить
                  self._historyBrowserContainer = $('<div />', {
                     'class': 'ws-suggest-browser'
                  })
                  .appendTo(self._historyBlock)
                  .css ({
                     width: parseInt(self._options.browserWidth, 10) + 'px'
                  });
                  //вынести в отдельный метод
                  if (self._options.maximumHeight !== 'auto') {
                     self._historyBrowserContainer.height(self._options.maximumHeight + 'px');
                  }
                  else{
                     self._historyBrowserContainer.attr('VerticalAlignment', 'Top');
                  }
                  if (self._options.browserAutoWidth) {
                     self._historyBrowserContainer.attr('HorizontalAlignment', 'Left');
                  }

                  self._historyBlock.append(self._historyBrowserContainer);
                  self._historyBrowser = new SuggestTableView(cMerge(browserConfig,{
                     element: self._historyBrowserContainer,
                     //TODO учесть, что сначала выделение должно установиться на список истории
                     setCursorOnLoad: false,
                     handlers: {
                        'onSetCursor': function() {
                           browserInstance.setActiveElement(null);
                        },
                        'onAfterRender': function() {
                           //если ещё ничего не ввели и показалась история, то не будем выделять строку
                           if (self._options.selectOnLoad && self._currentInputValue && self._historyRecordSet.getRecordCount()) {
                              self._historyBrowser.setActiveElement(self.getContainer().find('[rowkey]:first'));
                           }
                        }
                     }
                  }));
                  self._initHistoryRecordSet();
                  self._historyBrowser.setData(self._historyRecordSet);
               }

               self._currentBrowser[0] = browserInstance;
               self._initBrowser(0);
               self._currentBrowser[0].setData(self._currentRecordSet);
               return browserInstance;
            });
         }
         else {
            var deferred,
                browserName = self._options.linkedBrowser[numberOfBrowser];
            deferred = new cDeferred().dependOn( browserName.indexOf('/') === -1 ?
                  new cDeferred().callback(this.getTopParent().getChildControlByName(browserName)) :
                   Control.ControlStorage.waitWithParentName(browserName)
            );
            if (!deferred) {
               throw new Error('Browser (id = "' + self._options.linkedBrowser[numberOfBrowser] + '") for $ws.proto.Suggest does not exist');
            }
            else {
               return this._browserInit[numberOfBrowser] = deferred.addCallback(function (instance) {
                  self._currentBrowser[numberOfBrowser] = instance;
                  self._currentBrowser[numberOfBrowser].recordSetReady().addCallback(self._onBrowserReady.bind(self, numberOfBrowser));
                  self._browserSubscribe('onRowActivated', self._onRowActivated, numberOfBrowser);
                  if (self._currentBrowser[numberOfBrowser].hasEvent('onConvert')) {
                     self._browserSubscribe('onConvert', self._onConvertReInit, numberOfBrowser);
                  }
                  self._initBrowser(numberOfBrowser);
                  return instance;
               });
            }
         }
      },
      /**
       * Подписывается у браузера на события, сохраняет обработчики, чтобы их потом проще было удалить
       * @param {String} event Название события
       * @param {Function} handler Обработчик
       * @param {Number} numberOfBrowser Номер браузера
       * @private
       */
      _browserSubscribe: function(event, handler, numberOfBrowser) {
         var self = this,
            bindedFunction = function() {
               Array.prototype.push.apply(arguments, [this]);
               handler.apply(self, arguments);
            };
         this._browserHandlers.push({
            eventName: event,
            handler: bindedFunction
         });
         this._currentBrowser[numberOfBrowser].subscribe(event, bindedFunction);
      },
      /**
       * Отписывает браузер от всего
       * @private
       */
      _browserUnsubscribe: function(numberOfBrowser) {
         var i,
            len,
            handlerInfo;
         for (i = 0, len = this._browserHandlers.length; i < len; ++i) {
            handlerInfo = this._browserHandlers[i];
            if (this._currentBrowser[numberOfBrowser].hasEvent(handlerInfo.eventName)) {
               this._currentBrowser[numberOfBrowser].unsubscribe(handlerInfo.eventName, handlerInfo.handler);
            }
         }
      },
      /**
       * Создаёт рекордсет по обработчику, который передали в конфиг
       * @param {Object} [filter] Фильтр
       * @returns {Core/Deferred}
       * @private
       */
      _getRecordSetFromHandler: function(filter) {
         var recordSet = this._options.dataSource(filter),
            result = new cDeferred();
         if (recordSet instanceof cDeferred || recordSet instanceof dTransportRecordSet) {
            if (recordSet instanceof cDeferred) {
               return recordSet.addCallback(function(res) {
                  if (!(res instanceof dTransportRecordSet))
                     throw new Error(rk("Необходимо отдать корректный набор данных!"));
                  return res;
               });
            } else
               result.callback(recordSet);
            return result;
         } else
            throw new Error(rk("Необходимо отдать корректный набор данных!"));
      },
      /**
       * Отдаёт готовый рекордсет по нужным данным
       * @param {Object} [filter] Фильтр
       * @param {Object} [config] Опции
       * @returns {Core/Deferred}
       * @private
       */
      _getRecordSet: function(filter, config) {
         if (typeof(this._options.dataSource) === 'function') {
            return this._getRecordSetFromHandler(filter);
         }
         return this._createRecordSet(config);
      },
      _createRecordSet: function(config) {
         var toMerge = config || {
               context: this._context,
               firstRequest: false,
               usePages: this._options.display.usePaging,
               rowsPerPage: this._options.rowsCount
            },
            dataSource = cMerge({}, this._options.dataSource),
            result = new cDeferred();

         require(['Deprecated/RecordSet'],function(RecordSet) {
            result.callback(
               new RecordSet(cMerge(dataSource, toMerge))
            );
         });

         return result;
      },
      /**
       * Подписывание на события
       */
      _onBrowserReady: function(numberOfBrowser) {
         this._currentRecordSet = this._currentBrowser[numberOfBrowser].getRecordSet();
         if (!this._options.linkedBrowser.length) {
            this._browserSubscribe('onFocusIn', this._moveFocus, numberOfBrowser);
         }
      },
      /**
       * При заход в папку очищаем фильтрацию
       * @param {Core/EventObject} eventObject Событие
       * @param {String} key Открываемая папка
       * @param {Deprecated/Controls/DataViewAbstract/DataViewAbstract} browser Браузер, на котором произошло событие
       * @private
       */
      _onFolderChange: function(event, key, browser) {
         var filter,
             recordset = browser.getRecordSet();
         if (this._options.clearOnOpen) {
            this._sources.forEach(function(source, index) {
               source.setValue('');
               this.forceClearValue();
               if (this._clearButtons[index]) {
                  this._clearButtons[index].hide();
               }
            }.bind(this));
            filter = this._getFilter();
            clearTimeout(this._timer);
            if (this._filter && !this._isFilterEqual(filter)) {
               this._filter = cMerge({}, filter);
               if (this._options.useBrowserFilter) {
                  filter = cMerge(filter, browser.getQuery(), { preferSource: true } );
               }
               filter['Разворот'] = 'Без разворота';
               filter[browser.getRecordSet().getHierarchyField()] = key;
               browser.setTextHighlight('');
               recordset.setPage(0, true);
               filter = this._prepareFilter(filter);
               browser.setQuery(filter, false);
               this.hide();
               event.setResult(false);

            }
         } else {
            filter = this._getFilter();
            filter = cMerge(filter, browser.getQuery(), { preferSource: true } );
            filter[recordset.getHierarchyField()] = key;
            event.setResult(filter);
         }
      },
      _prepareFilter: function(filter) {
         //Если у нас есть история, то отдадим в фильтр значение ее параметра, чтобы можно было метод истории написать универсально
         if (this._options.historyMethod) {
            filter['_ИмяПараметраДляИсторииВыбора'] = this._ownerName;
         }
         return filter;
      },
      /**
       * Обработчик смены фильтра в иерархическом браузере
       * @param {Core/EventObject} eventObject Событие
       * @param {Object} filter Новый фильтр
       * @param {Deprecated/Controls/DataViewAbstract/DataViewAbstract} browser Браузер, на котором произошло событие
       * @private
       */
      _onFilterChange: function(event, filter, browser) {
         var values = this._getFilter(),
            recordSet = browser.getRecordSet();
         if (recordSet) {
            if (filter[recordSet.getHierarchyField()] === browser.getRootNode() && this._options.expandTree) {
               for(var i in values) {
                  if (values.hasOwnProperty(i)) {
                     if (values[i]) {
                        browser.applyTurn('mixed', true);
                        filter['Разворот'] = 'С разворотом';
                        return;
                     }
                  }
               }
            }
         }
      },
      /**
       * @param {Number} numberOfBrowser Номер браузера, с которым ведём раборту на данный момент
       *
       * Делает первый запрос у рекордсета, когда браузер готов. Или не делает.
       */
      _initBrowser: function(numberOfBrowser) {
         var browser = this._currentBrowser[numberOfBrowser];
         if (this._options.expandTree && browser.isTree()) {
            browser.setLoadChildFlag(true);
         }
         if (this._filter) {
            this._filter = this._prepareFilter(this._filter);
            browser.setQuery(this._filter);
            this._filter = undefined;
         }
         if (!this._options.linkedBrowser.length) {
            this._browserSubscribe('onLoadError', function (event) {
               this._wasLoadError = true;
               this._loading && this._loading.addClass('ws-hidden');
            }, numberOfBrowser);
         }
         this._browserSubscribe('onBeforeLoad', this._onDataLoadStarted, numberOfBrowser);
         this._browserSubscribe('onAfterLoad', this._onDataLoaded, numberOfBrowser);
         this._browserSubscribe('onBeforeRender', this._onBeforeRender, numberOfBrowser);
         this._browserSubscribe('onAfterRender', this._onAfterRender, numberOfBrowser);
         browser.getContainer().find('.ws-browser-container').bind('focus', function () {
            this._stopHideTimer();
         }.bind(this));
         if (this._hasFocus && this._options.autoShow) {
            this._processChanges(this._findInput(this._sources[0]), true);
         }
         if (browser.isHierarchy()) {
            this._browserSubscribe('onFolderEnter', this._onFolderChange, numberOfBrowser);
            this._browserSubscribe('onFilterChange', this._onFilterChange, numberOfBrowser);
         }
         this._notify('onReady');
      },
      _onAfterRender: function(event, browser) {
         if (this._needShowBrowser()) {
            browser._onResizeHandler();
         }
        this._showMenu();
      },

      /**
       * Позволяет задать ширину автодополнения после его создания
       * @param {Number | String} Ширина автодополнения в пикселях, если передать в параметр 'auto', то для автодополнения будет установлена автоширина
       */
      setSuggestWidth: function(width) {
         if (width !== 'auto') {
            this._container.width(width);
            this._currentBrowser[0].getContainer().width(width);
            if (this.isVisible())
               this._currentBrowser[0].recalcBrowserOnDOMChange();
         }else{
            this._options.browserAutoWidth = true;
            this._updateContainerSize();
         }
      },

      /**
       * Пересчитывает размер контейнера в случае автоширины браузера
       */
      _updateContainerSize: function() {
         var scroll = false,
             browserContainer = this._browserContainer.find('.ws-browser-container');

         this._browserContainer.find('.ws-browser-scrollbar').height('100%');
         if (this._options.historyMethod) {
            this._historyBrowserContainer.find('.ws-browser-scrollbar').height('100%');
         }
         if (this._options.maximumHeight !== 'auto') {
            var height = browserContainer.find('.ws-browser').outerHeight() + 1; //border-bottom
            if (height > this._options.maximumHeight) {
               height = this._options.maximumHeight;
               scroll = true;
            }
            browserContainer.height(height);
            if (this._options.historyMethod) {
               this._historyBrowserContainer.find('.ws-browser-container').height(height);
               this._historyBrowserContainer.height('auto');
            }
            this._browserContainer.height('auto');
            this._container.height('auto');
         }
         else{
            //Костыль! Проверить в dataViewAbstract метод setHeight, скорее всего хаки там уже не нужны
            if (this._options.historyMethod) {
               this._historyBrowserContainer.find('.ws-browser-container').height('auto');
            }
            if (cConstants.browser.isIE9) { //ie 9 hack
               this._container.find('*').each(function() {$(this).height();});
            }
         }
         if (this._options.browserAutoWidth) {
            var width = this._currentBrowser[0].getContainer().find('.ws-browser').width();
            if (scroll) {
               width += getScrollWidth();
            }
            this._container.width(width);
         }
         if (this._hiddenRowsHeight > 0 && this._isVisible) {
            browserContainer.height(browserContainer.height() - this._hiddenRowsHeight);
         } else if (this._hiddenRowsHeight === 0 && this._options.maximumHeight === 'auto') {
            browserContainer.height('auto');
         }
      },
      /**
       * Устанавливает фокус на первое поле ввода, снимает с браузера
       */
      _moveFocus: function(event) {
         if (this._currentBrowser[0] && this._isVisible) {
            var moveFocusToField = this._sources[this._currentField] && this._sources[this._currentField].setActive;
            this._currentBrowser[0].setActive(false, false, false, moveFocusToField ? this._sources[this._currentField] : this);
            if (moveFocusToField) {
               this._sources[this._currentField].setActive(true);
            }
         }
      },
      /**
       * Обработчик прихода фокуса в поля ввода
       * @param {Lib/Control/Control} field В какой контрол перешёл фокус
       */
      _focusIn: function(field) {
         var self = this;
          cDeferred.callbackWrapper(!this._browserInit.length &&  this._init(0), function(instance) {
            if (!self._hasFocus) {
               self._hasFocus = true;
               self._stopHideTimer();
               if (field.isEnabled()) {
                  /* Если была ошибка при загрузке, то не надо делать запрос при появлении фокуса в поле ввода,
                     чтобы не было зацикливания */
                  if (!self._wasLoadError) {
                     if (self._options.autoShow) {
                        self._processChanges(self._findInput(self._sources[0]), true);
                     } else if (self._options.historyMethod) {
                        //в случае использования истории мы должны показать ее и только ее в момент, когда на поле пришел фокус
                        //если же разработчик сам настроил автопоиск сразу, то все случится естественным образом
                        //при этом не показываем результаты последнего поиска
                        self._currentBrowser[0].clear();
                        self._hasMoreLabel.addClass('ws-hidden');
                        var filter = self._getFilter(false);
                        filter = cMerge(self._options.filterParams, filter);
                        filter = self._prepareFilter(filter);
                        self._historyRecordSet.setQuery(filter);
                     }
                  }
               }
            }
            for(var i = 0; i < self._sources.length; ++i) {
               if (self._sources[i] === field) {
                  self._currentField = i;
                  if (self._isVisible && field.isEnabled()) {
                     self._moveMenuToField(self._sources[i].getContainer());
                  }
                  return instance;
               }
            }
            self._currentField = 0;
            return instance;
         });
      },
      /**
       * При уходе фокуса с полей ввода
       */
      _focusOut: function(event, focusFlag, target) {
         var
            findSuggest = function(object) {
               if (!object) {
                  return;
               }
               if (object.getParentSuggest) {
                  return object.getParentSuggest();
               }

               var opener = object.getOpener && object.getOpener(),
                   topParent = object.getTopParent && object.getTopParent(),
                   suggest,
                   parent;
               if (opener) {
                  /* Особый случай, когда из саггеста открывают меню */
                  if (cInstance.instanceOfModule(opener, 'Deprecated/Controls/FieldLink/FieldLink')) {
                     suggest = self.getOpener() === opener.getInputField() ? opener.getSuggest() : opener;
                  } else {
                     suggest = opener.getParentSuggest && opener.getParentSuggest() || opener;
                  }
                  return cInstance.instanceOfModule(suggest, 'Lib/Control/Suggest/Suggest') ? suggest : findSuggest(opener);
               } else {
                  parent = object.getParent && object.getParent();
                  if (!parent) {
                     //если нет парента, пробуем поискать через топ парент
                     opener = topParent && topParent.getOpener ? topParent.getOpener() :  null;
                     return opener ? findSuggest(opener) : false;
                  } else {
                     return parent ? findSuggest(parent) : false;
                  }
               }
            },
            self = this;

         this._hasFocus = false;
         if (target !== this && findSuggest(target) !== this) {
            if (!this._options.linkedBrowser.length) {
               //Не выбираем запись в саггесте, если фокус ушёл на поле
               //Которое является фильтром для этого же саггеста
               if (this._sources.length && this._onTabClickLastActiveRecord) {
                  var isSuggestSource;
                  for (var i = 0, len = this._sources.length; i < len; i++) {
                     if (this._sources[i] === target) {
                        isSuggestSource = true;
                        break;
                     }
                  }
                  if (!isSuggestSource && this.isVisible()) {
                     this._selectRecord(this._onTabClickLastActiveRecord, this._activeBrowser);
                     this._onTabClickLastActiveRecord = undefined;
                  }
               }
               this._needShowHistory = !cInstance.instanceOfModule(target, 'Lib/Control/Suggest/Suggest');
               this._stopHideTimer();
               if (cInstance.instanceOfModule(target, 'Deprecated/Controls/CloseButton/CloseButton')) {
                  self._hideMenu(0);
               } else {
                  this._hideTimer = setTimeout(function () {
                     self._hideMenu(0);
                  }, HIDE_TIMEOUT);
               }
            }
         }
      },
      /**
       * Останавливает таймер скрытия окна
       */
      _stopHideTimer: function() {
         if (this._hideTimer) {
            clearTimeout(this._hideTimer);
         }
      },
      /**
       * Извещает о показе/скрытии меню. Делает это через родителя, иначе событие не дойдёт
       * @param {Boolean} showed Показано ли меню
       * @private
       */
      _notifySubWindow: function(showed) {
         var parent = this.getParent();
         if (parent) {
            parent.getContainer().trigger('wsSubWindow' + (showed ? 'Open' : 'Close'));
         }
      },
      /**
       * @param {Number} numberOfBrowser Номер браузера
       * Скрывает меню
       */
      _hideMenu: function(numberOfBrowser) {
         if (this._isVisible) {
            WindowManager.releaseZIndex(this._zIndex);
            this._zIndex = null;
            if (this._historyBrowser) {
               this._historyBrowser.setActiveElement(null);
            }
            this._container.addClass('ws-hidden');
            this._isVisible = false;
            this._hiddenRowsHeight = 0;
            this.abort(numberOfBrowser || 0);
            this._notify('onMenuHide');
            this._notifySubWindow(false);
         }
      },
      _onRowActivated: function(eventState, activeRow, currentRecord, browser) {
         //обрабатываем результат выбора только если запись к нам пришла честная, так как если почему-то в наборе уже нет этой записи, то мы получим undefined
         //такое может быть если по какой-то причине таблица начала сразу же перезагружаться еще раз
         if (currentRecord instanceof dTransportRecord) {
            //для истории актуально только то, что выбрал пользователь
            if (this._options.historyMethod) {
               this.addRecordToHistory(currentRecord);
            }
            this.processSuggest(currentRecord);
         }
         eventState.setResult(!!browser);
      },
      /**
       * Добавляет запись в историю
       * @param {dTransportRecord} record
       */
      addRecordToHistory: function(record) {
         if (this._options.historyMethod && this._options.historyKeyField) {
            var keyField = this._options.historyKeyField,
               key = keyField && record.hasColumn(keyField) ? record.get(keyField) : record.getKey();
            UserConfig.setParamValue(this._ownerName, key + '');
         }
      },
      /**
       * Устанавливает связанный браузер
       * @param {Deprecated/Controls/DataViewAbstract/DataViewAbstract} browser Новый браузер/браузеры
       */
      setBrowser: function(browser) {
         var filter = this._filter,
            curBrowser = Array.isArray(browser) ? browser : [browser];

         for (var i = 0, browserLen = this._options.linkedBrowser.length; i < browserLen; i++) {
            this._browserUnsubscribe(i);
         }
         for(i = 0, browserLen = curBrowser.length; i < browserLen; i++) {
            this._options.linkedBrowser[i] = curBrowser[i].getId();
            this._currentBrowser[i] = curBrowser[i];
            this._currentBrowser[i].recordSetReady().addCallback(this._onBrowserReady.bind(this, i));
            this._browserSubscribe('onRowActivated', this._onRowActivated, i);
            this._filter = undefined;
            this._initBrowser(i);
            if (filter) {
               this.show();
            }
         }
      },
      /**
       * Возвращает текущий связанный браузер
       */
      getBrowser: function() {
         return this._currentBrowser.length === 1 ? this._currentBrowser[0] : this._currentBrowser;
      },
      setUseDefinition: function(useDefinition) {
         var value, name;
         this._useDefinition = this._options.definition ? useDefinition : false;
         if (this._useDefinition) {
            value = this.getLinkedContext().getValue(this._options.definition);
            //Поставим значение через контекст FieldString
            name = this._sources[0].getName();
            if (name) {
               this._sources[0].getLinkedContext().setValue(name, value);
            }
            this._findInput(this._sources[0]).val(value);
         }
      },
      /**
       * Установить поле контекста для описания записи. Используется в Deprecated/Controls/FieldLink/FieldLink
       * @param {String} definition
       */
      setDefinition: function(definition) {
         this._options.definition = definition;
         //Если не были подпсианы раньше, подпишемся на изменение поля в контексте
         if (!this._setDefinitionValueHandler) {
            this._definitionValueHandler();
         }
      },
      _definitionValueHandler: function() {
         if (this._setDefinitionValueHandler) {
            return;
         }
         this._setDefinitionValueHandler = this._setDefinitionValue.bind(this);
         this.getLinkedContext().subscribe('onFieldChange', this._setDefinitionValueHandler);
         this.getLinkedContext().subscribe('onDataBind', this._setDefinitionValueHandler);
      },
      _unsubscribeDefinitionValueHandler: function() {
         this.getLinkedContext().unsubscribe('onFieldChange', this._setDefinitionValueHandler);
         this.getLinkedContext().unsubscribe('onDataBind', this._setDefinitionValueHandler);
         this._setDefinitionValueHandler = undefined;
      },
      /**
       * Получить поле контекста для описания записи. Используется в Deprecated/Controls/FieldLink/FieldLink
       * @param {String} definition
       */
      getDefinition: function() {
         return this._options.definition;
      },
      _setDefinitionValue: function(event, field, value) {
         if (this._useDefinition && (field === this._options.definition || event.name === 'onDataBind')) {
            this._processChanges(this._findInput(this._sources[0]), undefined, undefined,
                  event.name === 'onDataBind' ? this.getLinkedContext().getValue(this._options.definition) : value);
         }
      },
      /**
       * Обработчик "конвертации" браузера
       * @param {Core/EventObject} eventObject Событие
       * @param {Deprecated/Controls/HierarchyViewAbstract/HierarchyViewAbstract} newInstance Новый контрол
       * @private
       */
      _onConvertReInit: function(event, newInstance) {
         this.setBrowser(newInstance);
      },
      /**
       * Перегруженный метод обработки клавишь.
       * Клавиши обрабатываются не нажатые на своем контейнере, А нажатые на контейнере источника.
       */
      _initKeyboardMonitor: function(source, eventState, e) {
         if (e && e.which in this._keysWeHandle && (this._isVisible === true || this._notify('onKeyPressed', e) !== false)) {
            this._keyboardHover(source, eventState, e);
         }
      },
      /**
       * Обрабатывает нажатия кнопок клавиатуры
       * @param {Lib/Control/Control} source источник события
       * @param {Object} eventState Событие ws
       * @param {Object} e Объект события
       */
      _keyboardHover : function(source, eventState, e) {
         var self = this,
             browserLen = self._options.linkedBrowser.length || 1;
         for (var i = 0; i < browserLen; i++) {
            this._activeBrowser = this._currentBrowser[i];

            if (!this._activeBrowser) {
               return false;
            }

            var activeRow = this._activeBrowser.getActiveRow(),
                multiline = source.getContainer().find('textarea').length > 0 && !this._isVisible,
                cancelEvent = function(ev) {
                   ev.stopPropagation();
                   ev.preventDefault();
                };

            //Если у нас есть история выбора, а в обычном браузере активной записи не оказалось, то поищем в историии
            if ((!activeRow || !activeRow.hasClass('ws-browser-row-selected')) && this._historyBrowser) {
               activeRow = this._historyBrowser.getActiveRow();
               if (activeRow.length) {
                  this._activeBrowser = this._historyBrowser;
               }
            }
            if (!this._options.enabled || e.altKey || e.shiftKey || e.ctrlKey && e.which !== cConstants.key.space || !source.isEnabled()) {
               return false;
            }
            if (!multiline && (e.which === cConstants.key.down || e.which === cConstants.key.up)) {
               var next,
                   prev,
                   cur;

               if (e.which === cConstants.key.down) {
                  if (this._activeBrowser === this._currentBrowser[i]) {
                     next = activeRow.length ? activeRow.next() : this._browserContainer.find('tr').eq(0);
                  } else {
                     //Если есть браузер истории, то при нажатии на стрелку вниз
                     //Надо так же проверить, может стоит уйти на браузер найденных записей
                     next = activeRow.length ? activeRow.next() : this._historyBrowserContainer.find('tr').eq(0);
                     if (!next.length && this._browserContainer.find('tr').length) {
                        next = this._browserContainer.find('tr').eq(0);
                        this._historyBrowser.setActiveElement(null);
                        this._activeBrowser = this._currentBrowser[i];
                     }
                  }
               } else if (this._historyBrowser && this._activeBrowser === this._historyBrowser) {
                  prev = activeRow.length ? activeRow.prev() : this._historyBrowserContainer.find('tr').eq(-1);
               } else {
                  prev = activeRow.length ? activeRow.prev() : self._browserContainer.find('tr').eq(-1);
                  //Если вдруг предыдущей записи не нашли, и у нас есть история, пробуем поискать там
                  if (!prev.length && this._historyBrowserContainer && this._historyBrowserContainer.find('tr').length) {
                     prev = this._historyBrowserContainer.find('tr').filter(':last');
                     this._currentBrowser[i].setActiveElement(null);
                     this._activeBrowser = this._historyBrowser;
                  }
               }
               cur = e.which === cConstants.key.down ? next : prev;
               if (cur !== null && (self._options.selectOnLoad && cur.length || !self._options.selectOnLoad)) {
                  if (activeRow) {
                     activeRow.removeClass('ws-browser-row-selected');
                  }
                  this._activeBrowser.setActiveElement(cur.length ? cur : undefined);
                  if (this._options.linkedBrowser[i]) {
                     this._currentBrowser[i].setActive(true);
                  }
                  cancelEvent(e);
                  return false;
               }
               cancelEvent(e);
            }
            else if ((e.which === cConstants.key.enter && this._activeBrowser.getRecordSet().getRecordCount() && !multiline) ||
               (e.which === cConstants.key.space && e.ctrlKey)) {
               if (!self._isVisible) {
                  self.forceClearValue();
                  self.show();
               }
               else if (e.which === cConstants.key.enter && !multiline) {
                  self._selectRecord(activeRow, this._activeBrowser);
               }
               cancelEvent(e);
            }
            else if (e.which === cConstants.key.enter && !multiline) {
               self.show();
               cancelEvent(e);
            }
            else if (e.which === cConstants.key.esc && self._isVisible) {
               e.stopImmediatePropagation();
               self.hide();
            }
            else if ((e.which === cConstants.key.left || e.which === cConstants.key.right) && this._currentBrowser[i].isTree()) {
               var rowkey = activeRow.attr('rowkey'),
                  isLeft = (e.which === cConstants.key.left);
               if (isLeft === this._currentBrowser[i].isTreeFolderExpanded(rowkey) &&
                  this._currentBrowser[i].isRecordFolder(rowkey)) {
                  this._currentBrowser[i][isLeft ? 'hideBranch' : 'showBranch'](rowkey);
                  eventState.setResult(false);
                  cancelEvent(e);
                  return false;
               }
               eventState.setResult(true);
               return true;
            }
            else if (e.which === cConstants.key.tab && this._isVisible && this._loaded) {
               this._onTabClickLastActiveRecord = activeRow;
               this._hideMenu();
            }
            return false;
         }
      },
      /**
       * Обработка выбора записи в браузере
       * @param activeRow
       * @param browser Браузер, в котором обрабатываем выбор записи
       * @private
       */
      _selectRecord: function(activeRow, browser) {
            if (activeRow && activeRow.length) {
               this.processSuggest(browser.getActiveRecord(activeRow));
               this._hideMenu(0);
            }
      },
      /**
       *
       * Обрабатывает выбор записи.
       * @param {dTransportRecord} record Выбранная запись.
       * @example
       * <pre>
       *    suggest.subscribe('onSuggest', function(event, record) {
       *       event.setResult(false);
       *       helpers.newRecordSet('Лицо', 'Список', {}, undefined, false).addCallback(function(recordSet) {
       *          recordSet.readRecord(record.get("Сотрудник.@Лицо")).addCallback(function(record) {
       *             suggest.processResult(record);
       *             suggest.hide();
       *          });
       *       });
       *    });
       * </pre>
       */
      processSuggest:function(record) {
         var self = this,
            values = {},
            value, name,
            i, len;
         if (record instanceof dTransportRecord) {
            for (i = 0, len = self._options.processField.length; i < len; ++i) {
               value = record.get(self._options.processField[i]);
               values[self._options.processField[i]] = value;
            }
         }
         var res = self._notify('onSuggest', record, values);
         if (res === undefined) {
            for (i = 0, len = self._options.processField.length; i < len; ++i) {
               if (self._results && self._results[i]) {
                  name = values[self._options.processField[i]];
                  if (name) {
                     self._results[i].setValue(name, true);
                  }
               }
            }
         }
         if (res !== false && !self._options.linkedBrowser.length) {
            self._sources[self._currentField].setActive(true);
            self._hideMenu(0);
         }
      },
      /**
       * Оповещает о начале загрузки рекордсета
       */
      _onDataLoadStarted:function() {
         this._notify('onDataLoadStarted');
      },
      /**
       *
       * Получить текущий рекордсет автодополнения.
       * @returns {dTransportRecordSet} Возвращает текущий набор данных автодополнения.
       * @example
       * <pre>
       *    suggest.getRecordSet().subscribe('onAfterLoad', function(event, isSuccess, error){
       *       // при ошибке загрузки данных в автодополнение выведем ошибку
       *       if (!isSuccess && error instanceof HTTPError && error.httpError !== 0)
       *          CoreFunctions.alert(error.message);
       *    });
       * </pre>
       */
      getRecordSet: function(numberOfBrowser) {
         return this._currentBrowser[numberOfBrowser || 0].getRecordSet();
      },
      /**
       * Получить поле, у которого появилось автодополнение
       */
      getOpener: function () {
         return this._sources[this._currentField];
      },
      _acquireZIndex: function () {
         if (this._zIndex) {
            WindowManager.releaseZIndex(this._zIndex);
         }
         this._zIndex = WindowManager.acquireZIndex(false, false, true);
         this._container.css('z-index', this._zIndex);
      },
      /**
       *
       * Показывает меню
       */
      _showMenu: function() {
         if (this._needShowBrowser() && !this._isVisible && this._isCurrentSourceVisible(true)) {
            this._acquireZIndex();
            this._container.removeClass('ws-hidden');
            // у currentBrowser индекс 0, потому что высплывашки всего один браузер
            this._currentBrowser[0].recalcBrowserOnDOMChange();
            if (this._historyBrowser) {
               this._historyBrowser.recalcBrowserOnDOMChange();
            }
            this._updateContainerSize();

            this._moveMenuToField(this._sources[this._currentField].getContainer());
            this._notify('onMenuOpen');
            this._isVisible = true;
            this._notifySubWindow(true);
         }
      },
      /**
       * Перемещает меню к полю
       * @param {jQuery} fieldContainer Поле, к которому нужно переместить меню
       * @private
       */
      _moveMenuToField: function(fieldContainer) {
         /* Проверяем, может ли меню развернуться вверх в случае надобности и не обрезаться */
         var doVertFlip = this._container[0].offsetHeight < fieldContainer[0].getBoundingClientRect().top,
             doHorFlip = this._container[0].offsetWidth > fieldContainer[0].offsetWidth,
             positionObject = {
                of: fieldContainer,
                my: 'left top-1',
                at: 'left bottom',
                collision: (doHorFlip ? 'flip' : 'none') + (doVertFlip ? ' flip' : ' none'),
                using: function (pos) {
                   /* Для особого случая, когда автодополнение прикреплено к полю, которое лежит на fixed элементе,
                    чтобы автодоплнение не распирало страницу делаем смещение по вертикали */
                   if ((self._getDocumentHeight() < pos.top + this.offsetHeight) && pos.top !== 0  && self.fieldContainer[0].getBoundingClientRect().top < document.body.offsetHeight && self._oldOffset !== pos.top + this.offsetHeight) {
                      /* При определённых размерах окна jquery-плагин зацикливается и перестаёт сдвигать элемент.
                        Видимо, это происходит из-за бага в самом плагине. Запоминаем старую позицию и если элемент
                        перестаёт сдвигаться, то прерываем цикл. */
                      self._oldOffset = pos.top + this.offsetHeight;
                      positionObject.collision = (doHorFlip ? 'flip' : 'none') + ' fit';
                      $(this).position(positionObject);
                   } else {
                      this.style.left = pos.left + 'px';
                      this.style.top = pos.top + 'px';
                   }
                }
             },
             self = this;
         self.fieldContainer = fieldContainer;
         this._container.position(positionObject);
      },
      /* Кроссбраузерно считает высоту страницы */
      _getDocumentHeight: function() {
         return Math.max(
             document.body.scrollHeight, document.documentElement.scrollHeight,
             document.body.offsetHeight, document.documentElement.offsetHeight,
             document.body.clientHeight, document.documentElement.clientHeight
         );
      },
      _needShowBrowser: function() {

         var result = !this._options.linkedBrowser.length;
         if (result) {
            var recordset = this._currentBrowser.length && this._currentBrowser[0].getRecordSet();
            result = !!(recordset && recordset.getRecordCount());
            if (!result && this._options.historyMethod) {
               result = this._historyRecordSet && this._historyRecordSet.getRecordCount() && this._needShowHistory;
            }
         }
         return result;
      },

      _onBeforeRender: function(browser) {
         if (this._hasFocus) {
            this._container.stop(true, true);
         }
         return true;
      },

      /**
       * Пытается найти в источниках данные, которые введены в ошибочной раскладке
       * меняет фильтр если найдет такие
       *
       * @returns {number} количество изменений в фильтре
       */
      _tryRevertKbLayout : function() {

         if (!this._options.useKbLayoutRevert) {
            return;
         }

         var self = this,
             changes = 0,
             sourceValue,
             sourceValueReverted,
             hasReverted,
             revertedFilter = {};

         this._sources.forEach( function(source, key) {
            sourceValue = source.getStringValue();
            hasReverted = self._revertedValues.hasOwnProperty(key);

            if (hasReverted) {
               var diffPos = diffAt(sourceValue, self._revertedValues[key]),
                  symbolsCommon = diffPos === -1 ? '' : sourceValue.substr(0, diffPos);
               sourceValue = sourceValue.replace(symbolsCommon, '');
            }

            if (sourceValue !== null && sourceValue.trim() !== '') {
               sourceValueReverted = KbLayoutRevert.process(sourceValue);
               if (sourceValueReverted !== sourceValue) {
                  ++changes;
                  sourceValue = hasReverted ? symbolsCommon + sourceValueReverted : sourceValueReverted;
                  self._revertedValues[key] = sourceValue;
                  revertedFilter[self._options.filter[key]] = sourceValue;
               }
            }
         });

         if (changes) {
            this._kbReverted = true;
            this._setVisibility(true);
            this._processChanges(self._findInput(this._sources[0]), false, revertedFilter);
         }

         return changes;
      },

      /**
       * Обрабатывает загрузку рекордсета - показывает/скрывает браузер, и т. д.
       */
      _onDataLoaded: function(event, browser) {
         this._loaded = true;
         if (this._hasFocus && browser) {
            var recordset = browser.getRecordSet(),
               recordsCount = recordset.getRecordCount(),
               allRecords = recordset.hasNextPage(),
               self = this,
               hasAnotherRecords,
               text,
               filter = browser.getQuery();

            // поиск вернул 0 записей, пытаемся сменить ракладку и поискать снова
            if (!this._kbReverted &&  !recordsCount && this._tryRevertKbLayout()) {
               return;
            } else if (this._kbReverted && this._options.useKbLayoutRevert) {
               this._kbReverted = false;
               var source,
                  sourceOwner;
               if (!objIsEmpty(self._revertedValues)) {
                  if (recordsCount) {

                     for (var key in self._revertedValues) {
                        if (self._revertedValues.hasOwnProperty(key)) {
                           var
                              value = self._revertedValues[key];
                           source = self._sources[key];
                           sourceOwner = source.getOwner();
                           //У поля связи в строках переопределен _notFormatedVal - он нормально значение переставить не может
                           if (cInstance.instanceOfModule(sourceOwner, 'Deprecated/Controls/FieldLink/FieldLink')) {
                              sourceOwner.resetSuggestInputValue(value);
                           } else {
                              source.setValue(value);
                           }
                        }
                     }
                  }
               }
            }

            this._notify('onDataLoaded');

            if (!this._options.linkedBrowser.length) {
               if (this._options.maximumHeight !== 'auto')
                  this._container.height(this._options.maximumHeight);
               this._browserContainer.height(this._options.maximumHeight);
               if (this._options.historyMethod) {
                  this._historyBrowserContainer.height(this._options.maximumHeight);
               }
               if (this._addMoreButton) {
                  if (this._options.maximumHeight !== 'auto') {
                     this._container.height(this._options.maximumHeight+26);
                  }
                  this._addMoreButton.empty();
                  this._addMoreButton.append($('<div class="ws-suggest-addMore"></div>'));
                  new Button({
                     element: this._addMoreButton.find('.ws-suggest-addMore'),
                     name: 'addButton',
                     image: 'sprite:icon-24 icon-AddButton icon-primary',
                     renderStyle: 'asLink',
                     toolTip: rk('Добавить'),
                     caption: rk('Добавить'),
                     displayCaptionForAddButton: true,
                     handlers: {
                        'onActivated' : this._options.addMoreButtonHandler
                     }
                  });
                  this._addMoreButton.removeClass('ws-hidden');
               }
            }
            if (this._options.display.usePaging === 'full') {
               hasAnotherRecords = (recordsCount < allRecords);
            }
            else {
               hasAnotherRecords = !!allRecords;
            }
            if (hasAnotherRecords) {
               if (!self._options.linkedBrowser.length) {
                  this._hasMoreLabel.empty();
                  if (self._options.maximumHeight !== 'auto')
                     this._container.height(self._options.maximumHeight + 24);
                  if (this._options.display.usePaging === 'full') {
                     text = rk('Всего найдено') + ' ' + allRecords + ' ' + wordCaseByNumber(allRecords, rk('записей'), rk('запись', 'множественное'), rk('записи')) + '. ';
                  }
                  else {
                     text = '';
                  }
                  this._hasMoreLabel
                     .append(text)
                     .append(
                      $('<span class="ws-suggest-hasmore-link"/>')
                        .text(self._options.display.hasMoreLinkText)
                        .bind('click', this._showAllClick.bind(this, filter)))
                     .removeClass('ws-hidden');
               }
            }
            else if (!self._options.linkedBrowser.length) {
               this._hasMoreLabel.addClass('ws-hidden');
               if (self._options.maximumHeight !== 'auto') {
                  this._container.height(self._options.maximumHeight);
               }
            }
         }
         if (this._loading) {
            this._loading.addClass('ws-hidden');
         }
      },
      /**
       * Обработчик выбора записей в DialogSelector'е
       * @param {Core/EventObject} eventObject Событие
       * @param {Array} selectedRecords Массив с записями
       * @protected
       */
      _onDialogChange: function(event, selectedRecords) {
         if (selectedRecords.length && selectedRecords[0]) {
            this.processSuggest(selectedRecords[0]);
         }
      },
      /**
       * Обработчик на кнопку "показать всё".
       * @param {Object} filter Текущий фильтр автодополнения
       * @returns {Boolean} Обработку события не нужно продолжать
       * @private
       */
      _showAllClick: function(filter) {
         var self = this,
            attachOptions,
            isDialog = this._options.selectRecordsMode === 'newDialog',
            typeOfSelector = isDialog ? DialogSelector : FloatAreaSelector;

         this.hide();

         if (this._notify('onBeforeShowAll') !== false) {
            attachOptions = {
               opener: this,
               template: this._options.showAllTemplate || SHOW_ALL_TEMPLATE,
               multiSelect: this._options.showAllMultiSelect,
               selectionType: this._options.selectionType,
               handlers: {
                  onChange: function () {
                     self._onDialogChange.apply(self, arguments);
                     this.close();
                  },
                  onInit: function () {
                     if (!self._options.useUserBrowser) {
                        this.getReadyDeferred().addCallback(function () {
                           var browser = this.getBrowser();
                           if (browser) {
                              //если нам почему-то веселые разработчики отдали старый браузер, но не сделаем для него ничего
                              if (!self._options.useBrowserPaging && self._options.display.usePaging !== 'full' && cInstance.instanceOfModule(browser, 'Deprecated/Controls/DataViewAbstract/DataViewAbstract')) {
                                 browser.setUsePaging(self._options.display.usePaging);
                              }
                              self._setupShowAllBrowser(browser, filter);
                           }
                        }.bind(this));
                     }
                     self._acquireZIndex();
                  }
               }
            };
            if (!isDialog) {
               attachOptions.isStack = true;
               attachOptions.autoCloseOnHide = true;
            }
            new typeOfSelector(attachOptions);
         }
         return false;
      },
      /**
       * Настраивает браузер на диалоге "показать всё"
       * @param {SBIS3.CORE.DataView} browser Браузер, который мы будем обрабатывать
       * @param {Object} filter Фильтр браузера
       */
      _setupShowAllBrowser: function(browser, filter) {
         var toMerge = {
            firstRequest: true,
            filterParams: filter,
            usePages: this._options.display.usePaging,
            rowsPerPage: browser.getContainer().hasClass('ws-browser-ignore-local-page-size') ?
                           SHOW_ALL_ROWS_PER_PAGE : SHOW_ALL_ROWS_PER_PAGE,
            context: this.getLinkedContext()
         };
         this._getRecordSet(filter, toMerge).addCallback(function(recordSet) {
            browser.setColumns(this._currentBrowser[0].getColumns());
            if (this._options.display.rowRender) {
               browser.setRowRender(this._options.display.rowRender);
            }
            browser.setData(recordSet);
         }.bind(this));
      },
      /**
       *
       * Установить тип постраничной навигации для метода БЛ: полная или частичная
       * По умолчанию используется режим полной навигации.
       * @param {String} usePaging тип постраничной навигации:
       * <ul>
       *    <li>'full' - режим полной постраничной навигации</li>
       *    <li>'parts' - режим частичной постраничной навигации</li>
       * <ul>
       */
      setUsePaging: function(usePaging) {
         this._options.display.usePaging = usePaging || 'full';
      },
      /**
       *
       * Установить тип постраничной навигации для метода БЛ: полная или частичная
       * По умолчанию используется режим полной навигации.
       * @returns {String} usePaging тип постраничной навигации:
       * <ul>
       *    <li>'full' - режим полной постраничной навигации</li>
       *    <li>'parts' - режим частичной постраничной навигации</li>
       * <ul>
       */
      getUsePaging: function() {
         return this._options.display.usePaging;
      },
      /**
       * Возвращает, если ли фокус у саггеста
       * @returns {boolean|*}
       */
      isFocused: function() {
         return this._hasFocus;
      },
      /**
       * Просчитывает фильтр для запроса
       * @param {Number|Boolean} [validateLength] Нужно ли проверять длину
       * @returns {Object}
       */
      _getFilter: function(validateLength) {
         var filter = {};
         for(var i = 0, len = this._options.filter.length; i < len; ++i) {
            var isFormat = CFieldFormatAbstract && this._sources[i] instanceof CFieldFormatAbstract,
               value = isFormat ? this._sources[i].getStringValue() : this._sources[i].getValue();
            if (value !== null)
               value += "";
            if (value && typeof(value) === 'string' && ( value.length >= this._options.startChar || validateLength === false )) {
               filter[this._options.filter[i]] = value;
            }
            else if (!filter[this._options.filter[i]]) {
               filter[this._options.filter[i]] = '';
            }
         }
         return filter;
      },
      /**
       * Устанавливает подсветку найденного для браузера
       * @param {Object} filter Фильтр, который применяется к браузеру
       * @param {Number} numberOfBrowser Номер браузера, с которым мы работаем
       */
      _setBrowserHighlightning: function(filter, numberOfBrowser) {
         var result = [];
         for(var i in filter) {
            if (filter.hasOwnProperty(i)) {
               var value = filter[i];
               if (value instanceof Object && 'fieldName' in value) {
                  value = this.getLinkedContext().getValue(value['fieldName']);
               }
               if (value) {
                  result.push(value);
               }
            }
         }
         if (this._currentBrowser[numberOfBrowser]) {
            this._currentBrowser[numberOfBrowser].setTextHighlight(result.length ? result.join('|') : '');
         }
      },
      _initHistoryRecordSet: function() {
         var method = this._options.historyMethod.split('.'),
             self = this;
         this._historyRecordSet = new dTransportRecordSet({
            context: this.getLinkedContext(),
            usePages: this._options.display.usePaging,
            //ограничим историю, чтобы возвращалось не больше 10 записей, на всякий случай
            rowsPerPage: 10,
            filterParams: {},
            requiredParams: [],
            readerType: 'ReaderUnifiedSBIS',
            readerParams: {
               linkedObject: method[0],
               queryName: method[1]
            },
            firstRequest: false,
            handlers: {
               'onAfterLoad': function() {
                  if (!self.isVisible()) {
                     self._showMenu();
                  }
                  //скрываем блок истории, если у нас поле ввода скрыто
                  if (!self._isCurrentSourceVisible(true)) {
                     self._historyBlock.addClass('ws-hidden');
                  } else {
                     //если поле ввода видимо, то покажем только тогда, когда есть записи в истории
                     self._historyBlock.toggleClass('ws-hidden', !this.getRecordCount());
                  }
               }
            }
         });
      },
      /**
       * Проверяет видимость поля ввода
       * @param {Boolean} checkActive Проверять, активно ли поле ввода или нет
       * @returns {*}
       * @private
       */
      _isCurrentSourceVisible: function(checkActive) {
         var source = this._sources[this._currentField],
             owner = this._sourcesOwner[this._currentField];

         if (checkActive && !(source && source.isActive())) {
            return false;
         }
         //Для поля связи особо проверяем видимость
         if (owner && cInstance.instanceOfModule(owner, 'Deprecated/Controls/FieldLink/FieldLink')) {
            return owner.getInputVisibility();
         }
         return isElementVisible(source.getContainer());
      },
      /**
       * Обрабатывает изменение полей ввода
       */
      _processChanges: function(input, validateLength, revertedFilter, value) {
         var self = this,
            inputValue = value || value === '' ? value : input.attr('value');
         if ((!revertedFilter && inputValue === self._currentInputValue && this._options.autoShow !== true) ||
            !this._isCurrentSourceVisible(false)) {
            return;
         }
         if (this._useDefinition) {
            if (this.getLinkedContext().getValue(this._options.definition) !== inputValue) {
               if (this._options.definition) {
                  this.getLinkedContext().setValue(this._options.definition, value === undefined ? null : value);
               }
            } else if (input.val() !== value) {
               input.val(value);
            }
            return;
         }
         self._currentInputValue = inputValue;
         for(var k = 0, browserLen = self._currentBrowser.length; k < browserLen; k++) {
             cDeferred.callbackWrapper(!self._browserInit.length && self._init(k) || self._browserInit[k], function (instance) {
               /*если начальная длина поиска поставлена в 0, то проводить сравнение длины не имеет смысла.
                если разработчик такую длину поставил, то, видимо, видел в этом какой-то скрытый смысл...*/
               if (parseInt(self._options.startChar, 10) === 0 && !self._options.clearBrowser)
                  validateLength = false;
               var recordset = instance.getRecordSet(k),
                  hasValues = false,
                  filter = self._options.useKbLayoutRevert && revertedFilter ? revertedFilter : self._getFilter(validateLength);
               for (var i in filter) {
                  if (!filter.hasOwnProperty(i)) {
                     continue;
                  }
                  if (filter[i] && self._sourcesNames[i]) {
                     hasValues = true;
                     break;
                  }
               }
               self._setBrowserHighlightning(filter, k);
               filter = cMerge(self._options.filterParams, filter);
               filter = recordset.prepareFilter(filter, true);
               if (hasValues || validateLength === false) {
                  self._container
                     .toggleClass('ws-control-inactive', false)
                     .toggleClass('ws-has-focus', true);
                  if (!self._isFilterEqual(filter) || !self._loaded) {
                     self.hide();
                     self._loaded = false;
                     self._filter = cMerge({}, filter);

                     //запрос для истории this._options.historyMethod
                     if (self._options.historyMethod) {
                        if (!self._historyRecordSet) {
                           self._initHistoryRecordSet();
                        }
                        filter = self._prepareFilter(filter);
                        self._historyRecordSet.setQuery(filter);
                     }

                     if (recordset !== null && recordset.getReader().getAdapter().getRPCClient() !== null)
                        recordset.abort(k);
                     if (self._options.linkedBrowser[k]) // если связанный браузер, то сбрасываем номер страницы к первой
                        instance.setPage(0, false);
                     if (self._options.expandTree) {
                        if (instance.isTree()) {
                           instance.applyTurnTree(hasValues, true);
                        }
                        else if (hasValues) {
                           instance.applyTurn('mixed', true);
                        }
                        else {
                           instance.clearTurn(true);
                        }
                     }
                     if (self._options.selectOnLoad === false) {
                        instance.setActiveRow(undefined);
                     }
                     var offset = input.length === 0 ? {} : input.position(),
                        clearButton = input.parent().find('.ws-suggest-clear'),
                        left = offset.left + input.width() - 16,
                        top = offset.top + (input.height() - ICON_WIDTH) / 2;
                     if (clearButton.length > 0 && clearButton.css("display") !== "none") {
                        left -= 16;
                     }
                     self._loading
                        .css({
                           top: top,
                           left: left
                        })
                        .appendTo(input.parent())
                        .removeClass('ws-hidden');

                     if (typeof(self._options.dataSource) == 'function') {
                        self._getRecordSetFromHandler(filter).addCallback(function (rs) {
                           self._currentRecordSet = rs;
                           instance.setData(rs);
                        });
                     }
                     else {
                        if (self._options.useBrowserFilter) {
                           var query = instance.getQuery(),
                              hierarchyField = instance.getRecordSet(k).getHierarchyField();
                           for (var field in query) {
                              if (query.hasOwnProperty(field)) {
                                 if (field === hierarchyField || field === 'Разворот') {
                                    delete query[field];
                                 }
                              }
                           }
                           filter = cMerge(filter, query, { preferSource: true });
                        }
                        if (self._options.resetRoot) {
                           instance.setRootNode(instance.getRootNode(), true);
                        }
                        if (hasValues && self._options.expandTree) {
                           filter['Разворот'] = 'С разворотом';
                        }
                        if (!hasValues && instance.isHierarchy()) {
                           filter['Разворот'] = 'Без разворота';
                        }
                        filter = self._prepareFilter(filter);
                        instance.setQuery(filter, true, false);
                     }
                  }
                  else {
                     self._showMenu();
                  }
               } else {
                  self._filter = {};
                  instance.setTextHighlight('');
                  if (self._options.clearBrowser) {
                     instance.clear();
                  }
                  self.hide();
               }
               return instance;
            });
         }
      },
      /**
       * Возвращает, равен ли новый фильтр старому
       * @param {Object} filter Новый фильтр
       * @returns {Boolean}
       */
      _isFilterEqual: function(filter) {
         this._filter = this._filter || {};
         var equal = true,
            objectIn = function(object0, object1) {
               for(var i in object0) {
                  if (object0.hasOwnProperty(i)) {
                     if (!object1.hasOwnProperty(i) || object1[i] !== object0[i]) {
                        equal = false;
                        break;
                     }
                  }
               }
            };
         objectIn(filter, this._filter);
         objectIn(this._filter, filter);
         return equal;
      },
      /**
       *
       * Изменяет дополнительные параметры фильтрации
       * @param {Object} params Новые дополнительные параметры
       * @example
       * <pre>
       *    suggest.setParams({
       *       'Заблокированные': false
       *    });
       * </pre>
       */
      setParams: function(params) {
         this._options.filterParams = params;
      },
      /**
       *
       * Возвращает дополнительные параметры фильтрации метода бизнес-логики
       * @example
       * <pre>
       *    var params = suggest.getParams();
       *    if (params["Подразделение"] === null) {
       *       params["Подразделение"] = GlobalContext().getValue("Организация");
       *       suggest.setParams(params);
       *    }
       * </pre>
       * @returns {Object}
       */
      getParams: function() {
         return this._options.filterParams;
      },

      /**
       *
       * Принудительно запускает поиск
       * @example
       * <pre>
       *     Control.ControlStorage.getByName('search').subscribe('onActivated', function() {
       *       // по клику на кнопку поиска покажем автодополнение
       *        Control.ControlStorage.getByName('suggest').show();
       *    });
       * </pre>
       */
      _setVisibility : function(show) {
         if (show) {
            this._processChanges(this._findInput(this._sources[0]), this._options.clearBrowser, undefined, this._sources[0] ? this._sources[0].getStringValue() : undefined);
         } else {
            this._hideMenu(0);
         }
      },
      /**
       * Уничтожает контрол
       *
       */
      destroy: function() {
         for(var k = 0, browserLen=this._currentBrowser.length; k < browserLen; k++) {
         if (this._options.linkedBrowser.length && this._currentBrowser.length) {
            // Браузер может быть уже убит ареей
            !this._currentBrowser[k].isDestroyed() && this._currentBrowser[k].destroy();
         } else {
               this._browserUnsubscribe(k);
            }
         }
         if (this.isVisible()) {
            this._hideMenu();
         }
         this._windowChangeHandler = undefined;
         if (this._options.definition) {
            this._unsubscribeDefinitionValueHandler();
         }

         if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
         }

         this._onMouseWheelHandler = undefined;
         this._currentBrowser = null;
         this._currentRecordSet = null;
         this._sources.length = 0;
         this._sourcesNames = {};
         this._results = undefined;
         this._historyBrowser = undefined;
         this._hiddenRowsHeight = undefined;
         this._filter = undefined;
         this._addMoreButton = undefined;
         this._hasMoreLabel = undefined;
         this._browserContainer = undefined;
         this._hideTimer = undefined;
         if (this._isVisible) {
            this._isVisible = false;
            this._notifySubWindow(false);
         }
         this._loading.remove();
         this._loading = undefined;
         if (this._containerConnectedToLinkedBrowser) {
            //Тут мы привязаны к контейнеру от чужого браузера - удалять его нельзя.
            //Очистим переменную, чтоб метод предка не удалил чужой контейнер
            this._container = undefined;
         }
         Suggest.superclass.destroy.apply(this, arguments);
      },
      /**
       *
       * Изменение активности автодополнения
       * Если автодополнение не активно, то поиска при вводе не происходит
       * @example
       * <pre>
       *    if (suggest.isEnabled())
       *       suggest.setEnabled(false);
       * </pre>
       * @param {Boolean} enable
       */
      _setEnabled: function(enable) {
         if (this._isVisible) {
            this.hide();
         }
         for(var i = 0, l = this._clearButtons.length; i < l; i++) {
            if (this._clearButtons[i] && this._sources[i]) {
               this._clearButtons[i].toggle(!!enable && !!this._sources[i].getValue());
            }
         }
         Suggest.superclass._setEnabled.apply(this, arguments);
      },
      /**
       * Включает/выключает автопоказ
       * @param {Boolean} active Включать или выключать
       * @example
       * <pre>
       *    suggest.setAutoShow(true);
       * </pre>
       */
      setAutoShow: function(active) {
         this._options.autoShow = !!active;
      },
      /**
       * Добавляет новое поле, которое будет обрабатывать автодополнение
       * @param {Deprecated/Controls/FieldAbstract/FieldAbstract} field Поле (контрол)
       * @param {String} filterName Имя параметра фильтрации, соотвествующее этому полю ввода
       * @param {Boolean} addToResults Флаг, отвечающий за необходимость заполнения результирующего поля
       * @param {String} processField Поле выборки, значение из которой необходимо проставить в результирующее поле
       * @example
       * <pre>
       *    if (dialog.getRecord().get('Сотрудник.Уволен') === false)
       *       suggest.addSource( Control.ControlStorage.getByName('ДатаПриема'), 'ДатаС');
       * </pre>
       */
      addSource: function(field, filterName, addToResults, processField) {
         var number = this._sources.length;
         this._sources.push(field);
         this._sourcesNames[filterName] = true;
         this._options.filter.push(filterName);
         this._options.sourceField.push(field.makeOwnerName());
         if (addToResults !== false) {
            this._results.push(field);
            this._options.processField.push(processField || filterName);
         }
         this._initSourceEvents(number, field, this._options.linkedBrowser !== null);
      },
      /**
       * Прервать поиск
       *
       * Прерывает текущий запрос к браузеру, если он есть
       * @param {Number} numberOfBrowser Номер браузера, к которому прерываем запрос
       * @example
       * <pre>
       *     Control.ControlStorage.getByName("Закладки").subscribe('onTabChange', function(){
       *       // при переходе на другую закладку прервем поиск
       *       suggest.abort();
       *    });
       * </pre>
       */
      abort: function(numberOfBrowser) {
         if (this._currentBrowser[numberOfBrowser]) {
            var recordSet = this._currentBrowser[numberOfBrowser].getRecordSet(numberOfBrowser);
            if (recordSet) {
               recordSet.abort(numberOfBrowser);
               if (this._timer) {
                  clearTimeout(this._timer);
               }
               if (this._loading) {
                  this._loading.addClass('ws-hidden');
               }
            }
         }
      },
      /**
       * Очищать при открытии папки
       *
       * Будет ли очищать фильтр при входе в папку в иерархии
       * @param {Boolean} clear очищать или нет фильтр
       * @example
       * <pre>
       *    if (table.isTree())
       *       suggest.setClearOnOpen();
       * </pre>
       */
      setClearOnOpen: function(clear) {
         this._options.clearOnOpen = true;
      },

      canAcceptFocus: function() {
         return false;
      },
      /**
       * Задает параметр, отвечающий за смену раскладки в автодополнении
       * Раскладка меняется, если по запросу ничего не найдено
       *
       * @param {Boolean} useKbLayoutRevert менять ли раскладку
       * @example
       * <pre>
       *    suggest.setUseKbLayoutRevert(true);
       * </pre>
       */
      setUseKbLayoutRevert: function(useKbLayoutRevert) {
         this._options.useKbLayoutRevert = !!useKbLayoutRevert;
      },
      /**
       * Получить признак того, что используется смена раскладки при поиске
       *
       * @return {Boolean} useKbLayoutRevert меняется ли раскладка
       * @example
       * <pre>
       *    //если в автодополнении не используется сменя раскладки при поиске, то установим ее
       *    if (!suggest.getUseKbLayoutRevert()){
       *       suggest.setUseKbLayoutRevert(true);
       *    }
       * </pre>
       */
      getUseKbLayoutRevert: function() {
         return this._options.useKbLayoutRevert;
      },
      /**
       * Получить имя метода получения истории в автодополнении
       *
       * @return {String} historyMethod имя метода получения истории
       * @example
       * <pre>
       *    if (suggest.getHistoryMethod() !== 'Сотрудник.СписокИстории'){
       *       suggest.setHistoryMethod('Сотрудник.СписокИстории');
       *    }
       * </pre>
       */
      getHistoryMethod: function() {
         return this._options.historyMethod;
      },
      /**
       * Установить имя метода получения истории в автодополнении
       *
       * @param {String} historyMethod имя метода получения истории
       * @example
       * <pre>
       *    if (suggest.getHistoryMethod() !== 'Сотрудник.СписокИстории'){
       *       suggest.setHistoryMethod('Сотрудник.СписокИстории');
       *    }
       * </pre>
       */
      setHistoryMethod: function(historyMethod) {
         if (typeof historyMethod == 'string') {
            this._options.historyMethod = historyMethod;
         }
      }
   });

   return Suggest;

});
