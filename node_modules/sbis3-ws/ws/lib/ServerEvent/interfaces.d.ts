import Deferred = require("Core/Deferred");
import CONST = require('Lib/ServerEvent/_class/Constants');
import { Notifier } from 'Lib/ServerEvent/_class/Notifier';

export declare module SEB {
    interface IHashData {
        sid?: string
        cid?: string
        uid?: string
        user?: string
        domain?: string
        path?: string
        exchange?: string
        url?: string
    }

    interface IConnectData {
        sid?: string
        hash: string
        protocol?: string
        domain?: string
        exchange?: string
    }

    interface ISubscribeData {
        channelName: string;
        channeled: boolean;
        target: string;
    }

    interface IHashedSub {
        getChannelName(): string;
        hash(): string;
    }

    interface ISubscribe extends IHashedSub {
        isChanneled(): boolean;
        getDeliveryType(): string;
    }

    interface IChanneledSubscribe extends ISubscribe {
        getTarget(): string;
    }

    /**
     * На момент подписки у меня нет Target.
     * Он появляется после запроса /!hash.
     * Поэтому такой интерфейс нужен исключительно для установки Scope
     */
    interface IRawChanneledSubscribe extends ISubscribe {
        getScope(): CONST.CHANNEL_SCOPE;
    }

    interface IEventDeliver {
        deliver(channelName: string, eventName: string, rawData?: any);
        destroy();
    }
    interface IEventDeliverConstructor {
        new(notifyer: Notifier);
    }

    interface ITransportConstructor {
        new(...args): SEB.ITrackedTransport;
        getLocalName(): string;
    }

    interface ITransport {
        subscribe(subscribe: ISubscribe): void;
        unsubscribe(subscribe: ISubscribe): void;
        setDelivery(delivery: IEventDeliver);
        /**
         * Метод принудитиельного отключения транспорта
         * DisconnectHandler не срабатывает
         */
        close();
    }

    interface ITransportCreatorConstructor {
        new (connectOptions: IConnectData): ITransportCreator;
    }

    interface ITransportCreator {
        isAvailableInEnv(isExclusive: boolean): boolean;
        build(hash: string): Promise<ITrackedTransport>;
    }

    interface StompMessageData {
        command: string;
        headers: {};
        body: string;
    }

    interface IWatchDog {
        logStomp(message: StompMessageData);
        logEvent(channelName: string, eventName: string, data: any);
    }

    interface IWatchDogSystem extends IWatchDog {
        logConnect(data);
        logDisconnect(e);
    }

    interface ITracked {
        setWatchDog(watcher: IWatchDog);
    }

    interface ITrackedTransport extends ITransport, ITracked {
    }

    interface ILazyTransport {
        /**
         * Возвращаю им ятранспорта. Нужно для ленивого сравнения.
         */
        getLocalName(): string;

        /**
         * Устанавливает обработчик,
         * который срабатывает при внутреннем отсоединении
         * @param {(event) => any} fn
         */
        setDisconnectHandler(fn: (event) => any);
    }

    interface IFullTransport extends ITransport, ITracked, ILazyTransport {
    }
}