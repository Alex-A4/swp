/// <amd-module name="Lib/ServerEvent/_class/transport/LocalMainTransport" />
import {SEB} from "../../interfaces";
import UserInfo = require('Core/UserInfo');
import LocalStorageNative = require('Core/LocalStorageNative');
import TabMessage = require('Lib/Tab/Message');
import LocalStorage = require('Lib/Storage/LocalStorage');
import * as CONST from 'Lib/ServerEvent/_class/transport/Constants';
import { LocalPageTransport } from "Lib/ServerEvent/_class/transport/LocalPageTransport";
import { Subscribe } from "Lib/ServerEvent/_class/Subscribe";

export class LocalMainTransport implements SEB.ITrackedTransport {
    private transport: LocalPageTransport;
    private ls: LocalStorage = new LocalStorage(CONST.LS_PREFIX);
    private taber: TabMessage = new TabMessage();
    private mainChecker: number;

    private subFromTaber: (event, data: SEB.ISubscribeData) => void;
    private unsubFromTaber: (event, data: SEB.ISubscribeData) => void;
    private fnQuit: (event, data) => void;

    /**
     * Ключ, котоырй указывает, что он не единственный мастер
     * Стейт появляется лишь при закрытии, что бы оно пошло по другому.
     * @type {boolean}
     */
    private isAloneMain = true;
    /**
     * Необходима, что бы при обаружении смены мастера, вызвать пересоздание
     */
    private disconnectCallback: Function;

    constructor(private stomp: Stomp.Client, private hash: string,
                private persistent: boolean = true, private exchangeName: string) {
        /**
         * Нужно всем сообщить, что мастер готов.
         */
        this.fixMain();

        // region Разрешение гонок создания
        /**
         * Кто последний стал мастером, тот и главный.
         * Все асинхронное, поэтому проверяем по дате создания
         * @type {number}
         */
        let now = Date.now();
        this.taber.notify(CONST.KEY_MAINREADY, now);
        /**
         * Функция отключения транспорта, когда он обнаржил, что не актуален
         */
        this.fnQuit = (event, other) => {
            if (other < now) {
                return;
            }
            this.taber.unsubscribe(CONST.KEY_MAINREADY, this.fnQuit);
            this.isAloneMain = false;
            this.close("Detect later main.");
        };
        this.taber.subscribe(CONST.KEY_MAINREADY, this.fnQuit);
        this.taber.subscribe(CONST.KEY_NEW_PAGE, (event) => {
            if (!UserInfo.isValid()) {
                this.fnQuit(event, new Date());
            }
        });
        // endregion

        this.ls.removeItem(CONST.KEY_TRY_CREATE_MAIN);
        this.mainChecker = setInterval(() => {
            this.fixMain();
        }, CONST.CHECK_MIN_INTERVAL);

        const isAck = 'true' === LocalStorageNative.getItem('shared-bus-ack');
        this.transport = new LocalPageTransport(
            stomp, hash, persistent, exchangeName, isAck
        );

        this.subFromTaber = (event, data: SEB.ISubscribeData) => {
            this.subscribe(Subscribe.create(data.channelName, data.channeled, false, data.target));
        };
        this.unsubFromTaber = (event, data: SEB.ISubscribeData) => {
            this.unsubscribe(Subscribe.create(data.channelName, data.channeled, false, data.target));
        };
        this.taber.subscribe(CONST.KEY_SUBSCRIBE, this.subFromTaber);
        this.taber.subscribe(CONST.KEY_UNSUBSCRIBE, this.unsubFromTaber);

        window && window.addEventListener('unload', () => {
            this.close();
        });
    }

    private fixMain() {
        this.ls.setItem(CONST.KEY_ACTUAL_DATE, Date.now());
    }

    static getLocalName() {
        return 'LocalMainTransport';
    }

    getLocalName() {
        return LocalMainTransport.getLocalName();
    }

    subscribe(subscribe) {
        this.transport.subscribe(subscribe);
    }

    unsubscribe(subscribe: SEB.ISubscribe) {
        this.transport.unsubscribe(subscribe);
    }

    destructor(msg?) {
        /*
         * Может прилететь второй вызов при остановке транспорта черзе хедлер
         */
        if (this.taber) {
            this.taber.unsubscribe(CONST.KEY_SUBSCRIBE, this.subFromTaber);
            this.taber.unsubscribe(CONST.KEY_UNSUBSCRIBE, this.unsubFromTaber);
            this.taber.unsubscribe(CONST.KEY_MAINREADY, this.fnQuit);
            this.taber = undefined;
        }

        if (this.isAloneMain) {
            this.ls.removeItem(CONST.KEY_ACTUAL_DATE);
        }
        clearInterval(this.mainChecker);
        let callback = this.disconnectCallback;
        this.disconnectCallback = () => {
        };
        callback(msg);
    }

    /**
     * Обработчик вызывается после деструктора
     * @param {(event) => any} fn
     */
    setDisconnectHandler(fn: (event) => any) {
        this.disconnectCallback = fn;
        this.transport.setDisconnectHandler((evt) => {
            this.destructor();
        });
    }

    /**
     * Закрыте транспорта.
     * При закрытии транспорта не вызывается DisconnectHandler
     */
    close(msg?) {
        this.transport.close();
        this.destructor(msg);
    }

    setDelivery(delivery: SEB.IEventDeliver) {
        this.transport.setDelivery(delivery);
    }

    setWatchDog(watcher: SEB.IWatchDog) {
        this.transport.setWatchDog(watcher);
    }
}
