/**
 * Work with multi-service architecture
 * @author Мальцев А.А.
 */
define('Core/multiService', [
   'Core/load-contents',
   'Core/helpers/getVersionedLink',
   'Core/constants'
], function(
   loadContents,
   getVersionedLink,
   constants
) {
   var IS_NODE = typeof process !== 'undefined' && process.versions;
   var IS_BROWSER = typeof window !== 'undefined';
   var IS_URL_STRING = /http[s]?:\/\//;
   var TRAIL_SERVICE_PATH = /\/service\/(sbis-rpc-service300.dll)?/;

   // @member {Object.<Promise>} Loaded services: service name => service loader
   var loadedServices = {};

   function mkRemoteUrl(path) {
      var req = (process.domain && process.domain.req && process.domain.req) || {};
      var headers = req.headers || {};
      var host = headers.host;
      var proto = headers['x-forwarded-proto'] || headers['x-forwarded-protocol'] || 'http';

      proto = proto.split(',')[0];

      return proto + '://' + host + path;
   }

   function getServicePath(service) {
      var services = constants.services || {};
      var servicePath = (service in services ? services[service] : service) || '';
      servicePath = servicePath.replace(TRAIL_SERVICE_PATH, '');
      return servicePath.indexOf('/') === 0 || IS_URL_STRING.test(servicePath) ? servicePath : '/' + servicePath;
   }

   function getServiceData(name) {
      return {
         service: name,
         path: getServicePath(name)
      };
   }

   function loadService(data) {
      if (!loadedServices[data.service]) {
         loadedServices[data.service] = new Promise(function(resolve, reject) {
            var serviceUrl = IS_NODE ? mkRemoteUrl(data.path) : data.path;
            var contentsUrl = getVersionedLink(serviceUrl + '/resources/contents.json');

            var loadData = function(text) {
               try {
                  var contents = JSON.parse(text);

                  loadContents(contents, false, {
                     resolveRequirejsPath: true,
                     service: serviceUrl,
                     preferSource: true
                  });

                  resolve(data, contents);
               } catch (err) {
                  reject(err);
               }
            };

            if (IS_NODE) {
               var protocol = contentsUrl.startsWith('https') ? require('https') : require('http');
               protocol.get(contentsUrl, function(res) {
                  var statusCode = res.statusCode;
                  if (statusCode > 399 && statusCode < 600) {
                     res.resume();
                     reject(new Error(serviceUrl + ' HTTP status: ' + statusCode));
                  }

                  res.setEncoding('utf8');
                  var rawData = '';
                  res.on('data', function(chunk) {
                     rawData += chunk;
                  });
                  res.on('end', function() {
                     loadData(rawData);
                  });
               }).on('error', function(err) {
                  reject(err);
               });
            } else if (IS_BROWSER) {
               var xhr = new XMLHttpRequest();
               xhr.open('GET', contentsUrl, true);

               xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                     var statusCode = xhr.status || 0;
                     if (statusCode > 399 && statusCode < 600) {
                        // An http 4xx or 5xx error. Signal an error.
                        var err = new Error(serviceUrl + ' HTTP status: ' + statusCode);
                        err.xhr = xhr;
                        reject(err);
                     } else {
                        loadData(xhr.responseText);
                     }
                  }
               };
               xhr.send(null);
            } else {
               // eslint-disable-next-line no-undef
               loadData(TextRequest(contentsUrl));
            }
         });
      }

      return loadedServices[data.service];
   }

   return {

      /**
       * Loads the service
       * @param {String} name Service name
       * @return {Promise<Object>} Loaded service data
       */
      loadService: function(name) {
         if (!name) {
            throw new Error('Service name must be specified');
         }
         var data = getServiceData(name);
         return loadService(data);
      },

      /**
       * Returns list of loaded services
       * @return {String[]}
       */
      getLoadedServices: function() {
         return Object.keys(loadedServices);
      },

      /**
       * Unloads certain service or all of the services
       * @param {String} [name] Service name
       */
      unloadService: function(name) {
         if (name) {
            delete loadedServices[name];
         } else {
            loadedServices = {};
         }
      }
   };
});
