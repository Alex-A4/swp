define('Core/Deferred', ['Core/Entity'], function (Entity) {
   /**
   * Реализация класса Deferred <br />
   * Абстрактное асинхронное событие, может либо произойти, может сгенерировать ошибку.
   * Подробное описание находится {@link https://wi.sbis.ru/doc/platform/developmentapl/interface-development/architecture/deferred/ здесь}.
   * Частично приведено ниже:<br />
   * Deferred - объект, используемый для работы с асинхронными отложенными вычислениями.<br />
   * Ближайшим стандартным аналогом является {@link https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise}.
   * К сожалению Deferred в WS не полностью соответствует стандартизованному Promise.
   * Имеются важные фундаментальные отличия.<br />
   * Любой Deferred может иметь три состояния:
   * <ol>
   *    <li>Не определено (в этом состоянии создается изначально любой Deferred).</li>
   *    <li>Завершён успешно.</li>
   *    <li>Завершён ошибкой.</li>
   * </ol>
   * Для перевода Deferred в одно из состояний используются методы:
   * <ul>
   *    <li>.callback(res) - для перевода в состояние "Завершён успешно";</li>
   *    <li>.errback(err) - для перевода в состояние "Завершён с ошибкой";</li>
   * </ul>
   * <b>ВАЖНО!</b> Если при вызове .callback() передать в качестве аргумента объект Error, то это будет равносильно вызову
   * .errback() с тем же аргументом.
   * <b>ВАЖНО!</b> Нельзя использовать методы .callback() и .errback() несколько раз на одном и том же Deferred.
   * При попытке вызвать данные методы повторно будет выброшено исключение. Как правило, повторный вызов свидетельствует
   * об ошибке в коде приложения.<br />
   * Для получения результата используются методы:
   * <ul>
   *    <li>.addCallback(f) - для получения успешного результата;</li>
   *    <li>.addErrback(f) - для получения ошибочного результата;</li>
   *    <li>.addCallbacks(f1, f2) - для получения в первую функцию успешного результата, а во вторую - ошибки;</li>
   *    <li>.addBoth(f) - для подписки на любой результат одной функицией.</li>
   * </ul>
   * Вызов .addBoth(f) эквивалентен .addCallbacks(f, f).
   * Вызов .addCallback(f) эквивалентен .addCallbacks(f, null).
   * Вызов .addErrback(f) эквивалентен .addCallbacks(null, f).<br />
   * Все вышеописанные методы возвращают тот же Deferred, на котором они были вызваны.<br />
   * Deferred позволяет "мутировать" результат в функциях-обработчиках. То, что вернёт функция обработчик, будет передано
   * на вход следующему подписчику.
   * <br />
   * Пример первый:
   * <pre>
   *    var def = new Deferred();
   *    def.callback(10);
   *    def.addCallback(function(res) {
   *       console.log(res);  // 10
   *       return 20;
   *    });
   *    def.addCallback(function(res) {
   *       console.log(res); // 20
   *    });
   * </pre>
   * Обратие внимание: несмотря на то, что обработчики добавлены после перевода Deferred в состояние "Завершён успешно",
   * они все равно выполняются. Deferred сохраняет свой последний результат и передаёт его всем вновь добавленным
   * подписчикам.<br />
   * <b>ВАЖНО!</b>
   * Обратите внимание на последний добавленный колбэк в примере выше. В нём нет return. Что равнозначно return undefined.
   * Это приводит к следующему побочному эффекту:
   * <br />
   * <pre>
   *     // продолжение первого примера...
   *     def.addCallback(function(res) {
   *        console.log(res); // undefined
   *     });
   * </pre>
   * Мутация значения возможна также в том случае, если обработчик выбросит исключение.
   * <br />
   * Пример второй:
   * <pre>
   *    var def = new Deferred();
   *    def.addCallback(function(res) {
   *       throw new Error(123);
   *    });
   *    def.addCallback(function(res) {
   *    // никогда не выполнится
   *    });
   *    def.addErrback(function(err) {
   *       console.log(err); // Error 123
   *    });
   *    def.callback();
   * </pre>
   * Deferred был переведён в состояние "Успешное завершение", но первая функция-обработчик сгенерировала исключение
   * (конечно же оно могло быть сгенерировано не только конструкцией new Error, но и любой некорректной JS-операцией) и
   * Deferred переключился в состояние "Ошибка". По этой причине следующий добавленный обработчик на успешное завершение
   * выполнен не был, а вот обработчик на ошибку уже выполнился и отобразил в консоли текст ошибки.<br />
   * Для переключения Deferred в состояние "ошибка" не обязательно "выбрасывать" исключение. Достаточно просто вернуть из
   * обработчика объект Error. Разница лишь в том, что "выброшенное" исключение будет залогировано в консоли,
   * а возвращенный объект - нет.<br />
   * Верно и обратное. Если в функции-обработчике ошибки вернуть не ошибочное значение, Deferred изменит свое состояние в
   * "завершён успешно". Данный паттерн удобно использовать, например, в следующем случае. Пусть нам надо вызвать метод
   * бизнес-логики и вернуть результат. Но в случае ошибки не нужно пробрасывать её дальше, нужно заменить ошибку
   * некоторым объектом-заглушкой.
   * <br />
   * Пример третий:
   * <pre>
   *     function fetchData(args) {
   *        var stub = {
   *           some: 'stub',
   *           data: true
   *        };
   *        return loadDataSomehow(args).addErrback(function(err) {
   *           return stub;
   *        });
   *     }
   * </pre>
   * Данный пример демонстрирует ещё один правильный паттерн использования Deferred. Если у вас есть некая функция,
   * которая возвращает асинхронный результат в виде Deferred, и вам нужно его как-то модифицировать - не надо создавать
   * новый Deferred и проводить операции с ним, нужно мутировать результат, возвращаемый исходной асинхронной функцией.
   * <br />
   * Пример четвёртый:
   * <pre>
   *    function fetchData(args) {
   *       var stub = {
   *          some: 'stub',
   *          data: true
   *       };
   *       return loadDataSomehow(args).addCallback(function(res) {
   *          return processData(res);
   *       });
   *    }
   * </pre>
   * При данном способе реализации исходная ошибка будет передана далее вызывающей стороне.
   * <br />
   * Одной важной возможностью Deferred является создание цепочек. Например, ваша функция должна вызвать два метода БЛ
   * один за другим. Причём для вызова второго требуется результат первого. Это очень легко сделать.
   * <br />
   * Пример пятый:
   * <pre>
   *    function fetchData(args) {
   *       return doFirstCall(args).addCallback(function(firstResponse) {
   *          return doSecondCall(firstResponse);
   *       });
   *    }
   * </pre>
   * Если из функции обработчика (любого, не важно успеха или ошибки) вернуть Deferred, то следующий обработчик:
   * <ul>
   *   <li>будет ждать результата асинхронной операции, которую "описывает" возвращенный Deferred;</li>
   *   <li>получит состояние, которое вернёт возвращенный Deferred;</li>
   * </ul>
   * <b>ВАЖНО!</b> Deferred, который вернули из обработчика (т.е. который стал частью цепочки) нельзя более
   * использовать для добавления обработчиков. Попытка добавить обработчик как на успешное завершение, так и
   * на ошибку приведёт к выбросу исключения. Проверить заблокировано ли добавление обработчиков можно с
   * помощью метода .isCallbacksLocked(). Если всё же требуется подписаться на результат Deferred, отдаваемый
   * в цепочку, воспользуйтесь следующим паттерном.
   * <br />
   * Пример шестой:
   * <pre>
   *    someDef.addCallback(function(res) {
   *       var def2 = getDeferredSomehow();
   *       var dependent = def2.createDependent();
   *       dependent.addCallback(someHandler);
   *       return def2;
   *    });
   * </pre>
   * Функция .createDependent() позволяет создать новый Deferred, результат которого будет зависеть от данного.<br />
   * Есть и "обратная" функция. def.dependOn(someDef) - позволяет сделать уже существующий Deferred зависимым от данного.
   * @class Core/_Entity/Deferred
   * @public
   * @author Бегунов А.В.
   */
   Entity.Deferred.prototype._moduleName = 'Core/Deferred';
   return Entity.Deferred;
});