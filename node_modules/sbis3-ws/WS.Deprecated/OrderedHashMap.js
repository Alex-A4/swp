define('Deprecated/OrderedHashMap', [], function() {
   /**
    * "Направленный" хэш-мэп.
    * Перебор всегда идет в порядке добавления элементов.
    * Отслеживает конкурентные модификации (попытки изменения при переборе).
    *
    * @class Deprecated/OrderedHashMap
    * @author Крайнов Д.О.
    * @public
    * @deprecated
    */

   'use strict';
   /**
    * @alias Deprecated/OrderedHashMap
    */
   function OrderedHashMap() {
      this._keys = [];
      this._values = [];
      this._reading = false;
      this._helperHash = {};
   };

   /**
    * Добавляет элемент с указанным ключем
    *
    * @param key ключ. Принудительно преобразуется в строку.
    * @param value значение.
    * @returns {Boolean} Добавлен ли элемент.
    */
   OrderedHashMap.prototype.put = function(key, value) {
      this._checkConcurent();
      key = key + '';
      if (!this.contains(key)) {
         this._keys.push(key);
         this._values.push(value);
         this._helperHash[key] = null;
         return true;
      }
      return false;
   };

   /**
    * Вставляет элемент после указанного. Если не указан after, то будет вставлено в конец
    * @param {String|Number} key Ключ.
    * @param {*} value Значение.
    * @param {String|Number} [after] После какого элемента вставлять.
    * @return {Boolean} Удалось ли вставить.
    */
   OrderedHashMap.prototype.insert = function(key, value, after) {
      this._checkConcurent();
      key = key + '';
      if (!this.contains(key)) {
         var index;
         if (after !== undefined) {
            after = after + '';
            if (!this.contains(after)) {
               return false;
            }
            index = this._keys.indexOf(after) + 1;
         }
         else {
            index = 0;
         }
         this._keys.splice(index, 0, key);
         this._values.splice(index, 0, value);
         this._helperHash[key] = null;
         return true;
      }
      return false;
   };

   /**
    * Возвращает элемент по ключу
    *
    * @param {String} key Запрашиваемый ключ.
    * @returns {*} Элемент с указанным ключем или undefined.
    */
   OrderedHashMap.prototype.get = function(key) {
      var idx = this._getKeyIndex(key);
      return idx == -1 ? undefined : this._values[idx];
   };

   /**
    * Удаляем элемент по ключу
    * @param {String} key ключ.
    * @returns {Boolean} Удален ли элемент.
    */
   OrderedHashMap.prototype.remove = function(key) {
      this._checkConcurent();
      var idx = this._getKeyIndex(key);
      if (idx !== -1) {
         this._keys.splice(idx, 1);
         this._values.splice(idx, 1);
         this._helperHash[key] = undefined;
         return true;
      }
      return false;
   };

   /**
    * Удаляет несколько ключей
    * @param {Array} keys ключи, которые нужно удалить.
    * @returns {Boolean} true, если все ключи были удалены.
    */
   OrderedHashMap.prototype.removeAll = function(keys) {
      if (keys instanceof Array) {
         var r = true;
         for (var i = 0, l = keys.length; i < l; i++) {
            r &= this.remove(keys[i]);
         }
         return !!r;
      }
      return false;
   };

   /**
    * Перебирает элементы
    * @param {Function} f Функция, выполняемая для каждого элемента.
    * this - хэш-мэп, первый аргумент - ключ, второй - значение.
    * Для остановки перебора вернуть false из функции.
    */
   OrderedHashMap.prototype.each = function(f) {
      this._reading = true;
      try {
         for (var i = 0, l = this._keys.length; i < l; i++) {
            if (f.apply(this, [this._keys[i], this._values[i]]) === false) {
               break;
            }
         }
      } finally {
         this._reading = false;
      }
   };

   /**
    * Удаляет все значения
    */
   OrderedHashMap.prototype.clear = function() {
      this._checkConcurent();
      this._keys = [];
      this._values = [];
      this._helperHash = {};
   };

   /**
    * Деструктор
    */
   OrderedHashMap.prototype.destroy = function() {
      this._keys = null;
      this._values = null;
      this._helperHash = null;
   };

   /**
    * Проверяет, существует ли такой ключ
    * @param {String} key Ключ.
    * @returns {Boolean} Найден ли ключ.
    */
   OrderedHashMap.prototype.contains = function(key) {
      return this._helperHash[key] !== undefined;
   };

   OrderedHashMap.prototype._checkConcurent = function() {
      if (this._reading) {
         throw new ReferenceError(rk("Конкурентная модификация объекта. Попытка изменения при переборе"));
      }
   };

   OrderedHashMap.prototype._getKeyIndex = function(key) {
      return this._keys.indexOf(key + "");
   };

   return OrderedHashMap;
});