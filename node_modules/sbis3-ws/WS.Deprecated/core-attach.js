define('Deprecated/core-attach', [
   'require',
   'Core/core-ready',
   'Core/IoC',
   'Core/Deferred',
   'Core/ParallelDeferred',
   'Core/constants',
   'Core/moduleStubs',
   'Core/load-contents',
   'Core/ConsoleLogger'
], function(
   require,
   cReady,
   IoC,
   Deferred,
   ParallelDeferred,
   constants,
   mStubs,
   loadContents
) {
   'use strict';

   var checkPackages = function(url) {
      var shortUrl = url.replace(constants.wsRoot, '/');
      var packages = constants.jsPackages;
      return packages[shortUrl] ? (constants.wsRoot + packages[shortUrl]) : url;
   };

   var urlWithHost = function(url) {
      var l = constants.hosts.length,
         host = '';
      if (l > 0) {
         host = constants.hosts[Math.floor(Math.random() * l)];
         if (url.substring(0, 1) == '.') {
            var curPath = window.location.pathname;
            curPath = curPath.substring(0, curPath.lastIndexOf('/') + 1);
            url = host + curPath + url.substring(2);
         } else {
            url = host + (url.substring(0, 1) == '/' ? '' : '/') + url;
         }
      }
      return url;
   };

   var buildRegExp = /\.v[0-9a-z]+/;
    /**
     *
     * @class Deprecated/core-attach
     * @public
     * @deprecated
     */
   var coreAttach = /** @lends Deprecated/core-attach.prototype */{
      /**
       * Создаёт экземпляр класса компонента из JS-кода. Метод применяется в тех случаях, когда по умолчанию компонент не должен быть описан в разметке.
       * Например, метод применяют в сценариях, где происходит вызов окна (см. {@link Lib/Control/Dialog/Dialog} или {@link SBIS3.CONTROLS/FloatArea}) в обработчике клика по интерфейсному элементу.<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию. Используйте метод <b>require</b>, о чем подробнее Вы можете прочитать <a href="https://wi.sbis.ru/doc/platform/developmentapl/interfacedev/core/component/js/index/#how-to-define-component-from-js">здесь</a>.
       * @param {String} path Путь к компоненту или его имя из пространства имён. Формат:
       * <ul>
       *    <li><b>/path/to/component:className</b> - путь к файлу с именем класса компонента. Пример: "Control/Field:FieldAbstract".</li>
       *    <li><b>/path/to/component</b>.</li>
       *    <li><b>className</b> - имя класса. Пример: "Lib/Control/Dialog/Dialog".</li>
       * <ul>
       * @param {Оbject} cfg Объект с конфигурацией экземпляра класса.
       * @returns {Core/Deferred} Асинхронный результат.
       * @example
       * <pre class="brush: js">
       * var iDef = Core.attachInstance('Control/Field:FieldAbstract', {});
       * iDef.addCallback(function(inst) {
       *    alert("ints instanceOf FieldAbstract: " + (inst instanceof Deprecated/Controls/FieldAbstract/FieldAbstract).toString());
       *    return inst;
       * }).addErrback(function(e) {
       *    alert(e.message);
       *    return e;
       * });
       * </pre>
       */
      attachInstance: function(path, cfg) {
         var deps = coreAttach.loadControlsDependencies([[path, cfg]], true);
         return deps.addCallback(function(ctor) {
            return new ctor[0](cfg);
         });
      },
      /**
       * Подключение цепочки компонентов.<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {String} path Компонент
       * @param {String} [servicePath] Путь к сервису, с которого загружать файлы.
       * @returns {Core/Deferred}
       */
      attachComponent: function(path, servicePath) {
         var resourceRoot,
             resDef = new Deferred(),
             queue,
             libPath,
             fileUrl,
             componentPath;

         if (!servicePath) {
            servicePath = '';
            resourceRoot = constants.resourceRoot;
         } else {
            resourceRoot = '/';
         }

         // Костыль
         if (path === 'Source') {
            resDef.callback();
            return resDef;
         }

         if ((typeof window !== 'undefined' || typeof process !== 'undefined') && (path.indexOf('Transport') > -1 || path.indexOf('Core') > -1)) {
            resDef.dependOn(mStubs.require([path]));
            return resDef;
         }

         queue = path.split("/");
         componentPath = queue[0];

         if (queue.length > 1) {
            IoC.resolve('ILogger').info('attachComponent', 'Метод attachComponent загружает путь до первого слеша. Возможно, не все ваши зависимости будут загружены.');
         }

         if (componentPath.indexOf('@') != -1) {
            componentPath = componentPath.split('@');
            var module = componentPath.shift();

            // если модуля нет в списке подключенных модулей,
            // то, значит, мы подключаем модули на сервере, и в таком случае
            // транслитерация не нужна
            if (module in constants.modules)
               module = constants.modules[module];

            libPath = servicePath + resourceRoot + module + "/";
         } else {
            libPath = servicePath + constants.wsRoot;
         }

         fileUrl = libPath + 'lib/' + componentPath + '.js';
         resDef.dependOn(mStubs.require([fileUrl]));
         return resDef;
      },
      /**
       * Получает описание переданного имени хэндлера<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {String} name
       * @returns {Object}
       */
      getHandlerInfo: function(name) {
         var
            pathParts = name.split('/'),
            handlerName = pathParts.pop(),
            handlerPackage = pathParts.pop(),
            ext = '.hdl',
            isModule = false,
            packageUniqName, type, fullPath;

         type = pathParts.pop();  // some kind of peek()
         if (type || type === '')  // if type is not null | undefined
         {
            pathParts.push(type);
         } // return it to path
         if (type != 'render')     // If it is not render
         {
            type = '_handlers';
         }   // ...set default handlers type

         if (handlerPackage in constants.jsCoreModules || handlerPackage in constants.jsModules) {
            pathParts.push(constants.jsCoreModules[handlerPackage] || constants.jsModules[handlerPackage]);
            packageUniqName = fullPath = handlerPackage;
            isModule = true;
         } else {
            pathParts.push(handlerPackage + ext);
            packageUniqName = pathParts.join('/');
            pathParts.pop();

            pathParts.push(handlerPackage + ext);
            fullPath = pathParts.join('/');
         }

         if (packageUniqName.indexOf('/resources/') === 0) {
            packageUniqName = packageUniqName.replace('/resources/', constants.resourceRoot);
         }
         if (fullPath.indexOf('/resources/') === 0) {
            fullPath = fullPath.replace('/resources/', constants.resourceRoot);
         }
         if (constants.buildnumber && !buildRegExp.test(fullPath)) {
            fullPath = fullPath.replace(ext, '.v' + constants.buildnumber + ext);
         }

         return {
            type: type,
            name: handlerName,
            'package': packageUniqName,
            url: fullPath,
            isModule: isModule
         };
      },
      /**
       * Загружает пакет, возвращает его через Deferred<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {String} name.
       * @returns {Core/Deferred} асинхронный результат загрузки пакета.
       */
      getHandlerPackage: function(name) {
         throw new Error('Function "Deprecated/core-attach::getHandlerPackage" delete in 3.17.300.');
      },
      /**
       * Загружает и получает указанную функцию-обработчик<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {String} name Имя обработчика в формате HandlerPackage/handlerName.
       * @returns {Core/Deferred} Deferred, результатом которого будет заказанный обработчик.
       */
      getHandler: function(name) {
         throw new Error('Function "Deprecated/core-attach::getHandler" delete in 3.17.300. Use "require".');
      },
      /**
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @function
       * Подключение JS/CSS-файла в контекст документа.
       * @param {String} URL URL подключаемого файла.
       * @returns {Core/Deferred}
       */
      attach: function(URL) {
         URL = checkPackages(URL);
         if (URL.charAt(0) !== '/') {
            URL = constants.wsRoot + URL;
         }
         URL = urlWithHost(URL);

         var
            nodeType = URL.replace(/^.*\.([^\.]+)(\?.*)?$/ig, "$1").toLowerCase(),
            resDef = new Deferred();
         resDef.addErrback(function (e) {
            return e;
         });

         if (nodeType == 'css') {
            require(['native-css!' + URL], function() {
               resDef.callback();
            }, function(error) {
               resDef.errback(error);
            });
         } else if (nodeType == 'js') {
            require([URL], function() {
               resDef.callback();
            }, function(error) {
               resDef.errback(error);
            });
         } else {
            resDef.errback(new Error("attach: Unknown resource type specified: " + URL));
         }
         return resDef;
      },
      /**
       * Подключает переданные файлы по порядку<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {Array} urls Массив строк с адресами файлов для подключения.
       * @return {Core/Deferred}
       */
      attachSequentally: function(urls) {
         urls = urls || [];
         urls = urls instanceof Array ? urls : [urls];

         var dResult = new Deferred(),
             moduleRegExp = /^(css!)/,
             fileRegExp = /^\/.+\.(js|css)/;

         dResult.addErrback(function (e) {
            return e;
         });

         (function loader() {
            if (urls.length) {
               var url = urls.shift();
               if (moduleRegExp.test(url)) {
                  mStubs.require(url).addCallbacks(loader, function(e) {
                     dResult.errback(e);
                  });
               } else if (fileRegExp.test(url)) {
                  // ХВАТИТЪЪЪ ИСПОЛЬЗОВАТЬ XML }:->
                  IoC.resolve('ILogger').info('CoreAttach', 'Additional files in xml file with full path is deprecated. Use module notation. Instead ' + url + ', use the module with plugin js! or css!.');
                  mStubs.require(url.indexOf('.css') > -1 ? 'native-css!' + url : url).addCallbacks(loader, function(e) {
                     dResult.errback(e);
                  });
               } else {
                  coreAttach.attach(url).addCallbacks(loader, function(e) {
                     dResult.errback(e);
                  });
               }
            } else {
               dResult.callback();
            }
         })();

         return dResult;
      },
      /**
       * Готовит ядро к работе с указанными компонентами.
       * Фактически замена Core.ready + attachComponent * N.<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @returns {Core/Deferred} Deferred готовности ядра + готовности всех компонентов.
       */
      withComponents: function(/*components*/) {
         var components = arguments;
         return cReady.addCallback(function() {
            var dComponents = new ParallelDeferred();
            for (var i = 0, li = components.length; i < li; i++) {
               var moduleName = components[i];
               (function(moduleName) {
                  var def = new Deferred();
                  dComponents.push(def);
                  require([moduleName], function(){
                     def.dependOn(coreAttach.loadControlsDependencies([[moduleName, {}]], false));
                  }, function(e) {
                     def.errback(e);
                  });
               })(moduleName);
            }
            return dComponents.done().getResult();
         });
      },
      /**
       * Прописывает оглавление<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {Object} contents.
       * @param {Boolean} [replace] заменять ли содержимое.
       * @param {Object} [options] опции для указания пути до service (/, /auth/ etc.) и resources (resources, myresources etc.).
       */
      loadContents: loadContents,
      /**
       * Загружает контролы и их зависимости по массиву конфигов контролов.<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param configsPaths Массив путей и конфигов для контролов. Пример:
       * <pre>
       *    [
       *       ['Control/DataViewAbstract/TableView', {config}],
       *       ['Control/DataViewAbstract/TreeView', {config}] ....
       *    ]
       * </pre>
       * @param resolveCtors Ожидается ли возвращение конструкторов модулями указанных контролов. Если
       * ожидается, то функция будет проверять значения, возвращённые модулями, и кидать исключения, если те не похожи на конструкторы.
       * @returns {Core/Deferred}
       */
      loadControlsDependencies: function(configsPaths, resolveCtors) {
         var loadedPaths = {};

         function loaderForPath(path, resolveCtor) {
            var result;
            var  coreModules =  ['Deprecated', 'Lib'],
               moduleName = path.indexOf('/') > 0 ? path.split('/')[0] : false;
            if (  moduleName && (coreModules.indexOf(moduleName) > -1 ||
                  Object.keys(constants.modules).some(function (name) {return constants.modules[name] === moduleName})) ||
                 (path.indexOf('SBIS3.') === -1 && path.indexOf('/') > -1) && path.indexOf('Control/') == -1
            ) {
               result = function() {
                  return mStubs.require([path]).addCallback(function(mod) {
                     return [path, mod[0]];
                  });
               };
            } else {
               result = function() {
                  var loadDfr = mStubs.require(path);

                  loadDfr.addCallback(function(mod) {
                     var ctor = mod[0];
                     if (!ctor && resolveCtor) {
                         throw new Error('Модуль ' + path + ' нельзя загрузить через core/core-attach');
                     }

                     return [path, ctor];
                  });

                  return loadDfr;
               };
            }

            return result;
         }

         function getPathLoadersPDef(configsPaths, needCtors) {
            return configsPaths.reduce(function(pDef, cfgPath) {
               var path_ = cfgPath[0], path, loader;

               if (!(path_ in loadedPaths)) {
                  loadedPaths[path_] = true;
                  loader = loaderForPath(path_, needCtors);
                  pDef.push(loader());
               }

               return pDef;
            }, new ParallelDeferred()).done().getResult();
         }

         function resolveDepsAsControlConfigs(configsPaths) {

            var DepResolver = require.defined('Core/DependencyResolver') ? require('Core/DependencyResolver') : false;

            return configsPaths.reduce(function(result, cfgPath) {
               var path = cfgPath[0],
                  cfg = cfgPath[1],
                  deps;

               deps = DepResolver && DepResolver.resolve(path, cfg) || [];
               deps.forEach(function(dep) {
                  result.push([dep, cfg]);
               });
               return result;
            }, []);
         }

         function constructorsForAllConfigs(configsPaths, pathsConstructors) {
            var hash = Object.keys(pathsConstructors).reduce(function(result, pathConstr) {
               var path =  pathsConstructors[pathConstr];
               result[path[0]] = path[1];
               return result;
            }, {});

            return configsPaths.map(function(cfgPath) {
               var path = cfgPath[0],
                  ctor = hash[path];

               if (resolveCtors && typeof ctor !== 'function') {
                  throw new Error("Can't instantiate class '" + path + "'. Class not exists");
               }

               return ctor;
            });
         }

         function loadPaths(configsPaths, resolveCtors) {
            var loadersPDef = getPathLoadersPDef(configsPaths, resolveCtors);

            return loadersPDef.addCallback(function(pathsConstructors) {
               var depConfigs = resolveDepsAsControlConfigs(configsPaths),
                  result;

               if (depConfigs.length > 0) {
                  result = loadPaths(depConfigs, false).addCallback(function() {
                     return pathsConstructors;
                  });
               } else {
                  result = pathsConstructors;
               }
               return result;
            });
         }

         return loadPaths(configsPaths, resolveCtors).addCallback(constructorsForAllConfigs.bind(undefined, configsPaths));
      },
      /**
       * Загружает зависимости компонента (его модули, и дополнительные модули, требуемые по его конфигурации), и отдаёт
       * deferred, который по готовности выдаёт функцию, конструирующую компонент, и берущую конфиг в качестве аргумента (как его конструктор).
       * Эта функция нужна для случая, когда хочется загрузить зависимости для нескольких компонентов зараз, и потом создать их синхронно,
       * предварительно проверив, не удалился во время загрузки зависимостей родительский контрол.<br/>
       * <b>Внимание:</b> метод является устаревшим и не рекомендуется к использованию.
       * @param {string} path путь компонента и имя класса
       *    /path/to/component:className
       *    /path/to/component - путь к файлу с компонентом
       *    className - имя класса, который надо инстанцировать
       * @param {object} cfg конфиг
       * @returns {Core/Deferred}
       * @deprecated Используйте {@link Deprecated/core-attach#loadControlsDependencies}. Удалено в 3.8.0
       */
      loadAttachInstanceDependencies: function(path, cfg) {
         return coreAttach.loadControlsDependencies([[path, cfg]], true).addCallback(function(ctors) {
            return function(cfg) {
               return new ctors[0](cfg);
            }
         })
      }
   };
   return coreAttach;
});
