define('Deprecated/RecordSet', [
   'Core/core-merge',
   'require',
   'Core/Abstract',
   'Core/Context',
   'Core/Deferred',
   'Core/ParallelDeferred',
   'Core/IoC',
   'Core/TimeInterval',
   'Deprecated/OrderedHashMap',
   'Deprecated/RecordTypes',
   'Deprecated/SerializatorSBIS',
   'Core/helpers/vital/objectsDiff',
   'Core/helpers/Object/isEmpty',
   'Core/helpers/Object/sortedPairs',
   'Core/helpers/Array/clone',
   'Core/helpers/getType',
   'Deprecated/helpers/parseIdentity',
   'Deprecated/Record'
], function(
   cMerge,
   require,
   Abstract,
   Context,
   Deferred,
   ParallelDeferred,
   ioc,
   TimeInterval,
   OrderedHashMap,
   RecordTypes,
   SerializatorSBIS,
   objectsDiff,
   isEmptyObject,
   sortedPairs,
   cloneArray,
   getType,
   parseIdentity
) {
   var RecordSet;

   var forEach = function (obj, iterateCallback, context) {
      if (obj === null || obj === undefined || obj.length === 0)
         return;

      var i, l, key;
      if (obj instanceof Array) {
         if (obj.forEach) {
            //В Firefox-е именно здесь глючит цикл обхода - пропускает некоторые итерации
            //Заменяю forEach на родной массивский - он работает нормально
            obj.forEach(iterateCallback, context);
         } else {
            l = obj.length;
            for (i = 0; i < l; i++) {
               if (i in obj) {
                  iterateCallback.call(context, obj[i], i, obj);
               }
            }
         }
      } else if ('length' in obj && (obj.length - 1) in obj) {
         /**
          * Это место переписано так не случайно.
          * При необъяснимых обстоятельствах на iOS 8.1 старая проверка
          * (obj.length === +obj.length) для obj === { 0: ??? }
          * давала положительный результат (obj.length в момент проверки был === 1)
          * Но следующая строка при чтении obj.length уже давала как и положено `undefined`
          * Как показали опыты, переписанная нижеследующим образом проверка не багает
          */
         l = parseInt(obj.length, 10);
         for (i = 0; i < l; i++) {
            if (i in obj) {
               iterateCallback.call(context, obj[i], i, obj);
            }
         }
      } else {
         for (key in obj) {
            if (obj.hasOwnProperty(key)) {
               iterateCallback.call(context, obj[key], key, obj);
            }
         }
      }
   };
   var map = function (obj, iterateCallback, context) {
      var results = [];
      if (obj === null || obj === undefined)
         return results;
      //todo: обработать jqueryObj
      forEach(obj, function (value, index, list) {
         results[results.length] = iterateCallback.call(context, value, index, list);
      }, context);
      if ('length' in obj && (obj.length - 1) in obj) {//если на входе массив - подгоним длину
         /**
          * В ios8 есть баг объект с числовыми ключами может содержать length
          * https://bugs.webkit.org/show_bug.cgi?id=142792
          */
         results.length = obj.length;
      }
      return results;
   };
   var filter = function (obj, iterateCallback, context) {
      var results = [];
      if (obj === null || obj === undefined)
         return results;

      //todo: обработать jqueryObj
      forEach(obj, function (value, index, list) {
         if (iterateCallback) {
            if (iterateCallback.call(context, value, index, list))
               results[results.length] = value;
         } else if (!!value) {
            results[results.length] = value;
         }
      }, context);

      return results;
   };

   /**
    * Класс "Набор данных".
    * @remark
    * Для данного класса поле первичного устанавливается по следующему правилу:
    * <ul>
    *    <li>Когда используется парсер {@link Deprecated/ParserSimple}, поле первичного ключа устанавливается значением опции pkColumnName.</li>
    *    <li>Когда используется парсер {@link Deprecated/ParserSBIS}, поле первичного ключа будет либо явно указанно в данных, либо используется первое объявленное поле.</li>
    * </ul>
    * Когда в качестве исходных данных для класса RecordSet передаются записи без первичного ключа, набор данных создан не будет.
    * В итоге визуально в контроле данные отображены не будут, даже если они переданы от источника (например, бизнес-логики).
    * Проверить созданный RecordSet, например, для табличного представления данных {@link Deprecated/Controls/TableView/TableView} можно с помощью метода {@link Deprecated/Controls/DataViewAbstract/DataViewAbstract#getRecordSet}:
    * <pre>
    *    TableView.getRecordSet().getRecords();
    * </pre>
    * Пустой RecordSet вернёт пустой массив.
    * @class Deprecated/RecordSet
    * @extends Core/Abstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   RecordSet = Abstract.extend(/** @lends Deprecated/RecordSet.prototype */{
      _moduleName: 'Deprecated/RecordSet',

      /**
       * @event onBeforeLoad Возникает в момент начала загрузки данных через Reader
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object}filter Значение фильтров, с которыми началась загрузка
       * @param {Object} options Опции, которые могли быть переданы при запросе
       */
      /**
       * @event onAfterLoad Возникает после окончания загрузки данных (RecordSet готов к использованию)
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Deprecated/RecordSet} recordSet Экземпляр рекорд-сета
       * @param {Boolean} isSuccess успешна ли загрузка
       * @param {Error} error произошедшая ошибка (если загрузка неуспешная)
       * @param {Object} options Опции, которые могли быть переданы при запросе
       */
      /**
       * @event onRecordUpdated Возникает после обновлении записи в текущем рекордсете
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Deprecated/Record} record измененная запись
       */
      /**
       * @event onRecordDeleted Возникает при удалении обновлении записи в текущем рекордсете
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {String} primaryKey Первичный ключ удаленной записи
       * @param {Deprecated/Record} record Сама удалённая запись
       */
      /**
       * @event onAbort возникает при прерывании загрузки
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       */
      /**
       * @event onPageChange при смене страницы рекордсета
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       */
      /**
       * @event onShadowLoad При загрузке, если указать в методе loadNode параметр shadowed
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Deprecated/RecordSet} У чего закончилась загрузка
       * @param {Boolean} isSuccess Закончилась ли загрузка успешно
       * @param {Array} shadowRecords Массив с загруженными записями
       */
      /**
       * @cfg {Object} Маппинг параметров на альтернативные поля контекста
       * @name Deprecated/RecordSet#paramsMapping
       */
      $protected: {
         _data: [],
         _columns: [],
         _way: null,
         _results: null,
         _requestBegin: 0,
         _timeElapsed: 0,
         _dataIterator: -1,
         _pkIndex: {},
         // МакаровАВ: если Список не вызывается, то оставался -1 и метод Создать работал не правильно
         _pkColumnIndex: 0,
         _columnsParsed: false,
         _lastError: false,
         _options: {
            /**
             * @cfg {Core/Context} Связанный контекст
             */
            context: '',
            /**
             * @cfg {Array} Массив имен параметров выборки
             */
            filterParams: {},
            /**
             * @cfg {Object} Обязательные параметры
             */
            requiredParams: [],
            /**
             * @cfg {String} Тип ридера
             */
            readerType: 'ReaderUnifiedSBIS',
            /**
             * @cfg {Object} Описание ридера = { adapterType, adapterParams }
             */
            readerParams: {},
            /**
             * @cfg {Boolean} Запрашивать данные при создании или нет
             */
            firstRequest: true,
            /**
             * @cfg {String} Тип постраничной навигации
             * @variant '' нет её (по умолчанию)
             * @variant parts по результатам загрузки узнаёт, есть ли следующая страница, в hasNextPage boolean
             * @variant full грузит информацию об общем количестве страниц, в hasNextPage number (общее число записей, вне одной конкретной страницы)
             */
            usePages: '',
            /**
             * @cfg {Number} Номер страницы, с которой открыть
             */
            pageNum: 0,
            /**
             * @cfg {Number} Количество записей на странице
             */
            rowsPerPage: 2,
            /**
             * @cfg {Array} Массив с информацией о сортировке, содержит в себе строки в виде:
             *    [String, Boolean] - имя колонки и тип сортировки (убывающая-возрастающая).
             * @example
             * <pre>
             *    sorting: [
             *       ['Название', true],
             *       ['Дата', false]
             *    ]
             * </pre>
             */
            sorting: null,
            /**
             * @cfg {Boolean} Дождаться ли выполнения ранее начатого запроса
             */
            waitForPrevQuery: false,
            /**
             * @cfg {String} Название колонки с индексом отца
             */
            hierarchyField: '',
            subscribeOnPS: true
         },
         _parsedColumns: undefined, //разобранные колонки
         _columnIndex: {},
         _childRecordsMap: [],
         _reader: null,
         _hasNextPage: 0,        //Есть ли следующая страница либо общее число записей
         _pageNum: 0,            //Текущая страница
         _usePages: '',          //Использование постраничной навигации или нет
         _sorting: null,         //Текущая сортировка
         _loaded: true,          //Загружается ли сейчас рекордсет
         _queryStack: [],        //Если поступают новые запросы до загрузки старых, то они могут класться опционально сюда и вызываться потом
         _initialFilter: {},     //Исходный фильтр, по которому инициализировался рекордсет
         _currentFilter: {},     //Текущий фильтр браузера
         _loadingId: undefined,  //Идентификатор последнего вызванного на загрузку узла
         _level: {},             //Глубина какой-либо записи
         _newData: undefined,    //Новые данные
         _loadExpanded: false,   //Являются ли загружаемые данные раскрытыми
         _tree: null,            //Дерево с данными
         _shadowed: false,       //Является ли текущий запрос скрытым
         _treeMap: null,         //Мап, содержит в себе ссылки на элементы дерева по ключам
         _loadingInfo: null,     //Объект с информацией о текущем запросе: деферред и опции пользователя
         _isEmptyTable: false,   //Флаг, пустая ли таблица
         _isChanged: false,      //Флаг, изменялась ли таблица
         _maxKey: 0,             //Максимальный ключ в рекордсете
         _snapShotColumns: [],   //Отображаемые колонки
         _snapShot: []           //Отпечаток рекордов на основании отображаемых колонок
      },
      $constructor: function() {
         this._pageNum = this._options.pageNum;
         this._usePages = this._options.usePages;
         this._options.rowsPerPage = parseInt(this._options.rowsPerPage, 10);
         this._sorting = this._options.sorting;
         this._initialFilter = this._prepareFilter(this._options.filterParams);
         this._publish('onBeforeLoad', 'onAfterLoad', 'onRecordUpdated', 'onRecordDeleted', 'onAbort', 'onPageChange', 'onShadowLoad');
         this._options.filterParams = this._options.filterParams || {};
         this._clearTreeMap();

         if (this._options.readerType !== '' && this._options.firstRequest) {
            this._beginLoad();
         }

         if (!(this._options.context instanceof Context)) {
            this._options.context = Context.global;
         }
      },
      /**
       * Возвращает клон рекордсета.
       * @return {Deprecated/RecordSet} клон рекордсета
       */
      clone: function() {
         var serializedRecordset = JSON.parse(JSON.stringify(this.toJSON()));

         return new RecordSet({
            readerType: 'ReaderSBIS',
            readerParams: {
               adapterType: 'TransportAdapterStatic',
               adapterParams: {
                  data: serializedRecordset
               }
            }
         });
      },
      getPkColumnType: function() {
         if (this._columns[this._pkColumnIndex]) {
            return this._columns[this._pkColumnIndex].t;
         }
         return '';
      },
      /**
       * Возвращает имя ключевой колонки.
       * @return {String} имя ключевой колонки, или пустую строку при отсутствии ключевой колонки
       */
      getPkColumnName: function() {
         var pkColumn = this._columns[this._pkColumnIndex];
         if (pkColumn) {
            return pkColumn.n;
         }
         return '';
      },
      getLinkedObjectName: function() {
         return this._options.readerParams.linkedObject;
      },
      toJSON: function() {
         return {
            s: this.getColumnsForSerialize(),
            d: this.getDataForSerialize(),
            _type: 'recordset',
            _mustRevive: true
         };
      },
      _onNewData: function(event, data) {
         if (data instanceof Array &&
            data.length > 0 &&
            this._columns.length > 0
         ) {
            var dataLength = data[0] instanceof Array ? data[0].length : undefined;
            if (dataLength !== this._columns.length) {
               throw new Error('Columns count of the income data (' + dataLength + ') is not equal to the columns count of the existing scheme (' + this._columns.length + ')');
            }
         }
         this._childRecordsMap = [];
         this._newData = data;
      },
      /**
       * Делаем скриншот текущих данных на основании списка колонок
       * @see: _getSnapColumns
       */
      _getSnapShot: function(records) {
         if (!this._snapShotColumns.length) return false;
         var self = this;
         var snapShot = [];
         records.forEach(function(record) {
            var key = record.get(record.getKeyField()),
               arr = {};
            arr[key] = {};
            self._snapShotColumns.forEach(function(column) {
               if (record.hasColumn(column)) {
                  var val = record.get(column),
                     Record = require('Deprecated/Record');
                  if (val instanceof Record || val instanceof RecordSet) {
                     val = JSON.stringify(val.toJSON());
                  }
                  arr[key][column] = val;
               }
            });
            snapShot.push(arr);
         });
         return snapShot;
      },
      /**
       * Сохраняем список колонок для отслеживания изменений.
       * @param {Object} columns Список колонок, которые мы будем обрабатывать при сравнении
       */
      getSnapColumns: function(columns) {
         var self = this;
         this._snapShotColumns = [];
         for (var key in columns) {
            if (columns.hasOwnProperty(key)) {
               var
                  column = columns[key];
               column.title && self._snapShotColumns.push(column.title);
            }
         }
      },
      _compareSnapColumns: function(newColumns){
         newColumns = map(newColumns, function(value){
            return value.title;
         });
         if (this._snapShotColumns.length !== newColumns.length){
            return false;
         }

         for (var i = 0,l = newColumns.length; i < l; i++){
            if (newColumns.indexOf(this._snapShotColumns[i]) < 0){
               return false;
            }
         }
         return true;
      },
      /**
       * Создаем слепок записей рекордсета
       * @param [Array] columns Список колонок, которые мы будем обрабатывать при сравнении
       */
      storeSnapShot: function(columns) {
         columns && this.getSnapColumns(columns);
         this._snapShot = this._getSnapShot(this.getRecords());
      },
      /**
       * Получить список изменений между сохраненным набором записей и текущим
       * @param [Array] resultRecords Массив текущих записей
       * @return {Array} Массив изменений
       */
      checkSnapShot: function(resultRecords) {
         var
            records = [];
         if (!this._compareSnapColumns(this.getColumns())){
            return false;
         }
         records = this._getSnapShot(resultRecords || this.getRecords());
         return records ? (!!objectsDiff && !!this._snapShot.length && objectsDiff(this._snapShot, records)) : false;
      },

      /**
       * Позволяет фильтровать набор данных.
       * Фильтруется пользователем с помощью переданной функции. По завершению поднимает событие onAfterLoad.
       * Является альтертантивным спобом фильтрации и предоставляет возможность фильтровать данные на клиенте.
       * @param {Function} func функция, принимающая на вход запись {Deprecated/Record}. Если вернет true, то запись останется в наборе
       */
      filter: function(func) {
         this._newData = [];
         this.each(function(record) {
            if (func(record)) {
               this._newData.push(record.getDataRow());
            }
         });
         //почистим информацию о ранее загруженной иерархии
         this._clearTreeMap();
         this._onComplete({}, true, false, false, false);
      },
      /**
       * Очищает _treeMap
       * @protected
       */
      _clearTreeMap: function() {
         this._treeMap = new OrderedHashMap();
         this._tree = new OrderedHashMap();
      },
      /**
       * возвращает контекст рекордсета
       * @return {Object} контекст рекордсета
       */
      getContext : function(){
         return this._options.context;
      },
      /**
       * Устанавливает контекст рекордсета
       * @param {Object} context
       */
      setContext : function(context){
         this._options.context = context;
      },
      /**
       * Вызывает немедленную перезагрузку RecordSet без изменения каких-либо настроек
       */
      reload: function() {
         var info = this._createLoadingInfo();
         this._beginLoad(undefined, undefined, info);
         return info.deferred;
      },
      /**
       * Меняет источник данных
       * @param {String} readerType тип ридера
       * @param {Object} readerParams Параметры ридера
       * @param {Object} filter Параметры фильтрации
       * @param {Object} load загружать ли данные
       */
      setSource: function(readerType, readerParams, filter, load){
         this._options.readerType = readerType;
         this._options.readerParams = readerParams;
         this._options.filterParams = filter;
         this._reader = null;
         return this._processLoad(undefined, load === false, true);
      },
      /**
       * Возвращает описание набора данных, по которому построено. Содержит readerType, readerParams, filterParams
       * @returns {Object}
       */
      getSource: function(){
         return {
            readerType: this._options.readerType,
            readerParams: this._options.readerParams,
            filterParams: this._options.filterParams
         };
      },
      /**
       * Создаёт объект с информацией о текущем запросе
       * @param {Object} options Объект с пользовательскими опциями
       * @return {Object}
       * @protected
       */
      _createLoadingInfo: function(options){
         return {
            options: options,
            deferred: new Deferred({
               cancelCallback: this.abort.bind(this, false)
            })
         };
      },
      /**
       * Меняет параметры выборки.
       * !Внимание. Параметры фильтрации не заменяются безусловно.
       * Вновь переданные домердживаются на все ранее сделанные.
       * @param {Object} filter Параметры фильтрации
       * @param {Boolean|undefined} clear очищать ли все записи при загрузке
       * @param {Object} [options] Объект с пользовательскими параметрами
       * @param {Boolean} [noLoad] Не загружать данные, а просто запомнить фильтр
       * @returns {Core/Deferred} Асинхронное событие. Результатом работы является количество записей в новой выборке.
       * @example
       * <pre>
       *    myRecordSet.setQuery({'ГодРождения' : 1965})
       *       .addCallback(function(records_count){
    *              alert('Пришло ' + records_count + ' записей');
    *              return records_count;
    *           });
       * </pre>
       */
      setQuery: function(filter, clear, options, noLoad) {
         var curFilter = this._prepareFilter(filter),
            filterParams = cMerge({}, this._options.filterParams);
         //Все-таки переписываем filterParams, но сохраняем для них настройку получения данных из контекста
         this._options.filterParams = cMerge({}, curFilter);
         if (filterParams) {
            for (var i in curFilter) {
               if (curFilter.hasOwnProperty(i)) {
                  //Сохраянем настройку получения данных из контекста
                  if (filterParams[i] !== null && typeof( filterParams[i]) === 'object' && 'fieldName' in  filterParams[i]) {
                     this._options.filterParams[i] = filterParams[i];
                  }
               }
            }
         }
         if (noLoad) {
            this._currentFilter = curFilter;
         }
         return this._processLoad(curFilter, noLoad, clear, options);
      },
      _processLoad: function(filter, noLoad, clear, loadingOptions) {
         var info;
         if (noLoad) {
            return new Deferred().callback();
         } else {
            info = this._createLoadingInfo(loadingOptions);
            this._beginLoad(filter, clear, info);
            return info.deferred;
         }
      },
      /**
       * Метод сброса фильтров
       * @param {Object} filter Параметры фильтрации
       * @param {Boolean} noLoad Не инициировать загрузку данных
       */
      resetFilter: function(filter, noLoad) {
         this._options.filterParams = filter || {};
         if (this._options.requiredParams.length > 0) {
            for (var i = 0; i < this._options.requiredParams.length; i++) { // сбрасываем параметры рекордсета, параметры рекордсета == обязательные параметры, все остальные у браузера
               if (this._options.requiredParams.hasOwnProperty(i)) {
                  this._options.filterParams[this._options.requiredParams[i]] = this._initialFilter[this._options.requiredParams[i]];
               }
            }
         }
         this._currentFilter = cMerge({}, this._options.filterParams);
         //this._options.filterParams = $ws.core.merge({},filter,{clone:true});
         return this._processLoad(undefined, noLoad, true);
      },
      /**
       * Метод получения текущих параметров фильтра
       */
      getQuery: function() {
         // вернем фильтр, по которому строилась последний раз выборка с подставленными значениями (если был маппинг)
         return this._currentFilter;
      },
      /**
       * Возвращает фильтр только с перечитанными полями из контекста (параметры, которых нет в контексте удаляются)
       * @param {Object} filterParams Объект с фильтром, который содержит данные о контексте
       */
      getUpdatedQuery: function(filterParams) {
         var filter = cMerge({}, this._options.filterParams);
         for (var i in filterParams) {
            if (!filterParams.hasOwnProperty(i)) {
               continue;
            }
            if (typeof(filterParams[i]) === 'function' || (filterParams[i] instanceof Object && filterParams[i]['fieldName'] !== undefined)) {
               filter[i] = filterParams[i];
            } else {
               //Нам передают старые параметры, и так как они в контексте не лежат, их отсюда нужно убрать
               //Чтобы их уже не актуальные значения не попали в фильтр
               delete filter[i];
            }
         }
         return this._prepareFilter(filter);
      },
      /**
       * Подготавливает фильтр.
       * @param {Object} filter
       * @param {Boolean} [notReadyValuesOnly] Нужно ли только обновлять значения
       * @param {Boolean} [notUpdate] Нужно ли обновлять значения
       * @returns {Object} новый фильтр (исходное значение не меняется!)
       */
      _prepareFilter: function(filter, notReadyValuesOnly, notUpdate) {
         var requiredParams = {},
            curFilter = filter || {}, //? $ws.core.merge({}, filter) : {},
            retval = {},
            l = this._options.requiredParams.length,
            val, x, param;
         for (x = 0; x < l; x++) { // возьмем значения если не задали, здесь если их нет то будет либо значение, либо ссылка на контекст, либо функция
            param = this._options.requiredParams[x];
            requiredParams[param] = true;
            if (!(param in curFilter) && !notReadyValuesOnly) {
               curFilter[param] = this._initialFilter[param];
            }
         }
         for (var i in curFilter) {
            val = undefined;
            if (curFilter.hasOwnProperty(i)) {
               if (curFilter[i] !== null && typeof(curFilter[i]) === 'object' && 'fieldName' in curFilter[i]) {
                  if (this._options.context.getValue !== undefined && !notUpdate) {
                     val = this._options.context.getValue(curFilter[i].fieldName);
                  }
               }
               else if (typeof(curFilter[i]) === 'function') {
                  if (!notUpdate) {
                     val = curFilter[i].apply(this, [this._options.context, i]);
                  }
               } else {
                  val = curFilter[i];
               }
               if (val !== undefined) {
                  retval[i] = val;
               } else if (requiredParams[i] === true && !notReadyValuesOnly) {
                  retval[i] = this._initialFilter[i];
               }
            }
         }
         if (!notReadyValuesOnly) {
            if (this._usePages) {
               retval['pageNum'] = this._pageNum;
               retval['pageCount'] = this._options.rowsPerPage;
               if (this._pageNum === -1) {
                  retval['usePages'] = 'full';
               }
               else {
                  retval['usePages'] = this._usePages;
               }
            } else {
               delete retval['pageNum'];
               delete retval['pageCount'];
               delete retval['usePages'];
            }
            if (this._sorting) {
               retval['sorting'] = this._sorting;
            }
         }
         return retval;
      },
      /**
       * Подготавливает фильтр
       * @param {Object} filter Фильтр
       * @param {Boolean} [notReadyValuesOnly] Нужно ли только обновлять значение, которые берутся из контекста или по результату функции
       * @returns {Object}
       */
      prepareFilter: function(filter, notReadyValuesOnly) {
         return this._prepareFilter(filter, notReadyValuesOnly);
      },
      /**
       * Инициирует загрузку данных
       * @param {Object} [filter] фильтр, который использовать при загрузке, либо ничего и тогда автоматический просчёт
       * @param {Boolean|undefined} [clear] очищать ли всё при загрузке
       * @param {Object} [info] Информация о текущем запросе
       * @param {boolean} [addToStack] Добавить ли запрос в очередь
       */
      _beginLoad: function(filter, clear, info, addToStack) {
         var self = this;
         if (!this._loaded) {
            if (this._options.waitForPrevQuery || addToStack === true) {
               this._queryStack.push([this._prepareFilter(this._options.filterParams), info]);
               return;
            }
            else {
               this.getReader().abort();
            }
         }
         var curFilter = this._prepareFilter(filter ? filter : this._options.filterParams);
         this._shadowed = curFilter['shadowed'];
         if (!this._shadowed) {
            this._notify('onBeforeLoad', curFilter, info && info.options);
         }
         this._loaded = false;
         this._newData = [];
         if (this._options.hierarchyField) {
            this._loadingId = curFilter[this._options.hierarchyField];
            if (!(this._loadingId instanceof Array)) {
               this._loadingId = [this._loadingId];
            }
         }
         else {
            this._loadingId = [null];
         }
         this._loadExpanded = (curFilter['Разворот'] === 'С разворотом');
         if (clear) {
            this._pkIndex = {};
            this._level = {};
            this._data = [];
            this._tree.clear();
            this._treeMap.clear();
         }
         this._loadingInfo = info;
         this._currentFilter = curFilter;
         var result = this.getReader().readRecords(curFilter, this._columnsParsed);
         result.addBoth(function() {
            self._loaded = true;
            var first = self._queryStack.shift();
            if (first) {
               self._beginLoad(first[0], undefined, first[1]);
            }
         });
      },
      /**
       * Обновляет информацию о следующей страницу
       * @param {Object} event Объект события
       * @param {Number|Boolean} nextPage Следующая страница
       * @private
       */
      _updateNextPage: function(event, nextPage) {
         if (this._pageNum === -1) {
            this._pageNum = Math.ceil(nextPage / this._options.rowsPerPage) - 1;
            this._hasNextPage = false;
         }
         else {
            this._hasNextPage = nextPage;
         }
      },
      /**
       * Устанавливает текущую страницу в рекордсете и начинает загрузку
       * @param {Number} pageNum Номер страницы
       * @param {Boolean} [noLoad] установка страницы без загрузки данных
       * @param {Boolean} [noClear] не чистить ли всё остальное
       */
      setPage: function(pageNum, noLoad, noClear) {
         this._pageNum = pageNum;
         this._notify('onPageChange', pageNum);
         return this._processLoad(undefined, noLoad, !noClear);
      },
      /**
       * Устанавливает количество записей на странице
       * @param {Number} pageCount Количество записей
       * @param {Boolean} [noLoad] Не загружать данные
       */
      setPageSize: function(pageCount, noLoad) {
         this._options.rowsPerPage = pageCount;
         this._pageNum = 0;
         this._notify('onPageChange', 0);
         return this._processLoad(undefined, noLoad, false);
      },
      /**
       * Возвращает текущий размер страницы в рекордсете
       * @return {Number}
       */
      getPageSize: function() {
         return this._options.rowsPerPage;
      },
      /**
       * Устанавливает тип постраничной навигации
       *
       * Доступны следующие типы:
       * 1. '' - нет постраничного вывода,
       * 2. 'parts' - по результатам загрузки узнаёт, есть ли следующая страница, в hasNextPage boolean
       * 3. 'full' - грузит информацию об общем количестве страниц, в hasNextPage number (общее число записей, вне одной конкретной страницы)
       * @param {String} type Тип постраничной навигации
       */
      setUsePages: function(type) {
         this._pageNum = 0;
         this._usePages = type;
      },
      /**
       * Возвращает boolean, если usePages == 'parts'
       * Возвращает общее число страниц, если usePages == 'full'
       * @param {Boolean|undefined} [booleanResult] возвращать либо true либо false в зависимости от наличия следующей страницы
       * @returns {Number|boolean} общее число страниц
       */
      hasNextPage: function(booleanResult){
         if (!booleanResult){
            return this._hasNextPage;
         }

         if(this._usePages === 'full'){
            return this._hasNextPage > (this._pageNum + 1) * this._options.rowsPerPage;
         } else {
            return !!this._hasNextPage;
         }
      },
      /**
       * Используется ли постраничная навигация
       * @return {Boolean}
       */
      usePaging: function(){
         return !!this._usePages;
      },
      /**
       * Получение номера текущей страницы
       * @return {Number} номер страницы
       */
      getPageNumber : function(){
         return this._pageNum;
      },
      getRecords : function(){
         var records = [],
            l = this._data.length,
            i = 0;
         while(i < l){
            records.push(this.at(i));
            i++;
         }
         return records;
      },
      /**
       * Устанавливает сортировку и перезагружает рекордсет
       * @param {Array} [sorting] Массив массивов с информацией о сортировке: [ [поле, сортировать ли по убыванию], ... ]. Чем раньше поле, тем оно важнее для сортировки
       * @param {Object} [filter] Фильтр, который должен использоваться
       * @param {Boolean|undefined} [noClear] не чистить ли всё остальное
       * @param {Boolean} [noLoad] Если указано, то загрузки не будет
       */
      setSorting: function(sorting, filter, noClear, noLoad){
         this._sorting = sorting || null;
         return this._processLoad(filter, noLoad, !noClear);
      },
      /**
       * Метод получения ридера
       * @returns {Deprecated/ReaderAbstract} Инстанс ридера
       */
      getReader: function() {
         if (!this._reader) {
            /*var params = $ws.core.merge({
               handlers: this._getReaderHandlers()
            }, this._options.readerParams);*/
            this._options.readerParams.handlers = this._getReaderHandlers();

            var Reader = require.defined('Deprecated/' + this._options.readerType) ? require('Deprecated/' + this._options.readerType) : null;
            if (Reader) {
               this._reader = new Reader(this._options.readerParams);
            } else {
               throw new Error("Reader type is not specified");
            }
         }
         return this._reader;
      },
      _getReaderHandlers: function() {
         return {
            'onNewRecord': this._onNewRecord.bind(this),
            'onParseData': this._onParseData.bind(this),
            'onWayExists': this._onWayExists.bind(this),
            'onResults': this._onResults.bind(this),
            'onSettingsParsed': this._onSettingsParsed.bind(this),
            'onComplete': this._onComplete.bind(this),
            'onNewData': this._onNewData.bind(this),
            'onNextPageChange': this._updateNextPage.bind(this)
         };
      },
      /**
       * Метод получения пути
       * @returns {Deprecated/RecordSet} путь к узлу
       */
      getWay: function(){
         return this._way;
      },
      /**
       * Метод получения итогов
       * @returns {Deprecated/Record} строка итогов
       */
      getResults: function(){
         return this._results;
      },
      /**
       * Внутренний обработчик события создания новой записи
       * @param {Object} eventState
       * @param {Array} data массив с данными "как есть" из запроса
       */
      _onNewRecord: function(eventState, data) {
         this._newData.push(data);
      },
      /**
       * Внутренний обработчик события парсинга данных
       * @param {Object} eventState
       * @param {Array} data массив с данными "как есть" из запроса
       */
      _onParseData: function(eventState, data) {
         this._way = null;
         this._results = null;
      },
      /**
       * Обработчик пути
       * @param {Event} eventState
       * @param way //TODO коммент
       */
      _onWayExists: function(eventState, way) {
         if (way.d) {
            var dataSource = {
                  readerType: 'ReaderSBIS',
                  readerParams: {
                     pkColumnName: way.s[way.k || 0].n,
                     adapterType: 'TransportAdapterStatic',
                     adapterParams: {
                        data: {
                           s: way.s,
                           d: way.d
                        }
                     }
                  }
               },
               self = this;
            self._way = new RecordSet(dataSource);
         }
      },
      /**
       * Пустая ли таблица
       * @param {Event} eventState
       * @param isEmptyTable - пустая ли таблица
       */
      isEmptyTable: function() {
         return this._isEmptyTable;
      },
      /**
       * Обработчик итогов
       * @param {Event} eventState
       * @param results пришедшие итоги
       */
      _onResults: function(eventState, results) {
         var Record = require('Deprecated/Record');
         this._results = new Record({
            colDef: results.columns,
            row: results.row,
            pkValue: null,
            parentRecordSet: null
         });
      },
      /**
       * Внутренний обработчик события готовности конфигурации колонок
       * @param {Object} eventState
       * @param {Object} columnConfig Конфигурация колонок
       * @param {Number} pkColumnIndex индекс колонки с праймари ключем
       *
       */
      _onSettingsParsed: function(eventState, columnConfig, pkColumnIndex) {
         var
            l = columnConfig.length,
            i = 0;
         this._columnIndex = {};
         while (i < l) {
            this._columnIndex[columnConfig[i].n] = i;
            i++;
         }
         this._columnsParsed = l > 0;
         if (this._columnsParsed &&
             this._data.length > 0 &&
             this._columns.length !== l
         ) {
            ioc.resolve('ILogger').log(
               'RecordSet::_onSettingsParsed()',
               'Columns count of the income scheme (' + l + ') is not equal to the columns count of the existing scheme (' + this._columns.length + '). This will cause potential errors.'
            );
         }
         this._pkColumnIndex = pkColumnIndex;
         this._columns = columnConfig;
      },
      /**
       * Возвращает, распарсили ли мы уже колонки, или нет
       */
      isInit: function() {
         return this._columnsParsed;
      },
      /**
       * Добавляет в себя иерархические данные
       * @param {Array} data Массив с записями
       * @private
       */
      _buildHierarchyData: function(data) {
         var childs = new OrderedHashMap(),
            shadowRecords = [],
            i, len,
            found = {}, //Практически найденные записи, которые не должны лежать в корне
            parent,
            self = this,
            loadedMap = {},
            recordsMap = {},
            record,
            recursive = false,
            treeKeys = {},
            key,
            recordParent = function(data) {
               var parent = data[self.getColumnIdx(self._options.hierarchyField)];
               parent = parseIdentity(parent);
               return parent;
            },
            isParentEqual = function(parent0, parent1) {
               if (parent0 == 'null') {
                  parent0 = null;
               }
               if (parent1 == 'null') {
                  parent1 = null;
               }
               return parent0 == parent1;
            },
            //Запоминает записи из незагруженных веток и не учитывает старые из загруженных
            viewTree = function(node) {
               node.each(function(k, v) {
                  if (!loadedMap[k]) {
                     if (v.childs) {
                        childs.put(k, []);
                        v.childs.each(function(k2, v) {
                           if (isParentEqual(recordParent(v.record), k)) {//Возможно, данные записи обновили
                              childs.get(k).push(v.record);
                              found[k2] = true;
                           }
                        });
                     }
                  }
                  if (!loadedMap[k] || !self._loadExpanded) {
                     viewTree(v.childs);
                  }
               });
            },
            childsFilling = function(arrData) {
               for (i = 0, len = arrData.length; i < len; ++i) {
                  parent = recordParent(arrData[i]);
                  childs.put(parent, []);
                  childs.get(parent).push(arrData[i]);
                  found[arrData[i][self._pkColumnIndex]] = true;
               }
            },
            appendToData = function(node, level) {
               node.each(function(k, v) {
                  if (!found[k]) {
                     return;
                  }
                  if (v.record) {
                     if (self._shadowed) {
                        shadowRecords.push(v.record);
                     }
                     else {
                        self._pkIndex[k] = self._data.length;
                        self._data.push(v.record);
                     }
                  }
                  self._level[k] = level;
                  if (!v.childs) {
                     v.childs = new OrderedHashMap();
                  }
                  if (!self._shadowed) {
                     self._treeMap.put(k, v.childs);
                  }
                  if(childs.contains(k)) {
                     if (!self._shadowed) {
                        if (treeKeys[k]) {
                           recursive = true;
                        }
                        treeKeys[k] = true;
                        var items = childs.get(k);
                        for(var j = 0, len = items.length; j < len; ++j){
                           var rec2 = items[j],
                              key = parseIdentity(rec2[self._pkColumnIndex]),
                              nHM;
                           if (v.childs.put(
                              key,
                              {
                                 record: rec2,
                                 childs: nHM = new OrderedHashMap()
                              }
                           )) {
                              self._treeMap.put(key, nHM);
                           }
                           else {
                              self._treeMap.put(key, v.childs.get(key).childs);
                           }
                        }
                        treeKeys[k] = false;
                     }
                     if (!recursive) {
                        appendToData(v.childs, level + 1);
                     }
                  }
                  return true;
               });
            };

         if (this._loadingId) {
            for (i = 0, len = this._loadingId.length; i < len; ++i) {
               loadedMap[this._loadingId[i]] = true;
            }
         }

         /*
          *  Читаем ветку this._tree в childs
          */
         viewTree(this._tree);

         /*
          *  Заполняем новыми значениями childs
          */
         childsFilling(data);

         for (i = 0, len = this._childRecordsMap.length; i < len; ++i) {
            record = this._childRecordsMap[i];
            if (record) {
               recordsMap[record.getKey()] = record;
            }
         }

         this._level = {};
         this._data = [];
         this._pkIndex = {};
         this._clearTreeMap();
         childs.each((function(key) {
            if (!found[key]) {
               found[key] = true;
               this._tree.put(key, {
                  record: undefined,
                  childs: new OrderedHashMap()
               });
            }
         }).bind(this));
         appendToData(this._tree, -1); //На нулевом уровне теперь несуществующие папки, так что передаём -1
         this._childRecordsMap = [];
         for (i = 0, len = this._data.length; i < len; ++i) {
            key = this._data[i][this._pkColumnIndex];
            if (recordsMap[key]) {
               this._childRecordsMap[i] = recordsMap[key];
            }
            if (this._maxKey < key) {
               this._maxKey = key;
            }
         }
         if (recursive) {
            ioc.resolve('ILogger').error("RecordSet", "Recursive hierarchy data");
         }
         return shadowRecords;
      },
      /**
       * Внутренний обработчик события завершения обработки данных Reader'ом
       * @param {Object} eventState
       * @param {Boolean} isSuccess Успешность обработки
       * @param {Object} error Ошибка
       * @param {boolean} isEmptyTable Флаг наличия данных в таблице
       * @param {boolean} noConfirm  Если true, то не будет стрелять onAfterLoad (нужно для добавления сразу нескольких записей)
       * @param {boolean} [noBuildHierarchy]  Если true, то не будет строиться иерархия (для оптимизации при множественном appendRecord)
       */
      _onComplete : function(eventState, isSuccess, error, isEmptyTable, noConfirm, noBuildHierarchy){
         //сбросим описание колонок, так как каждый раз колонки переначитываем
         if (isSuccess) {
            this._parsedColumns = undefined;
         }
         var shadowRecords,
            newRecords = [].concat(this._newData);
         if (this._options.hierarchyField !== '' && !noBuildHierarchy) {
            shadowRecords = this._buildHierarchyData(this._newData);
         }
         else {
            if (this._shadowed) {
               shadowRecords = this._newData;
            }
            else {
               this._childRecordsMap = [];
               this._pkIndex = {};
               this._level = {};
               this._data = [];

               for (var j = 0, len2 = this._newData.length; j < len2; ++j) {
                  var tempId = parseIdentity(this._newData[j][this._pkColumnIndex]);
                  this._level[tempId] = 0;
                  this._pkIndex[tempId] = this._data.length;
                  this._data.push(this._newData[j]);
                  if (tempId > this._maxKey) {
                     this._maxKey = tempId;
                  }
               }
            }
         }
         this._newData = [];

         //this._timeElapsed = new Date() - this._requestBegin;
         if (!isSuccess) {
            this._lastError = error;
         } else {
            this._isEmptyTable = !!(isEmptyTable === false);
         } // Пока будем выставлять, когда запрос был удачен

         this.rewind();
         if (this._shadowed) {
            this._notify('onShadowLoad', this, isSuccess, error, shadowRecords);
            this._shadowed = false;
         }
         else {
            if (!noConfirm) {
               this._notify('onAfterLoad', this, isSuccess, error, this._loadingInfo && this._loadingInfo.options);
            }

            if (this._loadingInfo && !this._loadingInfo.deferred.isReady()) {
               if (isSuccess) {
                  this._loadingInfo.deferred.callback(newRecords.length);
               } else {
                  this._loadingInfo.deferred.errback(error);
               }
            }
         }
      },
      _produceRecord: function(data) {
         if (data === null || data === undefined) {
            return null;
         }

         var Record = require('Deprecated/Record');
         return new Record({
            row: data.row,
            colDef: data.columns,
            parentRecordSet: this,
            pkValue: parseIdentity(data.row[data.pk]),
            objectName: data.objectName
         });
      },
      /**
       * Возвращает в колбэке новую "пустую" строку из базы, предзаполненную переданным фильтром
       * @param {Object} filter фильтр для создания новой записи
       * @param {String} [methodName] имя методя для выяснения формата
       * @returns {Core/Deferred}
       */
      createRecord: function(filter, methodName) {
         return this
            .getReader()
            .createRecord(this._prepareFilter(filter), methodName)
            .addCallback(this._produceRecord.bind(this));
      },
      /**
       * если id не задан - возвращает в колбэке новую "пустую" строку из базы (в рекордсет запись не вставляется)
       * иначе возвращет строку из базы по id
       * @param {String} id идентификатор запрашиваемой записи
       * @param {Object} [filter] фильтр для создания новой записи (если будет создание)
       * @param {String} [linkName] Имя связи (вычитывается только связь)
       * @returns {Core/Deferred} асинхронное событие стреляет готовым рекордом
       */
      readRecord: function(id, filter, linkName) {
         if (id === undefined) {
            ioc.resolve('ILogger').log("RecordSet", "It is not recommended to use readRecord with id === undefined, use createRecord.");
            return this.createRecord(filter);
         } else {
            return this.getReader().readRecord(id, filter, linkName).addCallback(this._produceRecord.bind(this));
         }
      },
      /**
       * если id не задан - возвращает в колбэке новую "пустую" строку из базы (в рекордсет запись не вставляется)
       * иначе возвращет строку из базы по id
       * @param {String} id идентификатор запрашиваемой записи
       * @returns {Core/Deferred} асинхронное событие стреляет готовым рекордом
       */
      copyRecord: function(id, format) {
         try {
            return this.getReader().copyRecord(id, format).addCallback(this._produceRecord.bind(this));
         } catch (e) {
            return Deferred.fail(e);
         }
      },
      /**
       * Объединить записи с указанными идентификаторами.
       * @param {String} mergeKey Идентификатор записи, с которой объединяем.
       * @param {String|Array} recordKey Идентификатор записи, которую объединяем.
       * @returns {Core/Deferred} Асинхронное событие, стреляет готовым рекордом.
       */
      mergeRecords: function(mergeKey, recordKey) {
         var self = this;
         try {
            return this.getReader().mergeRecords(mergeKey, recordKey).addCallback(function() {
               self.clearRecord(recordKey);
            });
         } catch (e) {
            return Deferred.fail(e);
         }
      },
      /**
       * Чистит данные и _pkIndex у RecordSet'а
       */
      clear: function() {
         this._data = [];
         this._newData = [];
         this._pkIndex = [];
         this._level = {};
         this._tree.clear();
         this._treeMap.clear();
         this._childRecordsMap = [];
         this._pageNum = 0;
         this._notify('onPageChange', 0);
      },
      /**
       * Чистит данные и _pkIndex у RecordSet'а для Record'а с заданным pk
       * @param {String} pk первичный ключ записи
       */
      clearRecord: function(pk) {
         if (this._pkIndex[pk] !== undefined) {//only if record was not empty
            if (this._options.hierarchyField) {
               var record = this.at(this._pkIndex[pk]),
                  Record = require('Deprecated/Record'),
                  parent, hashMap;
               if (record instanceof Record) {
                  parent = record.get(this._options.hierarchyField);
                  hashMap = this._treeMap.get(parent);
                  if (hashMap) {
                     hashMap.remove(pk);
                  }
               }
            }
            this._data.splice(this._pkIndex[pk], 1); // Remove Record from data array
            this._childRecordsMap.splice(this._pkIndex[pk], 1);
            this._removeKeyFromIndex(pk); // Rebuild key index
            delete this._level[pk]; // Remove item from level index
         }
      },
      /**
       * Очистка всех записей, parent которых - указанный, а также всех зависимых от них и т д
       * Возвращает массив с ключами удалённых записей
       * @param {String} pId Парент очищаемых записей
       */
      clearNode: function(pId) {
         if (this._pkIndex[pId] === undefined) {
            return [];
         }
         var key, i, len, level;

         for (i = this._pkIndex[pId] + 1,
         len = this._data.length,
         level = this._level[pId]; i < len; ++i) {
            if (!this._data[i]) {
               continue;
            }
            key = this._data[i][this._pkColumnIndex];
            if (this._level[key] > level) {
               this._data[i] = null;
               this._tree.remove(key);
               this._treeMap.remove(key);
               delete this._pkIndex[key];
               delete this._level[key];
            }
            else {
               break;
            }
         }
         this._data = filter(this._data, function(value) {
            return value !== null;
         });

         var recordsMap = {},
            record;
         for (i = 0, len = this._childRecordsMap.length; i < len; ++i) {
            record = this._childRecordsMap[i];
            if (record) {
               recordsMap[record.getKey()] = record;
            }
         }
         this._childRecordsMap = [];
         for (i = 0, len = this._data.length; i < len; ++i){
            key = this._data[i][this._pkColumnIndex];
            if(recordsMap[key]){
               this._childRecordsMap[i] = recordsMap[key];
            }
         }

         if (this._tree.contains(pId)) {
            var childs = this._tree.get(pId).childs;
            childs && childs.clear();
         }
         if (this._treeMap.contains(pId)) {
            this._treeMap.get(pId).clear();
         }

         this._refreshPkIndex();
      },
      _refreshPkIndex: function() {
         var key;
         this._pkIndex = {};
         for (var i = 0, l = this._data.length; i < l; i++) {
            key = this._data[i][this._pkColumnIndex];
            if (key !== undefined) {
               this._pkIndex[key] = i;
            }
         }
      },
      /**
       * Получить индекс записи в рекордсете по ее первичному ключу
       * @param {String} key значение ключа записи
       */
      getRecordIndexByPrimaryKey: function(key) {
         return this._pkIndex[key];
      },
      /**
       * Сбрасывает итератор датасета в начало.
       */
      rewind: function() {
         this._dataIterator = -1;
      },
      /**
       * Возвращает менялся ли набор данных
       * @return {Boolean}
       */
      isChanged: function() {
         if (this._isChanged === true) {
            return true;
         } else {
            var result = false;
            this.each(function(record) {
               if (record.isChanged()) {
                  result = true;
                  return false;
               }
            });
            return result;
         }
      },
      commit: function() {
         this._isChanged = false;
         for (var i = 0, l = this._childRecordsMap.length; i < l; i++) {
            if (this._childRecordsMap[i] !== undefined && this._childRecordsMap[i].isChanged()) {
               this._childRecordsMap[i].commit();
            }
         }
      },
      /**
       * Получает следующую запись датасета
       *
       * @return {Deprecated/Record} строка данных
       */
      next: function() {
         var l = this._data.length;
         while (++this._dataIterator < l) {
            var record = this.at(this._dataIterator);
            if (record) {
               return record;
            }
         }
         return false;
      },
      /**
       * Возвращает рекорд на нужной позиции
       * @param {Number} id
       * @returns {Deprecated/Record|undefined}
       */
      at: function(id) {
         if (this._childRecordsMap[id] === undefined) {
            var data = this._data[id];
            if (data) {
               var Record = require('Deprecated/Record');
               this._childRecordsMap[id] = new Record({
                  row: data,
                  colDef: this._columns,
                  parentRecordSet: this,
                  pkValue: this._pkColumnIndex >= 0 ? parseIdentity(data[this._pkColumnIndex]) : null
               });
            } else if (id < 0 || id >= this._data.length) {
               return undefined;
            } else {
               throw new Error("No record at index " + id);
            }
         }
         return this._childRecordsMap[id];
      },
      /**
       * Выполняет функцию f для каждой строки, при этом выполняется вызов в цикле f.apply(this, [rec, idx++])
       * где:
       *   this - это RecordSet
       *   rec - запись набора данных
       *   idx - номер строки (0 - первая строка, 1-вторая и т.д.)
       * Если функция возвращает false, то ее вызов в цикле для оставшихся строк не выполняется, т.е. обработка прекращается.
       * @param {Function} f функция которая будет выполнена для каждой строки набора данных
       */
      each: function(f) {
         this.rewind();
         var rec, idx = 0;
         while ((rec = this.next()) !== false) {
            if ((f.apply(this, [rec, idx++])) === false) {
               return;
            }
         }
      },
      /**
       * Возвращает время, затраченное на получение данных
       * @return Number
       */
      getElapsedTime: function() {
         return 0;
      },
      /**
       * Получает время начала запроса
       * @return Date
       */
      getBeginTime: function() {
         return new Date();
      },
      /**
       * Возвращает модель представления колонок набора данных
       * @return Object
       */
      getColumns: function() {
         if (isEmptyObject(this._parsedColumns || {})) {
            var parser = this.getReader().getParser();
            this._parsedColumns = parser.getParsedColumns(this._columns);
         }
         return this._parsedColumns;
      },
      /**
       * Проверяет наличие колонки в рекордсете.
       */
      hasColumn: function(columnName) {
         return columnName in this.getColumns();
      },
      /**
       * Устанавливает модель представления колонок набора данных
       * @param {Object} columns колонки
       */
      setColumns: function(columns) {
         if (Object.prototype.toString.call(columns) == "[object Object]") {
            this._columns = SerializatorSBIS.serializeCols(columns);
         } else {
            this._columns = columns;
         }
         var l = this._columns.length,
            i = 0;

         this._columnIndex = {};
         while (i < l) {
            this._columnIndex[this._columns[i].n] = i;
            i++;
         }
         this._parsedColumns = {};
      },
      /**
       * @param {Deprecated/Record} record
       * @param {Object} [options]
       * @returns {Core/Deferred|Boolean}
       */
      updateRecord: function(record, options) {
         var recKey = record.getKey(),
            self = this;

         return this.getReader().updateRecord(record, options).addCallback(function(v) {
            if (v !== null && recKey === null) {
               record.setKey(v, self._pkColumnIndex);
            }
            self._isChanged = true;
            self._notify('onRecordUpdated', record);
            return v;
         });
      },
      /**
       * Удалить запись (как из набора так и из внешнего источника)
       * @param {String} pk первичный ключ записи которую необходимо удалить
       * @return {Core/Deferred}
       */
      deleteRecord: function(pk) {
         var self = this;
         try {
            var record = self.contains(pk) ? self.getRecordByPrimaryKey(pk) : false,
               clearRecord = function(key) {
                  self.clearRecord(key);
                  self._isChanged = true;
               },
               postDelete = function() {
                  if (getType(pk) === 'array') {
                     pk.forEach(function(key) {
                        clearRecord(key);
                     });
                  } else {
                     clearRecord(pk);
                  }
                  self._notify('onRecordDeleted', pk, record);
               };
            if (getType(pk) === 'array' && pk.indexOf(null) > -1) {
               //значит есть записи, которые на БЛ фактически не созданы и нам надо их вычистить
               pk = pk.filter(function(val) {
                  return val !== null;
               });
               //если были одни null в массиве ключей, то притворимся, что пытаемся вычистить одну запись с таким ключом.
               if (!pk.length) {
                  pk = null;
               }
            }
            if (pk !== null) { //Ключ null означает, что в бизнес-логики этой записи нет, а значит, и удалять её не надо
               return this.getReader().deleteRecord(pk).addCallback(postDelete);
            }
            else {
               postDelete();
               return new Deferred().callback();
            }
         } catch (e) {
            return Deferred.fail(e);
         }
      },
      /**
       * Удалить записи (как из набора так и из внешнего источника)
       * @param {array} pkArr массив первичных ключей записей, которые необходимо удалить
       * @return {Core/Deferred}
       */
      deleteRecords: function(pkArr) {
         var deleteReady = new ParallelDeferred();
         for (var i = 0, len = pkArr.length; i < len; ++i) {
            deleteReady.push(this.deleteRecord(pkArr[i]));
         }
         return deleteReady.done().getResult();
      },
      deleteRecordsByFilter: function(filter, methodName) {
         var self = this;
         return this.getReader().deleteRecordsByFilter(filter, methodName).addCallback(function() {
            self.clear();
            self._isChanged = true;
            self._notify('onRecordDeleted', null, []);
         });
      },
      /**
       * Удаляет ключ из индекса, частично его перестраивая
       * @param {*} pk ключ записи, которую удаляем из индекса
       * @private
       */
      _removeKeyFromIndex: function(pk) {
         var dataPos = this._pkIndex[pk];
         delete this._pkIndex[pk];
         for (var i in this._pkIndex) {
            if (this._pkIndex.hasOwnProperty(i) && this._pkIndex[i] > dataPos) {
               this._pkIndex[i]--;
            }
         }
      },
      /**
       * Возвращает общее количество записей
       *
       * @return {number} количество записей
       */
      getRecordCount: function() {
         var result = 0;
         for (var i = this._data.length - 1; i >= 0; --i) {
            if (this._data[i]) {
               ++result;
            }
         }
         return result;
      },
      /**
       * Получить последнюю ошибку
       * @return {Object} ошибка
       */
      getLastError: function() {
         return this._lastError;
      },
      /**
       * Получает запись по ее первичному ключу
       * @param {Number} primaryKey Первичный ключ записи
       * @returns {Deprecated/Record}
       */
      getRecordByPrimaryKey: function(primaryKey) {
         if (primaryKey in this._pkIndex) {
            return this.at(this._pkIndex[primaryKey]);
         }
         throw new Error("Record with primary key " + primaryKey + " is not found");
      },
      /**
       * Добавляет новое значение первичного ключа в массив _pkIndex
       * @param {Number} pkValue значение первичного ключа
       */
      addPkIndex: function(pkValue) {
         this._pkIndex[pkValue] = this._data.length - 1;
      },
      /**
       * Возвращает номер колонки с первичным ключом
       * @returns {Number}
       */
      getPkColumnIndex: function() {
         return this._pkColumnIndex;
      },
      getColumnIdx: function(columnName) {
         if(columnName in this._columnIndex)
            return this._columnIndex[columnName];
         else
            throw new TypeError("Column " + columnName + " is not defined");
      },
      getDataForSerialize: function(){
         var data = cloneArray(this._data);
         for (var i = 0, l = this._childRecordsMap.length; i < l; i++) {
            if (this._childRecordsMap[i] !== undefined) {
               data[i] = this._childRecordsMap[i].toJSON().d;
            }
         }
         return data;
      },
      /**
       * Метод получения колонок, пришедших с БЛ.
       * !Использование метода крайне не рекомендуется.
       * @returns {Object|*} Возвращает колонки в формате сериализации, заложенном при конструировании рекордсета.
       * Формат сериализации может меняться со временем - использование данного метода крайне не рекомендуется.
       * @example
       * Создать запись по формату рекордсета без привязки к нему
       * <pre>
       *     var columns = rs.getColumnsForSerialize(),
       *         data = [],
       *         record;
       *     for(var i = 0, l = columns.length; i < l; i++){
    *        //Здесь нужно учесть тип колонки и, возможно, проставить какое-то более подходящее значение
    *        data.push(null);
    *     }
       *     record = new Record({
    *        colDef: columns,
    *        row: data,
    *        pkValue: null,
    *        parentRecordSet: null
    *     })
       * </pre>
       */
      getColumnsForSerialize: function() {
         return this._columns;
      },
      /**
       * Прерывает загрузку рекордсета
       * @param {boolean} clearStack - очистить очередь загрузки
       */
      abort: function(clearStack) {
         this.getReader().abort();
         //Этот код был написан Владом Яковлевым
         if (clearStack) {
            this._queryStack.length = 0;
            this._loaded = true;
            this._loadingInfo = undefined;
         }
         this._notify('onAbort');
      },
      /**
       * Есть ли запись с указанным ключом
       * @param {Number} pkValue ключ
       * @returns {Boolean} наличие записи
       */
      contains: function(pkValue) {
         return this._pkIndex[pkValue] !== undefined;
      },
      /**
       * Загружает нужный узел (для иерархии)
       * @param {Number|Array}   id             идентификатор нужного узла или массив с ними ('Выборка')
       * @param {Boolean}        [clear]        очищать ли рекордсет
       * @param {Boolean}        [pageNum]      грузить ли следующую страницу или 0
       * @param {Boolean}        [expand]       загружать ли с разворотом
       * @param {Boolean}        [shadowed]     скрытый ли запрос
       * @param {Object}         [options]      опции запроса. придут в событии onAfterLoad
       * @param {Boolean}        [saveFilter]   сохранять параметры фильтра
       * @param {Boolean}        [queuedLoad]   Принудительное использование очереди запросов
       * @returns {Core/Deferred} Сработает с массивом записей и опциями (параметр options этого метода)
       */
      loadNode: function(id, clear, pageNum, expand, shadowed, options, saveFilter, queuedLoad) {
         if (this._options.hierarchyField) {
            if (!saveFilter) {
               this._options.filterParams[this._options.hierarchyField] = id;
            }
         }
         var filter = this._prepareFilter(this._options.filterParams);
         //      clear = clear === undefined ? true: clear;
         this._pageNum = (pageNum ? pageNum : 0);
         this._notify('onPageChange', this._pageNum);
         if (this._options.hierarchyField) {
            filter['Разворот'] = expand ? 'С разворотом' : 'Без разворота';
         }
         filter['shadowed'] = shadowed;
         var info = this._createLoadingInfo(options);
         this._beginLoad(filter, clear, info, queuedLoad);
         return info.deferred;
      },
      /**
       * Установит нужный раздел иерархии, чтобы рекордсет считал загруженным его
       * Не приводит к загрузке данных
       * @param {Number|Array}   id             идентификатор нужного узла
       */
      setCurrentNode: function(id) {
         var hierField = this._options.hierarchyField;
         if (hierField) {
            this._options.filterParams[hierField] = id;
         }
      },
      /**
       * Возвращает последний загруженный id
       * @returns {Number} идентификатор
       */
      getLoadingId: function() {
         if (this._loadingId instanceof Array && this._loadingId.length === 1) {
            return this._loadingId[0];
         }
         return this._loadingId;
      },
      /**
       * Возвращает "глубину" какой-либо записи по её идентификатору
       * @param {Number} id идентификатор записи
       * @returns {Number|undefined} если запись есть, то возвращается её глубина, иначе - undefined
       */
      getRecordLevel: function(id) {
         return this._level[id];
      },
      /**
       * Возвращает поле иерархии
       * @returns {String} field
       */
      getHierarchyField: function() {
         return this._options.hierarchyField;
      },
      /**
       * Устанавливает поле иерархии и перестраивает данные
       * @param {String} field Поле, в котором находится иерархия
       */
      setHierarchyField: function(field) {
         if (this._options.hierarchyField !== field) {
            this._options.hierarchyField = field;
            if (field) {
               this._buildHierarchyData(this._data);
            }
         }
      },
      _importRecord: function(record, usePkColumn) {
         var badColumns = false,
            recordColumns = record.getColumns(),
            rsColumns = this.getColumns(),
            rsColumnsList = [],
            systemColumn = recordColumns.indexOf("ctid"),
            columnDefinition, columnName, rsColumn, cnt;
         for (var col in rsColumns) {
            if (rsColumns.hasOwnProperty(col)) {
               rsColumnsList[rsColumns[col].index] = col;
            }
         }
         if (systemColumn !== -1) {
            recordColumns.splice(systemColumn, 1);
         }
         cnt = recordColumns.length;
         if (rsColumnsList.length === cnt) {
            for (var k = 0; k < cnt; k++) {
               columnName = recordColumns[k];
               rsColumn = rsColumns[columnName];
               columnDefinition = record.getColumnDefinition(columnName);
               if (!rsColumn || rsColumn.type !== columnDefinition.type || rsColumn.index !== columnDefinition.index) {
                  badColumns = true;
                  break;
               }
            }
         } else {
            badColumns = true;
         }
         record.setRecordSet(this, true);
         var key = record.getKey(usePkColumn ? this._pkColumnIndex : undefined);
         if (!key && key !== 0) {
            record.setKey(++this._maxKey, this._pkColumnIndex);
         }
         if (badColumns === true) {
            throw new TypeError('RecordSet:appendRecord - ' + rk('передана запись формата, отличного от формата набора данных. Возможны проблемы в работе с этим набором записей'));
         }
      },
      /**
       * Добавляет в рекордсет новый рекорд, собранный из переданных данных
       * @param {Object|Deprecated/Record} data хэш-мэп поле-значение для нового рекорда или настоящий Record, окоторый будет добавлен по ссылке
       * @param {boolean} [noConfirm]  Если true, то не будет стрелять onAfterLoad (нужно для добавления сразу нескольких записей)
       * @param {boolean} [noBuildHierarchy]  Если true, то не будет строиться иерархия (нужно при множественном appendRecord)
       * @param {boolean} [usePkColumn]  Если true, то будет использоваться поле ПК рекордсета для получения значения ПК записи
       * @returns {Deprecated/Record} добавленный рекорд
       */
      appendRecord: function(data, noConfirm, noBuildHierarchy, usePkColumn) {
         var columns = this._columns,
            colDef = {},
            colType,
            row = [],
            len = columns.length,
            record,
            newRecordIdx = this._data.length,
            Record = require('Deprecated/Record');

         if (data instanceof Record) {
            record = data;
            this._importRecord(record, usePkColumn);
            row = record.getDataRow();
            // чтобы не создавать запись лишний раз запомним ее как дочернюю для этого рекордсета
            this._childRecordsMap[newRecordIdx] = record;
         } else {
            ioc.resolve('ILogger').log("RecordSet:appendRecord", "Deprecated call of method with arguments type Object. Use Deprecated/Record");
            row = [];
            for (var i = 0; i < len; i++) {
               colDef = columns[i];
               colType = typeof(colDef.t) == 'string' ? colDef.t : colDef.t.n;
               if (colDef.n in data) {
                  row.push(this._importValueForSet(data[colDef.n], colType));
               } else {
                  row.push(null);
               }
            }
            record = new Record({
               colDef: columns,
               row: row,
               pkValue: parseIdentity(row[this._pkColumnIndex]),
               parentRecordSet: this
            });
         }

         this._pkIndex[record.getKey()] = newRecordIdx;

         if (record.getKey() !== null && this._options.hierarchyField !== '') {
            // TODO проверить этот код при построении иерархического RecordSet
            var parentId = record.get(this._options.hierarchyField),
               parentLevel = this._level[parentId];
            this._level[record.getKey()] = parentLevel ? parentLevel + 1 : 1;

            /*
             * Заполняем массив _newData текущими значениями this._data
             * для того, чтобы привести результат добавления аналогично
             * результату ридера
             */
            this._newData = cloneArray(this._data);
            this._newData.push(row);
            this._onComplete({}, true, undefined, undefined, noConfirm, noBuildHierarchy);
         }
         else {
            this._data.push(row);
            if (!noConfirm) {
               this._notify('onAfterLoad', this, true);
            }
         }
         // возвращаем именно ту запись, которую вставили
         return record;
      },
      /**
       * Добавить массив записей в RecordSet
       * @param {Array} records - массив записей, которые нужно добавить в рекордсет
       * @param {Boolean} noNotify - принудительно не стрелять onAfterLoad по завершению метода
       * @param {Boolean} [noBuildHierarchy] - флаг для отключения построения иерархии в конце метода. Если возводим флаг -
       * не забываем дергать и buildHierarchy()
       */
      appendRecords: function( records, noNotify, noBuildHierarchy) {
         for (var i = 0, len = records.length; i < len; i++) {
            //Разрешаем стрелять onAfterLoad только при добавлении последней записи или noNotify вообще
            this.appendRecord(records[i], noNotify || (i < len -1), !!noBuildHierarchy);
         }
         if (!noBuildHierarchy && this._options.hierarchyField) {
            this._buildHierarchyData(this._data);
         }
      },
      /**
       * Принудительное построение иерархии. Должно дергаться только после нескольких итераций с appendRecords с флагом noBuildHierarchy
       * Дергать только когда сознательно вызываем appendRecords много раз.
       */
      buildHierarchy: function() {
         if (this._options.hierarchyField) {
            this._buildHierarchyData(this._data);
         }
      },
      /**
       * TODO : ИСПОЛЬЗОВАТЬ ТОЛЬКО ПРИ СТРОГОЙ НЕОБХОДИМОСТИ!!!
       *
       * Добавляет в рекордсет новый рекорд в позицию после указанной
       * @param {Number} pk значение первичного ключа записи, после которой будет вставлена новая
       * @param record {Deprecated/Record} вставляемый рекорд
       * @param {boolean} [noNotify] флаг для запрета нотификации события onAfterLoad
       * @return {Deprecated/Record}
       */
      insertAfter: function(pk, record, noNotify) {
         var pos = this.contains(pk) ? (this._pkIndex[pk] + 1) : 0,
            key = record.getKey(),
            row = [],
            Record = require('Deprecated/Record');

         if (record instanceof Record) {
            row = record.getDataRow();
         } else {
            throw new Error(rk("Не передана запись для вставки в набор данных!"));
         }
         this._data.splice(pos, 0, row);
         for (var j = this._childRecordsMap.length; j >= pos; j--) {
            if (this._childRecordsMap[j] !== undefined) {
               this._childRecordsMap[j + 1] = this._childRecordsMap[j];
            }
         }
         this._childRecordsMap[pos] = record;
         for (var i in this._pkIndex) {
            if (this._pkIndex.hasOwnProperty(i) && this._pkIndex[i] >= pos) {
               ++this._pkIndex[i];
            }
         }
         this._pkIndex[key] = pos;
         record.setRecordSet(this, true);
         if (this._options.hierarchyField) {
            var parentField = this._options.hierarchyField,
               parent = record.get(parentField),
               hashMap;
            if (this._treeMap.contains(parent)) {
               hashMap = this._treeMap.get(parent);
            }
            else {
               hashMap = new OrderedHashMap();
               this._treeMap.put(parent, hashMap);
            }
            var after = pk,
               afterRecord;
            while (this.contains(after) && (afterRecord = this.getRecordByPrimaryKey(after)) && afterRecord.get(parentField) != parent) {
               after = afterRecord.get(parentField);
            }
            if (!this.contains(after)) {
               after = undefined;
            }
            hashMap.insert(key, {
               record: row,
               childs: new OrderedHashMap()
            }, after);
         }
         if (!noNotify) {
            this._notify('onAfterLoad', this, true);
         }
         return record;
      },
      _importValueForSet: function(value, type) {
         var Record = require('Deprecated/Record');

         switch (type) {
            case RecordTypes.FIELD_TYPE_DATE:
            case RecordTypes.FIELD_TYPE_DATETIME:
            case RecordTypes.FIELD_TYPE_TIME:
               var serializeMode;
               switch (type) {
                  case "Дата и время":
                     serializeMode = true;
                     break;
                  case "Время":
                     serializeMode = false;
                     break;
               }
               return value instanceof Date ? value.toSQL(serializeMode) : null;
            case RecordTypes.FIELD_TYPE_INTEGER:
               return (typeof(value) == 'number') ? value : (isNaN(parseInt(value, 10)) ? null : parseInt(value, 10));
            case RecordTypes.FIELD_TYPE_IDENTITY:
               return SerializatorSBIS.serializeHierarchyIdentity(value);
            case RecordTypes.FIELD_TYPE_ENUM:
               var eV = value.getCurrentValue();
               return eV === null ? null : parseInt(eV, 10);
            case RecordTypes.FIELD_TYPE_FLAGS:
               if (value instanceof Record) {
                  var s = {},
                     t = value.getColumns(),
                     dt = [];
                  for (var x = 0, l = t.length; x < l; x++) {
                     s[value.getColumnIdx(t[x])] = t[x];
                  }
                  var sorted = sortedPairs(s),
                     rO = value.toObject();
                  for (var y = 0, ly = sorted.keys.length; y < ly; y++) {
                     dt.push(rO[sorted.values[y]]);
                  }
                  return dt;
               } else if (value instanceof Array) {
                  return value;
               } else {
                  return null;
               }
            case RecordTypes.FIELD_TYPE_RECORD:
            case RecordTypes.FIELD_TYPE_QUERY:
               if (value === null) {
                  return null;
               } else if (value instanceof Record || value instanceof RecordSet) {
                  return value.toJSON();
               } else {
                  return SerializatorSBIS.serialize(value);
               }
            case RecordTypes.FIELD_TYPE_STRING:
               return value === null ? null : value + "";
            case RecordTypes.FIELD_TYPE_LINK:
               return value === null ? null : parseInt(value, 10);
            case RecordTypes.FIELD_TYPE_TIME_INTERVAL:
               if (value instanceof TimeInterval) {
                  return value.toString();
               } else {
                  return TimeInterval.toString(value);
               }
            default:
               return value;
         }
      },
      /**
       * Проверяет наличие записей на текущей странице, если их нет, переходит назад
       */
      updatePages: function() {
         var recordsCount = 0;
         for (var i = 0, len = this._data.length; i < len; ++i) {
            if (this._data[i]) {
               ++recordsCount;
            }
         }

         var result;
         if (recordsCount === 0 && this._pageNum > 0) {
            result = this.setPage(this._pageNum - 1, true, true);
         } else {
            result = (new Deferred()).callback();
         }
         return result;
      },
      moveRecord: function(parent, key, isUp) {
         var childs = this._treeMap.get(parent),
            swapedChilds = [],
            newChilds = [[], []],
            state = 0, m;
         if (childs) {
            var prev,
               swap = function(key0, key1) {
                  swapedChilds.push([key0, childs.get(key0)]);
                  swapedChilds.push([key1, childs.get(key1)]);
               };
            childs.each(function(i, v) {
               if (isUp) {
                  if (state === 0 && i == key && prev !== undefined) {
                     newChilds[0].pop();
                     swap(i, prev);
                     ++state;
                  }
                  else {
                     newChilds[state].push([i, v]);
                  }
                  prev = i;
               }
               else {
                  if (i == key) {
                     prev = i;
                  }
                  else if (state === 0 && prev !== undefined) {
                     swap(i, prev);
                     ++state;
                  }
                  else {
                     newChilds[state].push([i, v]);
                  }
               }
            });
            this._treeMap.put(parent, new OrderedHashMap());
            for (var c = 0; c < 2; ++c) {
               for (var j = 0, len = newChilds[c].length; j < len; ++j) {
                  m = this._treeMap.get(parent);
                  m.put.apply(m, newChilds[c][j]);
               }
               if (c === 0) {
                  for (var h = 0; h < 2; ++h) {
                     m = this._treeMap.get(parent);
                     m.put.apply(m, swapedChilds[h]);
                  }
               }
            }
         }
      },
      /**
       * Проверяет, является ли эта колонка иерархической
       * @param {String} hierColumn
       * @returns {Boolean}
       */
      checkHierColumn: function(hierColumn) {
         if (this._loadingId !== undefined) { //Ещё ничего не загружали, знать не можем
            var idx = this._columnIndex[hierColumn];
            if (idx === undefined) {
               return false;
            }
            return this._columns[idx].s && this._columns[idx].s === "Иерархия";
         }
         return true;
      },
      /**
       * Обновляет параметр в исходном фильтре. Использовать при строгой необходимости
       * @param {String} key Ключ
       * @param {String} value Значение
       */
      updateInitialParameter: function(key, value) {
         this._options.filterParams[key] = this._initialFilter[key] = value;
      },
      /**
       * Загружен ли сейчас рекордсет или производится загрузка данных
       * @return {Boolean}
       */
      isLoaded: function() {
         return this._loaded;
      },
      /**
       * Возвращает дочерние узлы записи с указанным идентификатором
       * @param {String} key Ключ записи
       * @return {Array}
       */
      recordChilds: function(key) {
         var result = [],
            childs = this._treeMap.get(key);
         if (childs) {
            childs.each(function(key) {
               result.push(key);
            });
         }
         return result;
      },
      /**
       * Добавляет колонку в набор записей
       * @param {String} name Имя добавляемой колонки
       * @param {String} type Тип добавляемой колонки
       * @param {String|Object} details Детализация структуры для типов: флаги, перечисляемое, массив и связь
       * Для флагов и перечисляемого описывается их структура, для связи - имя связанной таблицы, а для массива тип его элементов
       * @return {Boolean} добавлена ли колонка
       */
      addColumn: function(name, type, details) {
         if (!(name in this._columnIndex)) {
            var j, cnt;
            var config = SerializatorSBIS.getColumnConfigByType(name, type, details);
            if (config !== false) {
               var i, l;
               // Добавляем колонку в массив колонок
               config.cols.forEach(function(col){
                  this._columnIndex[col.n] = this._columns.length;
                  this._columns.push(col);
               }, this);
               // добавляем колонку в данные
               for (j = 0, cnt = this._data.length; j < cnt; j++) {
                  if (this._childRecordsMap[j] !== undefined) {
                     // Если для данного индекса уже создавался Record - вызовем метод добавления на нем
                     this._childRecordsMap[j].addColumn(name, type, details, config);
                  } else {
                     // Иначе пропишем колонку непосредстивенно в данные
                     for (i = 0, l = config.cols.length; i < l; i++) {
                        if (this._data[j] !== undefined) {
                           this._data[j].push(config.data[i]);
                        }
                     }
                  }
               }
               this._parsedColumns = {};
               return true;
            }
         }
         return false;
      },
      /**
       * Удаляет колонку из набора записей
       * @param {String} name Имя удаляемой колонки
       * @return {Boolean} удалена ли колонка
       */
      removeColumn: function(name) {
         if (name in this._columnIndex) {
            var idx = this.getColumnIdx(name),
               j, cnt;
            for (var colName in this._columnIndex) {
               if (this._columnIndex.hasOwnProperty(colName) && this._columnIndex[colName] > idx) {
                  this._columnIndex[colName]--;
               }
            }
            delete this._columnIndex[name];
            for (j = 0, cnt = this._data.length; j < cnt; j++) {
               if (this._data[j] !== undefined) {
                  this._data[j].splice(idx, 1);
               }
            }
            this._columns.splice(idx, 1);
            for (j = 0, cnt = this._childRecordsMap.length; j < cnt; j++) {
               if (this._childRecordsMap[j] !== undefined) {
                  this._childRecordsMap[j].removeColumn(name, true);
               }
            }
            this._parsedColumns = {};
            return true;
         } else {
            return false;
         }
      },
      /**
       * Возвращает массив идентификаторов записей, у которых нет родительских записей в данный момент
       * @returns {Array}
       */
      getLoadedRoots: function() {
         var res = [];
         this._tree.each(function(key) {
            res.push(key);
         });
         return res;
      }
   });

   function getRsIdx(id) {
      var idx = parseInt(id, 10);
      if (isNaN(idx)) {
         idx = -1;
      }
      return idx;
   }

   var RecordSetFieldType = {
      name: 'RecordSetFieldType',
      is: function(value) {
         return value instanceof RecordSet;
      },
      //Встроенный record отдаёт значения только по одному уровню
      get: function(value, keyPath) {
         var
            NonExistentValue = Context.NonExistentValue,
            recordSet = value,
            count = recordSet.getRecordCount(),
            idx, result, subValue, key, subType;

         if (keyPath.length !== 0) {
            key = keyPath[0];
            idx = getRsIdx(key);

            if (idx >= 0 && idx < count) {//at
               subValue = recordSet.at(idx);
               subType = Context.getValueType(subValue);
               result = subType.get(subValue, keyPath.slice(1));
            } else {
               result = NonExistentValue;
            }
         } else {
            result = value;
         }

         return result;
      },
      setWillChange: function(oldValue, keyPath, value) {
         var
            recordSet = oldValue,
            count = recordSet.getRecordCount(),
            result, idx, subValue, key, subType;

         if (keyPath.length !== 0) {
            key = keyPath[0];
            idx = getRsIdx(key);

            result = keyPath.length > 1 && idx >= 0 && idx < count;

            if (result) { //TODO: а удаление/переустановка записи как (keyPath.length === 1) ???
               subValue = recordSet.at(idx);
               subType = Context.getValueType(subValue);
               result = subType.setWillChange(subValue, keyPath.slice(1));
            }
         } else {
            result = oldValue !== value;
         }

         return result;
      },
      set: function(oldValue, keyPath, value) {
         var
            recordSet = oldValue,
            count = recordSet.getRecordCount(),
            result, changed, idx, subValue, key, subType;

         if (keyPath.length !== 0) {
            key = keyPath[0];
            idx = getRsIdx(key);

            changed = idx >= 0 && idx < count;
            if (changed) {
               if (keyPath.length !== 1) { //TODO: а удаление/переустановка записи как (keyPath.length === 1) ???
                  subValue = recordSet.at(idx);
                  subType = Context.getValueType(subValue);
                  subType.set(subValue, keyPath.slice(1), value);
               }
            }
            result = oldValue;
         } else {
            result = value;
         }

         return result;
      },
      remove: function(oldValue, keyPath) {
         var
            changed,
            recordSet = oldValue,
            count = recordSet.getRecordCount(),
            idx, subValue, key, subType;

         changed = keyPath.length !== 0;
         if (changed) {
            key = keyPath[0];
            idx = getRsIdx(key);

            changed = keyPath.length > 1 && idx >= 0 && idx < count;//TODO: а удаление/переустановка записи как (keyPath.length === 1) ???
            if (changed) {
               subValue = recordSet.at(idx);
               subType = Context.getValueType(subValue);
               changed = subType.remove(subValue, keyPath.slice(1)).changed;
            }
         }

         return {
            value: oldValue,
            changed: changed
         };
      },
      toJSON: function(value, deep) {
         return deep ? value.toJSON() : value;
      },
      subscribe: function(value, fn) {
         function sub(event) {
            value.subscribe(event, fn);
         }

         function unsub(event) {
            value.unsubscribe(event, fn);
         }

         sub('onRecordUpdated');
         sub('onRecordDeleted');
         sub('onPageChange');
         sub('onAfterLoad');
         sub('onShadowLoad');

         return function() {
            unsub('onRecordUpdated');
            unsub('onRecordDeleted');
            unsub('onPageChange');
            unsub('onAfterLoad');
            unsub('onShadowLoad');
         };
      }
   };

   Context.registerFieldType(RecordSetFieldType);

   return RecordSet;
});
