define('Deprecated/ReaderSBIS', [
   'Deprecated/ReaderAbstract',
   'Deprecated/RecordTypes',
   'Deprecated/SerializatorSBIS',
   'Deprecated/Enum',
   'Deprecated/helpers/String/parseComplexKey'
], function(ReaderAbstract, RecordTypes, SerializatorSBIS, Enum, parseComplexKey) {
   var ReaderSBIS;

   /**
    * Класс-читатель формата "Выборка СБиС"
    *
    * @class Deprecated/ReaderSBIS
    * @extends Deprecated/ReaderAbstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   ReaderSBIS = ReaderAbstract.extend(/** @lends Deprecated/ReaderSBIS.prototype */{
      $protected: {
         _pkColumnName: 'pk',
         _options: {
            parserType: 'ParserSBIS',
            /**
             * @cfg{String} Связанный объект выборки
             */
            linkedObject: '',
            /**
             * @cfg {String} Имя первичного ключа
             */
            pkName: 'id'
         }
      },
      $constructor: function() {
         this._publish('onNewData');
         this.getParser().subscribe('onDataParsed', this._onDataParsed.bind(this));
      },
      /**
       * Извлекает простой ключ (числовой) из (возможно) переданного сложного вида ID,Object
       * @param {String|Number} key
       * @returns {Number}
       */
      _extractPlainKey: function(key) {
         var parsedKey = parseComplexKey(key).objKey;
         var keyAsNumber = Number(parsedKey);
         return isNaN(keyAsNumber) ? key : keyAsNumber;
      },
      _extractObjectName: function(key) {
         return parseComplexKey(key).objName;
      },
      /**
       * Делает из объекта фильтр вида {d[] s[]}, чтобы можно было хорошо отдать БЛ
       * @param filter
       * @return {*}
       */
      prepareFilter: function(filter){
         var retval = { d: [], s: [] };
         if(filter && filter instanceof Object) {
            var keys = Object.keys(filter).sort();
            for(var i, j = 0; j < keys.length; ++j) {
               i = keys[j];
               if(i == 'pageNum' || i == 'pageCount' || i == 'usePages' || i == 'sorting'){
                  continue;
               }
               if(filter.hasOwnProperty(i) && filter[i] !== undefined) {
                  var serialized = ReaderSBIS.serializeParameter(i, filter[i]);
                  if(filter[i] instanceof Object && filter[i].hasOwnProperty('hierarchy')){
                     retval.d = retval.d.concat(serialized.d);
                     retval.s = retval.s.concat(serialized.s);
                  }else{
                     retval.d.push(serialized.d);
                     retval.s.push({ 'n': i, 't': serialized.s });
                  }
               }
            }
         }
         return retval;
      },
      _prepareSorting: function(filter) {
         if (!filter || filter['sorting'] === undefined) {
            return null;
         }
         var result = {
            s: [
               {'n': 'n', 't': 'Строка'},
               {'n': 'o', 't': 'Логическое'},
               {'n': 'l', 't': 'Логическое'}
            ],
            d: []
         };
         for (var len = filter['sorting'].length, i = 0; i < len; ++i) {
            result.d.push([filter['sorting'][i][0], filter['sorting'][i][1], !filter['sorting'][i][1]]);
         }
         return result;
      },
      _prepareNavigation: function(filter) {
         if (!filter || filter['pageNum'] === undefined || filter['pageCount'] === undefined || !filter['usePages']) {
            return null;
         }

         // Костыль. Повторяется только на интерфейсе у клиента, откуда там null понять не удалось.
         // Уходит навигация со страницей, но с размером страницы null, делаю защиту.
         // https://online.sbis.ru/opendoc.html?guid=7026cf69-265c-4ff5-b48e-6823d0d375e7
         var pageCount = filter['pageCount'] === null ? 0 : filter['pageCount'];
         return {
            s: [
               {'n': 'Страница', 't': 'Число целое'}, {'n': 'РазмерСтраницы', 't': 'Число целое'},
               {'n': 'ЕстьЕще', 't': 'Логическое'}],
            d: [filter['pageNum'], pageCount, filter['usePages'] == 'parts' || filter['usePages'] == 'auto']
         };
      },
      _makeArgsForQuery: function(filter) {
         return {
            "ДопПоля": [],
            "Фильтр": this.prepareFilter(filter),
            "Сортировка": this._prepareSorting(filter),
            "Навигация": this._prepareNavigation(filter)
         };
      },
      _makeArgsForCreate: function(filter, methodName) {

         if (methodName === undefined) {
            methodName = this._options.queryName || "null";
            if (methodName != "null") {
               methodName = this._options.dbScheme + this._options.linkedObject + '.' + methodName;
            }
         }

         return {
            "Фильтр": this.prepareFilter(filter),
            "ИмяМетода": methodName
         };
      },
      /**
       * Подготавливает хэш-мэп аргументов для операции обновления
       *
       * @param {Deprecated/Record} row Сохраняемая запись
       * @param {Object} [options] Опции
       * @param {Boolean} [options.consistencyCheck = false] Проверка целостности TODO: описать
       * @param {Boolean} [options.diffOnly = false] Сохранять только измененнные поля
       * @returns {Object}
       * @private
       */
      _makeArgsForUpdate: function(row, options) {
         var retval = {
            "Запись": SerializatorSBIS.serialize(row, options)
         };
         // TODO Выпилить в 3.7 (?) поддержку передачи boolean
         if (options && (typeof options == 'boolean' || options.consistencyCheck)) {
            retval["Проверка"] = true;
         }
         return retval;
      },
      _makeArgsForRead: function(pk, methodName, linkName) {

         if (methodName === undefined) {
            methodName = this._options.queryNameForRead || this._options.queryName || "null";
            if (methodName != "null" && methodName != "БазовоеРасширение") {
               methodName = this._options.dbScheme + this._options.linkedObject + '.' + methodName;
            }
         }

         var args = {
            'ИдО': this._extractPlainKey(pk),
            "ИмяМетода": methodName
         };

         if (linkName) {
            args['Связь'] = linkName;
         }

         return args;
      },
      _makeArgsForMergeRecords: function(mergeKey, recordKey) {
         return {
            'ИдО': this._extractPlainKey(mergeKey),
            'ИдОУд': this._preparePlainKeys(recordKey)
         };
      },
      _makeArgsForCopy: function(pk, formatMethod) {
         return {
            'ИдО': this._extractPlainKey(pk),
            'ИмяМетода': formatMethod
         };
      },
      _makeArgsForDestroy: function(pk) {
         return {'ИдО': this._preparePlainKeys(pk)};
      },
      _makeArgsForDestroyByFilter: function(filter, methodName) {
         if (methodName === undefined)
            methodName = this._options.dbScheme + this._options.linkedObject + '.' + this._options.queryName;
         return {
            "ИмяМетода": methodName,
            "Фильтр": this.prepareFilter(filter)
         };
      },
      _preparePlainKeys: function(pk) {
         if (pk instanceof Array) {
            var result = [];
            for (var i = 0, len = pk.length; i < len; i++) {
               result.push(this._extractPlainKey(pk[i]));
            }
            return result;
         }
         else
            return this._extractPlainKey(pk);
      },
      /**
       * Удаляет запись с указанным PK
       * Возвращает ошибку если от сервера вернулось не true
       *
       * @param {Number} pk
       * @returns {Core/Deferred}
       */
      deleteRecord: function(pk) {
         return ReaderSBIS.superclass.deleteRecord.apply(this, arguments).addCallback(function(result) {
            if(result !== true)
               return new Error("Запись не удалена");
            else
               return result;
         });
      },
      _onDataParsed: function(event, data){
         this._notify('onNewData', data);
      }
   });

   ReaderSBIS.serializeParameter = function(field, value) {
      var arrayType, ret = {
         d: null,
         s: null
      };

      if (value instanceof Array) {

         // Превратим все null-значения ('null', undefined, null) в настоящий null
         value = value.map(function(e) {
            return (e === 'null' || e === undefined || e === null) ? null : e;
         });

         // Выясним тип массива. Если все элементы одного типа - то его и возьмем. Если разные - то берем строку
         arrayType = value.reduce(function(lastType, e) {
            // null-значения не меняют тип
            if (e !== null) {
               var currentType = RecordTypes.FIELD_TYPE_STRING;
               if (lastType) {
                  // Все далее сравниваем с эталоном
                  if (lastType != currentType) {
                     // Если не совпало - падаем в строку
                     lastType = RecordTypes.FIELD_TYPE_STRING;
                  }
               } else {
                  // Первый элемент эталонный
                  lastType = currentType
               }
            }
            return lastType;
         }, false);

         // Если не удалось определить тип - берем TEXT
         arrayType = arrayType || RecordTypes.FIELD_TYPE_STRING;

         value = value.map(function(e) {
            if (e !== null) {
               /*switch(arrayType) {
                case Record.FIELD_TYPE_TEXT:
                return '' + e;
                case Record.FIELD_TYPE_DOUBLE:
                case Record.FIELD_TYPE_BOOLEAN:
                return e;
                case Record.FIELD_TYPE_DATETIME:
                case Record.FIELD_TYPE_DATE:
                case Record.FIELD_TYPE_TIME:
                return e.toSQL(Date.SQL_SERIALIZE_MODE_AUTO);
                }*/
               if (e instanceof Date) {
                  return e.toSQL(Date.SQL_SERIALIZE_MODE_AUTO);
               } else {
                  return '' + e;
               }
            }
            return e;
         });

         ret.s = {
            n: 'Массив',
            t: arrayType
         };
         ret.d = value;
      }
      else if (value instanceof Date) {
         ret.d = value.toSQL(null);
         ret.s = 'Строка';
      }
      else if (value instanceof Enum) {
         ret.d = value.getCurrentValue() + '';
         ret.s = 'Строка';
      }
      else if (value instanceof Object && value.hierarchy !== undefined) {
         ret.d = [
            SerializatorSBIS.serializeHierarchyIdentity(value.hierarchy[0]),
            value.hierarchy[1], null
         ];
         ret.s = [{
               n: field,
               t: 'Идентификатор',
               s: 'Иерархия'
            }, {
               n: field + '@',
               t: 'Логическое',
               s: 'Иерархия'
            }, {
               n: field + '$',
               t: 'Логическое',
               s: 'Иерархия'
            }];
      }
      else if (value instanceof Object) {
         var item;
         ret.d = {
            d: [],
            s: []
         };
         ret.s = 'Запись';
         for (var i in value) {
            if (value.hasOwnProperty(i)) {
               item = ReaderSBIS.serializeParameter(i, value[i]);
               ret.d.d.push(item.d);
               ret.d.s.push({
                  n: i,
                  t: item.s
               });
            }
         }
      }
      else if (typeof value == 'boolean') {
         ret.d = value;
         ret.s = 'Логическое';
      }
      else {
         ret.d = (value === null) ? null : ('' + value);
         ret.s = 'Строка';
      }
      return ret;
   };

   return ReaderSBIS;
});
