define('Deprecated/ReaderAbstract', [
   'require',
   'Core/Abstract',
   'Core/IoC'
], function(require, Abstract, ioc) {
   var ReaderAbstract;

   /**
    * @class Deprecated/ReaderAbstract
    * @extends Core/Abstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   ReaderAbstract = Abstract.extend(/** @lends Deprecated/ReaderAbstract.prototype*/{
      /**
       * @event onNewRecord событие, генерируемое для каждой прочитанной записи
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} data Десериализованные данные для создания записи.
       */
      /**
       * @event onParseData событие, генерируемое при парсинге данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} data Десериализованные данные для парсинга.
       */
      /**
       * @event onComplete событие, генерируемое при окончании перебора массива данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Boolean} isSuccess успешно ли завершился перебор данных
       * @param {String} [error] ошибка, почему не удалось завершить построение
       */
      /**
       * @event onSettingsParsed событие, генерируемое при окончании разбора конфигурации полей
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} columnsConfig конфигурация столбцов
       * @param {Number} pkColumnIndex номер столбца с первичным ключем
       */
      /**
       * @event onWayExists событие, сообщает о наличии пути в принятых данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} way Путь
       */
      /**
       * @event onResults событие, сообщает о наличии итогов в принятых данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} results Итоги
       */
      /**
       * @event onNextPageChange событие, сообщает о получении данных об общем числе записей / следующей странице
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} nextPage Есть ли следующая страница или общее число записей
       */
      $protected: {
         _parser : null,
         _options: {
            parserType : 'ParserAbstract',
            /**
             * @cfg {String} Тип используемого адаптера
             */
            adapterType: '',
            /**
             *  @cfg {Object} Параметры адаптера
             */
            adapterParams: {},
            subscribeOnPS: true
         },
         _nullable: {
            /**
             * @cfg {String} Имя списочного метода
             */
            format : undefined
         },
         _adapter: ''
      },
      $constructor: function(){
         var adapterType = this._options.adapterType;
         this._publish('onNewRecord', 'onParseData', 'onSettingsParsed', 'onComplete', 'onWayExists', 'onResults', 'onNextPageChange');

         if (adapterType === '')
            throw new Error("Adapter type is not specified");

      },
      getParser: function(){
         if (!this._parser) {
            var Parser = require.defined('Deprecated/' + this._options.parserType) ? require('Deprecated/' + this._options.parserType) : null;
            if (Parser) {
                this._parser = new Parser(this._getParserCfg());
            } else {
                throw new Error("Parser type is not specified");
            }
         }
         return this._parser;
      },
      _getParserCfg : function(){
         var
            self = this,
            handlers = {},
            EVENTS = ['onNewRecord', 'onParseData', 'onSettingsParsed', 'onComplete', 'onWayExists', 'onResults'];

         for (var i = 0, l = EVENTS.length; i < l; i++){
            var name = EVENTS[i];
            handlers[name] = function(e){
               arguments[0] = e._eventName;
               self._notify.apply(self, arguments);
            };
         }
         return {handlers : handlers};
      },
      /**
       * @param [method]
       * @param [args]
       * @returns {Deprecated/TransportAdapterAbstract}
       */
      getAdapter: function(method, args){
         if (this._adapter === '') {
            var Adapter = require.defined('Deprecated/' + this._options.adapterType) ?
               require('Deprecated/' + this._options.adapterType) :
               (require.defined(this._options.adapterType) ? require(this._options.adapterType) : null);

            if (Adapter) {
                this._adapter = new Adapter(this._options.adapterParams);
            } else {
                throw new Error("Adapter type is not specified");
            }
         }

         return this._adapter;
      },
      /**
       * Запускает процесс чтения данных из внешнего источника, возвращет deferred, в который придут результаты постраничного отображения
       * @param {Object} args
       * @param {Boolean} notColumnParse
       * @returns {Core/Deferred}
       */
      readRecords: function(args, notColumnParse){
         var self = this;
         return this.getAdapter().list(this._makeArgsForQuery(args))
            .addCallbacks(
            function(data){
               if (data){
                  self._notify('onNextPageChange', data.n);
                  self._onLoaderDone(data, notColumnParse);
                  return data;
               }
               else{
                  var e = new Error("Reader error : data is null");
                  self._notify('onComplete', false, e);
                  return e;
               }
            },
            function(error){
               self._notify('onComplete', false, error);
               return error;
            });
      },
      /**
       * Запускает запрос на создание новой строки в базе
       *
       * @param {Object} filter фильтр для создания новой записи
       * @param {String} methodName имя метода для получения формата
       * @return {Core/Deferred} Асинхронный результат. В нем
       * result.columns - колонки
       * result.row - строка данных
       * result.pk - значние Primary Key
       */
      createRecord: function(filter, methodName){
         var parser = this.getParser();
         return this.getAdapter()
            .create(this._makeArgsForCreate(filter,  methodName === undefined ? this._options.format : methodName))
            .addCallback(parser.readRecord.bind(parser));
      },
      /**
       * Запускает запрос на получение записи по id
       *
       * @param {Number} id идентификатор записи
       * @param {String} methodName имя метода для получения формата
       * @param {String} [linkName] имя вычитываемой связи
       * @return {Core/Deferred} Асинхронный результат. В нем
       * result.columns - колонки
       * result.row - строка данных
       * result.pk - значние Primary Key
       */
      readRecord: function(id, methodName, linkName){
         var parser = this.getParser();
         return this.getAdapter('read', arguments)
            .read(this._makeArgsForRead(id, methodName === undefined ? this._options.format : methodName, linkName))
            .addCallback(parser.readRecord.bind(parser));
      },
      /**
       * Запускает запрос на получение копии записи по id
       *
       * @param {Number|String} id идентификатор записи
       * @param {String} formatMethod Метод, определяющий формат записи для копирования
       * @return {Core/Deferred} Асинхронный результат. В нем
       * result.columns - колонки
       * result.row - строка данных
       * result.pk - значние Primary Key
       */
      copyRecord: function(id, formatMethod){
         var parser = this.getParser();
         return this.getAdapter('copy', arguments)
            .copy(this._makeArgsForCopy(id, formatMethod === undefined ? this._options.format : formatMethod))
            .addCallback(parser.readRecord.bind(parser));
      },
      /**
       * Удалить запись с указанным PK
       *
       * @param {Number|String} pk PK
       * @returns {Core/Deferred}
       */
      deleteRecord: function(pk){
         return this.getAdapter('destroy', arguments).destroy(this._makeArgsForDestroy(pk));
      },
      /**
       * Объединить записи с указанными PK
       *
       * @param {Number|String} mergeKey PK
       * @param {Number|String} recordKey PK
       * @returns {Core/Deferred}
       */
      mergeRecords: function(mergeKey, recordKey){
         return this.getAdapter('merge', arguments).merge(this._makeArgsForMergeRecords(mergeKey, recordKey));
      },
      /**
       * Обновить запись до указанных данных
       * В результрующем колбэке приходит праймари-ключ записи.
       * Ошибка извещается черезе errback
       *
       * @param {Deprecated/Record} record
       * @param {Object} [options]
       * @returns {Core/Deferred}
       */
      updateRecord: function(record, options){
         return this.getAdapter('update', arguments).update(this._makeArgsForUpdate(record, options));
      },
      deleteRecordsByFilter: function(filter, methodName){
         return this.getAdapter('destroyByFilter', arguments).destroyByFilter(this._makeArgsForDestroyByFilter(filter, methodName));
      },
      /**
       * Обработчик события успешной загрузки данных
       * @param {Object} loadedData Данные полученные от лоадера
       * @param {Boolean} notColumnParse Флаг того, что не нужно парсить колонки
       */
      _onLoaderDone: function(loadedData, notColumnParse){
         var
            success = false,
            errorMessage;
         try{
            this.getParser().parseData(loadedData, notColumnParse);
            success = true;
         } catch(e){
            errorMessage = e.message;
            ioc.resolve('ILogger').error(
               "Reader",
               "Parser (" + this._options.parserType + ") parseData ends with error: " + errorMessage,
               e);
         }
         this._notify('onComplete', success, errorMessage, loadedData.e);
      },
      parseData: function(data, notColumnParse){
         this._notify('onParseData', data);
         //if(!notColumnParse || notColumnParse === undefined)
         this._columnsParser(data);
         if(data.p)
            this._notify('onWayExists', data.p);
         if(data.r)
            this._notify('onResults', this.readRecord(data.r));
         this._dataParser(data);
      },
      _columnsParser: function(data){
         var r = this._columnsParseFnc(data);
         this._notify('onSettingsParsed', this._transformColumns(r.settings), r.pk);
      },
      _columnsParseFnc: function(data){
         throw new Error("Method AbstractReader::_columnsParseFnc must be implemented");
      },
      _dataParser: function(data){
         throw new Error("Method AbstractReader::_dataParser must be implemented");
      },
      _makeArgsForQuery: function(args) {
         return args;
      },
      _makeArgsForCreate: function(filter, methodName){
         throw new Error("Method AbstractReader::_makeArgsForCreate must be implemented");
      },
      _makeArgsForDestroyByFilter: function(filter, methodName){
         throw new Error("Method AbstractReader::_makeArgsForDestroyByFilter must be implemented");
      },
      /**
       * Подготавливает хэш-мэп аргументов для операци объединения записей
       *
       * @param {Number} mergeKey
       * @param {Number} recordKey
       * @returns {Object}
       */
      _makeArgsForMergeRecords: function(mergeKey, recordKey){
         throw new Error("Method AbstractReader::_makeArgsForMergeRecords must be implemented");
      },
      /**
       * Подготавливает хэш-мэп аргументов для операци копирования записи
       *
       * @param {Number} key
       * @returns {Object}
       */
      _makeArgsForCopy: function(key, formatMethod){
         throw new Error("Method AbstractReader::_makeArgsForCopy must be implemented");
      },
      /**
       * Подготавливает хэш-мэп аргументов для операци удаления
       *
       * @param {Number} pk
       * @returns {Object}
       */
      _makeArgsForDestroy: function(pk){
         throw new Error("Method AbstractReader::_makeArgsForDestroy must be implemented");
      },
      /**
       * Подготавливает хэш-мэп аргументов для операции обновления
       *
       * @param {Deprecated/Record} record
       * @param {Object} options
       * @returns {Object}
       */
      _makeArgsForUpdate: function(record, options){
         throw new Error("Method AbstractReader::_makeArgsForUpdate must be implemented");
      },
      _makeArgsForRead: function(pk, methodName, linkName){
         throw new Error("Method AbstractReader::_makeArgsForRead must be implemented");
      },
      /**
       * Прерывает загрузку
       */
      abort: function(){
         this.getAdapter().abort();
      }
   });

   return ReaderAbstract;
});
