define('Deprecated/ParserAbstract', [
   'require',
   'Core/Abstract',
   'Deprecated/RecordTypes',
   'Core/constants'
], function(require, Abstract, RecordTypes, _const) {
   var ParserAbstract,
      returnType = {
         RECORD: "returnRecord",
         RECORD_SET: "returnRecordSet"
      };

   /**
    * Абстрактный парсер массива данных
    * @class Deprecated/ParserAbstract
    * @extends Core/Abstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   ParserAbstract = Abstract.extend(/** @lends Deprecated/ParserAbstract.prototype */{
      /**
       * @event onNewRecord событие, генерируемое для каждой прочитанной записи
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} data Десериализованные данные для создания записи.
       */
      /**
       * @event onParseData событие, генерируемое при парсинге данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} data Десериализованные данные для парсинга.
       */
      /**
       * @event onSettingsParsed событие, генерируемое при окончании разбора конфигурации полей
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} columnsConfig конфигурация столбцов
       * @param {Number} pkColumnIndex номер столбца с первичным ключем
       */
      /**
       * @event onWayExists событие, сообщает о наличии пути в принятых данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} way Путь
       */
      /**
       * @event onResults событие, сообщает о наличии итогов в принятых данных
       * @param {Core/EventObject} eventObject описание в классе Core/Abstract
       * @param {Object} results Итоги
       */
      $protected: {
         _cols: null,
         _rows: [],
         _options: {
            subscribeOnPS: true
         }
      },
      $constructor: function() {
         this._publish("onParseData", "onWayExists", "onResults", "onSettingsParsed", "onNewRecord");
      },
      /**
       * Функция десериализации данных
       * @param {object} data
       * @param {$ws._const.returnType.RECORD | $ws._const.returnType.RECORD_SET} type - тип ожидаемых данных
       * @return {Deprecated/Record | Deprecated/RecordSet}
       */
      parse: function(data, type) {
         var
            self = this,
            Record = require('Deprecated/Record'),
            result;

         if (data === null) {
            return null;
         }

         this._rows = [];
         var
            parsedColumns = this._columnsParseFnc(data);
         this._cols = parsedColumns.settings;
         switch (type) {
            case returnType.RECORD :
               result = new Record({
                  row: data.d,
                  colDef: this._cols,
                  pkValue: data.d[parsedColumns.pk || 0]
               });
               break;
            case returnType.RECORD_SET :
               var RecordSetStatic = require('Deprecated/RecordSetStatic'),
                  row = [];
               for (var i = 0, l = data.d.length; i < l; i++) {
                  row = data.d[i];
                  this._rows.push(new Record({
                     row: row,
                     colDef: self._cols,
                     pkValue: row[parsedColumns.pk || 0]
                  }));
               }
               result = new RecordSetStatic({
                  defaultColumns: this._cols,
                  records: this._rows
               });
               break;
         }
         return result;
      },
      parseData : function(data, notColumnParse){
         this._notify('onParseData', data);
         //if(!notColumnParse || notColumnParse === undefined)
         this._columnsParser(data);
         if(data.p)
            this._notify('onWayExists', data.p);
         if(data.r)
            this._notify('onResults', this.readRecord(data.r));
         this._dataParser(data);
      },
      _columnsParser: function(data) {
         var r = this._columnsParseFnc(data);
         this._notify('onSettingsParsed', this._transformColumns(r.settings), r.pk);
      },
      _columnsParseFnc: function(data) {
         throw new Error("Method AbstractReader::_columnsParseFnc must be implemented");
      },
      _dataParser: function(data) {
         throw new Error("Method AbstractReader::_dataParser must be implemented");
      },
      _transformColumns: function(parsedCols) {
         var
            retval = {},
            l = parsedCols.length,
            colType;
         for (var i = 0; i < l; i++) {
            if (parsedCols[i].s && parsedCols[i].s == RecordTypes.FIELD_TYPE_HIERARCHY) {
               retval[parsedCols[i].n] = {
                  type: parsedCols[i].t,
                  title: parsedCols[i].n,
                  s: parsedCols[i].s,
                  index: i
               };
            } else if (typeof(parsedCols[i].t) == 'object') { // тип СБиС++ сложный
               colType = parsedCols[i].t;
               if (colType.n == RecordTypes.FIELD_TYPE_LINK) {
                  retval[parsedCols[i].n] = {
                     type: colType.n,
                     title: parsedCols[i].n,
                     table: colType.t,
                     index: i
                  };
               }
               else if (colType.n == RecordTypes.FIELD_TYPE_ARRAY) {
                  retval[parsedCols[i].n] = {
                     type: colType.n,
                     title: parsedCols[i].n,
                     arrayType: colType.t,
                     index: i
                  };
               }
               else if (colType.n == RecordTypes.FIELD_TYPE_ENUM || colType.n == RecordTypes.FIELD_TYPE_FLAGS) {
                  retval[parsedCols[i].n] = {
                     type: colType.n,
                     title: parsedCols[i].n,
                     s: colType.s,
                     index: i
                  };
               }
               else if (colType.n == RecordTypes.FIELD_TYPE_MONEY) {
                  retval[parsedCols[i].n] = {
                     type: colType.n,
                     title: parsedCols[i].n,
                     p: colType.p,
                     index: i
                  };
               }
            }
            else
               retval[parsedCols[i].n] = {
                  type: parsedCols[i].t,
                  title: parsedCols[i].n,
                  index: i
               };
         }
         return retval;
      },
      getParsedColumns: function(columns) {
         columns = this._columnsParseFnc({s: columns, d: []});
         return this._transformColumns(columns.settings);
      },
      readRecord: function(data) {
         if (data === null) {
            return null;
         }

         var
            parsedColumns = this._columnsParseFnc(data),
            parsed = parsedColumns.settings,
            pkColumnIndex = parsedColumns.pk,
            colsN = parsed.length,
            columns = [],
            row = this._dataParser(data);

         for (var i = 0; i < colsN; i++) {
            if (parsed[i].s && parsed[i].s == "Иерархия") {
               if (parsed[i].t == "Логическое") {
                  columns[i] = {
                     t: parsed[i].t,
                     n: parsed[i].n,
                     s: parsed[i].s
                  };
               } else {
                  columns[i] = {
                     t: parsed[i].t,
                     n: parsed[i].n,
                     b: parsed[i].b,
                     f: parsed[i].f,
                     s: parsed[i].s
                  };
               }
            } else if (parsed[i].t == "Связь" || parsed[i].t == "Массив") {
               columns[i] = {
                  t: parsed[i].t,
                  n: parsed[i].n,
                  s: parsed[i].s
               };
            }
            else {
               columns[i] = {
                  t: parsed[i].t,
                  n: parsed[i].n
               };
            }
         }
         var config = {
            columns: this._transformColumns(columns),
            row: row,
            pk: pkColumnIndex
         };
         if (data.objectName) {
            config.objectName = data.objectName;
         }
         return config;
      }
   });

   _const.returnType = returnType;

   return ParserAbstract;
});
