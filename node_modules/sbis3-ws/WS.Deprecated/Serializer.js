define('Deprecated/Serializer', [
   'require',
   'Core/Serializer',
   'Core/core-simpleExtend',
   'Deprecated/Record',
   'Deprecated/RecordSet'
], function(
   require,
   CoreSerializer,
   simpleExtend
) {

   /**
    * Устаревший сериалайзер - наслединк Core/Serializer, который умеет работать с deprecated Record/RecordSet.
    * @class
    * @name Deprecated/Serializer
    * @extends Core/Serializer
    * @public
    * @author Бегунов А.В.
    * @deprecated
    */
   var Serializer = simpleExtend.extend(CoreSerializer, {
      /**
       * @member {Boolean} Использовать детекцию сериализованных контейнеров данных
       */
      _detectContainers: true,

      constructor: function Serializer(storage, isServerSide) {
         Serializer.superclass.constructor.call(this, storage, isServerSide);
         this.deserialize = Serializer.deserializeWith(this);
      },

      /**
       * Использовать детекцию сериализованных контейнеров данных.
       * @param {Boolean} detect
       */
      setDetectContainers: function(detect) {
         this._detectContainers = detect;
      },

      /**
       * Используется детекция сериализованных контейнеров данных.
       * @returns {Boolean}
       */
      isDetectContainers: function() {
         return this._detectContainers;
      }
   });

   Serializer.setToJsonForFunction = CoreSerializer.setToJsonForFunction;
   Serializer.getFuncFromDeclaration = CoreSerializer.getFuncFromDeclaration;

   var fnStorage = {};

   /**
    *
    * @param self
    * @returns {Function}
    * @function
    * @name Deprecated/Serializer#deserializeWith
    */
   Serializer.deserializeWith = function(self) {
      var superDeserializeWith = CoreSerializer.deserializeWith(self);

      return function (name, value) {
         var result = superDeserializeWith.call(this, name, value);
         if (result === value) {
            //Поддержка старых форматов сериализации для совместимости
            return JSONreviver.call(fnStorage, name, value, self._detectContainers);
         } else {
            return result;
         }
      };
   };

   function JSONreviver(key, value, detectContainers) {
      if (typeof value === 'string') {
         if (beginsWith(value, 'wsFuncDecl::')) {
            return Serializer.getFuncFromDeclaration(value.replace('wsFuncDecl::', ''));
         }
         else if (beginsWith(value, 'wsGlobalFnDecl::')) {
            var
               sKey = value.replace('wsGlobalFnDecl::', ''),
               result = this[sKey];
            delete this[sKey];
            return result;
         }
         else if (beginsWith(value, 'moduleFunc#')) {
            var
               m = value.replace(/^moduleFunc#/, '').split("/"),
               fName = m.length > 1 ? m.pop() : '',
               mName = m.join('/');
            try {
               value = require(mName)[fName];
            }
            catch (e) {
               throw new Error('Parsing moduleFunc "' + value + '" failed. Original message: ' + e.message)
            }
         } else if (beginsWith(value, 'datasource!')) {
            return getDataSourceFromDeclaration(value);
         }
      } else if (detectContainers && detectCommonDataContainer(value) && value._mustRevive) {
         return commonDataContainerReviver(key, value);
      }

      return value;
   }

   function commonDataContainerReviver(key, value) {
      if (value._type === 'recordset') {
         var RecordSet = require('Deprecated/RecordSet');
         if (RecordSet) {
            return new RecordSet({
               readerParams: {
                  adapterType: 'TransportAdapterStatic',
                  adapterParams: {
                     data: {
                        d: value.d,
                        s: value.s
                     }
                  }
               }
            });
         }
      } else if (value._type === 'record') {
         var Record = require('Deprecated/Record');
         if (Record) {
            return new Record({
               row: value.d,
               colDef: value.s,
               pkValue: value._key
            });
         }
      } else {
         return value;
      }
   }

   function detectCommonDataContainer(value) {
      return value && value.s && value.d && (value._type === 'record' || value._type === 'recordset');
   }

   function getDataSourceFromDeclaration(declaration) {
      var parts = declaration.split(':'),
         result;
      try {
         result = require(parts[0]);
         if (parts[1]) {
            var data = result.contents && result.contents[parts[1]];
            result = {
               readerParams: {
                  adapterType: "TransportAdapterStatic",
                  adapterParams: {
                     data: data
                  }
               }
            }
         }
      }
      catch (e) {
         throw new Error('Parsing datasource declaration "' + declaration + '" failed. Message:' + e.message);
      }

      return result;
   }

   function beginsWith(value, s) {
      s = ('' + s);
      return value.substr(0, s.length) === s;
   }

   return Serializer;
});