define('Deprecated/RecordSetStatic', [
   'Core/core-merge',
   'require',
   'Core/Deferred',
   'Core/IoC',
   'Deprecated/RecordSet',
   'Deprecated/RecordTypes',
   'Core/helpers/getType'
], function(
   cMerge,
   require,
   Deferred,
   ioc,
   RecordSet,
   RecordTypes,
   getType
) {
   var RecordSetStatic;

   var forEach = function (obj, iterateCallback, context) {
      if (obj === null || obj === undefined || obj.length === 0)
         return;

      var i, l, key;
      if (obj instanceof Array) {
         if (obj.forEach) {
            //В Firefox-е именно здесь глючит цикл обхода - пропускает некоторые итерации
            //Заменяю forEach на родной массивский - он работает нормально
            obj.forEach(iterateCallback, context);
         } else {
            l = obj.length;
            for (i = 0; i < l; i++) {
               if (i in obj) {
                  iterateCallback.call(context, obj[i], i, obj);
               }
            }
         }
      } else if ('length' in obj && (obj.length - 1) in obj) {
         /**
          * Это место переписано так не случайно.
          * При необъяснимых обстоятельствах на iOS 8.1 старая проверка
          * (obj.length === +obj.length) для obj === { 0: ??? }
          * давала положительный результат (obj.length в момент проверки был === 1)
          * Но следующая строка при чтении obj.length уже давала как и положено `undefined`
          * Как показали опыты, переписанная нижеследующим образом проверка не багает
          */
         l = parseInt(obj.length, 10);
         for (i = 0; i < l; i++) {
            if (i in obj) {
               iterateCallback.call(context, obj[i], i, obj);
            }
         }
      } else {
         for (key in obj) {
            if (obj.hasOwnProperty(key)) {
               iterateCallback.call(context, obj[key], key, obj);
            }
         }
      }
   };
   var map = function (obj, iterateCallback, context) {
      var results = [];
      if (obj === null || obj === undefined)
         return results;
      //todo: обработать jqueryObj
      forEach(obj, function (value, index, list) {
         results[results.length] = iterateCallback.call(context, value, index, list);
      }, context);
      if ('length' in obj && (obj.length - 1) in obj) {//если на входе массив - подгоним длину
         /**
          * В ios8 есть баг объект с числовыми ключами может содержать length
          * https://bugs.webkit.org/show_bug.cgi?id=142792
          */
         results.length = obj.length;
      }
      return results;
   };


   /**
    * Класс для локальной работы с записями: ведёт себя, как RecordSet, но не требует бизнес-логики для работы.
    * Можно использовать вместе с браузером:
    * <pre>
    *    browser.setData(recordSetStatic);
    * </pre>
    * Создание статического рекордсета (если Source уже загружен):
    * <pre>
    *    var recordset = new RecordSetStatic({
 *       defaultColumns: columns,
 *       hierarchyField: 'Раздел',
 *       records: records
 *    });
    * </pre>
    * Здесь:
    * - columns: колонки. Формат такой же, как результат выполнения метода {@link getColumns} у обычного рекордсета.
    * - "Раздел": название колонки с иерархией. Если иерархии нет/не нужна, то можно не указывать или передать пустую.
    * - recods: массив с записями. Можно не передавать или передать пустой массив, а записи добавлять позже.
    * Основные способы добавления записей:
    * <pre>
    *    recordset.addRecords(records);
    *    recordset.setRecords(records);// в отличии от предыдущего, удалит существующие записи
    *    recordset.appendData([object]);
    * </pre>
    * Пример колонок:
    * <pre>
    *    var columns = {
 *       "@key": {
 *          "type": "Идентификатор",
 *          "title": "@key",
    *          "index": 0
    *       },
    *       "Название": {
 *          "type": "Строка",
 *          "title": "Название",
 *          "index": 1
 *       }
    *    };
    * </pre>
    * Можно легко создать статический рекордсет из обычного:
    * <pre>
    *    var staticRecordSet = new RecordSetStatic({
 *       defaultColumns: recordset.getColumns(),
 *       records: recordset.getRecords()
 *    });
    * </pre>
    * Статический рекордсет позволяет удалять, добавлять, редактировать и создавать записи.
    * Возможна работа с постраничной навигацией, иерархическими данными, фильтрацией.
    * Больше информации можно найти на <a href="http://inside.sbis.ru/doc/_layouts/DocIdRedir.aspx?ID=SBIS-5-1858">inside.sbis.ru</a>
    *
    * @class Deprecated/RecordSetStatic
    * @extends Deprecated/RecordSet
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   RecordSetStatic = RecordSet.extend(/** @lends Deprecated/RecordSetStatic.prototype */{
      $protected: {
         _options: {
            /**
             * @cfg {Object} Разметка колонок всех записей
             */
            defaultColumns: {},        //Дефолтное значение для colDef записи
            /**
             * @cfg {Array} Массив с Deprecated/Record - начальные данные
             */
            records: [],               //Массив с записями - начальные данные
            /**
             * @cfg {Function} Функция для фильтрации значений. Получит запись и текущий фильтр
             */
            filter: undefined,         //Функция фильтрации данных
            /**
             * @cfg {String} Тип итогов
             * По каким записям считать итоги.
             * @variant leaves по листьям
             * @variant folders  по узлам
             * @variant foldersAndLeaves по узлам и листьям
             */
            resultType: 'foldersAndLeaves',
            /**
             * @cfg {Function} Функция для вычисления суммы больших чисел, принимает три параметра, два слагаемых и точность.  Возвращает сумму ввиде строки.
             * @see getBigCalcSum
             * @see setBigCalcSum
             */
            bigCalcSum: undefined
         },
         _hiddenData: [],              //Скрытые данные
         _expand: false,               //Будут ли загружаемые данные раскрытыми
         _parentNode: null,             //Идентификатор отца получаемых записей
         _pocketAppending: false,      //Флаг пакетной обработки
         _typeDetailesName: {
            "Флаги": "s",
            "Перечисляемое": "s",
            "Связь":"table",
            "Массив": "arrayType"
         }
      },
      $constructor: function() {
         this._initOptions();
         this._initRecords();
         this._startLoad();
      },
      addColumn: function(name, type, details) {
         var
            colDef = {
               cols: [{
                  n: name,
                  t: type
               }],
               data: [null]
            };
         this._columns[name] = {
            'title': name,
            'type': type,
            'index': Object.keys(this._columns).length
         };
         if (!!details && this._typeDetailesName[type]) {
            this._columns[name][this._typeDetailesName[type]] = details;
            colDef[this._typeDetailesName[type]] = details;
         }
         for (var i = 0, l = this._hiddenData.length; i < l; i++) {
            this._hiddenData[i].addColumn(name, type, details, colDef);
         }
      },
      removeColumn: function(name) {
         delete this._columns[name];
         for (var i = 0, l = this._hiddenData.length; i < l; i++) {
            this._hiddenData[i].removeColumn(name);
         }
      },
      /**
       * Метод фильтрации текущих записей статического набора данных.
       * Является аналогом фильтрации через параметр filter
       * @param {Function} func функция фильтрации записей статического набора данных, на вход принимает запись {Deprecated/Record}.
       * На выходе должна вернуть true для того, чтобы запись осталась в отфильтрованном наборе.
       */
      filter: function(func) {
         var newData = [];
         this.each(function(record) {
            if (func(record)) {
               newData.push(record.getDataRow());
            }
         });
         this.setRecords(newData);
      },
      /**
       * Инициализирует опции
       * @private
       */
      _initOptions: function() {
         this._columns = this._options.defaultColumns;
         this._hiddenData = this._options.records;
      },
      /**
       * Инициализирует данные, связанные с записями
       * @private
       */
      _initRecords: function() {
         for (var i = 0; i < this._hiddenData.length; ++i) {
            if (this._hiddenData[i]) {
               this._hiddenData[i].setRecordSet(this);
               var key = this._hiddenData[i].getKey();
               this._pkIndex[key] = i;
               this._level[key] = 0;
            }
         }
      },
      /**
       * Начинает первую загрузку, если это нужно
       * @private
       */
      _startLoad: function() {
         if (this._options.firstRequest) {
            this._beginLoad();
         }
      },
      /**
       * Рекордсет всегда инициализирован
       * @return {Boolean}
       */
      isInit: function() {
         return true;
      },
      commit: function() {
         this._isChanged = false;
         for (var i = 0, l = this._hiddenData.length; i < l; i++) {
            if (this._hiddenData[i] !== undefined && this._hiddenData[i].isChanged()) {
               this._hiddenData[i].commit();
            }
         }
      },
      /**
       * Переопределяем загрузку, чтобы ничего не делал
       * @param {Object} [queryFilter] фильтр, который использовать при загрузке, либо ничего и тогда автоматический просчёт
       * @param {Boolean|undefined} [clear] очищать ли всё при загрузке
       * @param {Object} [info] Информация о текущем запросе
       */
      _beginLoad: function(queryFilter, clear, info) {
         var self = this,
            subresult = [],
            childResult = [],
            filter = this._options.filter,
            recursion = function(parentId) {
               if (parentId === null) {
                  parentId = 'null';
               }
               for (var i = 0, len = self._hiddenData.length; i < len; ++i) {
                  if (self._hiddenData[i]) {
                     var recordParent = self._hiddenData[i].get(self._options.hierarchyField);
                     if (recordParent === null) {
                        recordParent = 'null';
                     }
                     if (recordParent == parentId &&
                         (!filter || filter(self._hiddenData[i], self._options.filterParams))) {
                        var key = self._hiddenData[i].getKey();
                        self._level[key] = self._level[parentId] + 1;
                        subresult.push(self._hiddenData[i]);
                        if (self._expand) {
                           recursion(self._hiddenData[i].getKey());
                        }
                     }
                  }
               }
            };
         if (clear) {
            this._data = [];
         }
         if (this._options.hierarchyField) {
            var parentNode = this._parentNode;
            if(parentNode instanceof Array){
               this._expanded = false;
            } else {
               parentNode = [parentNode];
            }
            for (i = 0; i < parentNode.length; ++i) {
               subresult = [];
               this._level[parentNode[i]] = parentNode[i] === null ? -1 : 0;
               recursion(parentNode[i]);
               childResult = childResult.concat(subresult);
               if (parentNode[i] === null) {
                  Array.prototype.splice.apply(this._data, [0, this._data.length].concat(subresult));
               } else {
                  var found = false;
                  for (j = 0; j < this._data.length; ++j) {
                     if (this._data[j] && this._data[j].getKey() == parentNode[i]) {
                        for (var c = j + 1; c < this._data.length; ++c) {
                           if (this._data[c] && this._data[c].get(this._options.hierarchyField) == parentNode[i]) {
                              this._data.splice(c--, 1);
                           }
                        }
                        this._data.splice.apply(this._data, [j + 1, 0].concat(subresult));
                        found = true;
                        break;
                     }
                  }
                  if (!found) {
                     this._data = this._data.concat(subresult);
                  }
               }
            }
            subresult = this._data;
         }
         else {
            for (var j = 0, len2 = this._hiddenData.length; j < len2; ++j) {
               if (this._hiddenData[j] && (!filter || filter(this._hiddenData[j], this._options.filterParams))) {
                  subresult.push(this._hiddenData[j]);
               }
            }
         }

         if (this._usePages) {
            if (this._usePages === 'parts' && this._pageNum === -1) {
               this._pageNum = Math.ceil(subresult.length / this._options.rowsPerPage) - 1;
            }
            this._data = [];
            this._hasNextPage = (this._usePages === 'full' ? subresult.length :
               (subresult.length > (this._pageNum + 1) * this._options.rowsPerPage));
            for (var i = this._pageNum * this._options.rowsPerPage,
               len = Math.min(subresult.length, i + this._options.rowsPerPage); i < len; ++i) {
               this._data.push(subresult[i]);
            }
         }
         else {
            this._data = subresult;
         }

         this._notify('onAfterLoad', this, true, undefined, info && info.options);
         if (info && info.deferred && !info.deferred.isReady()) {
            info.deferred.callback(childResult || this._data);
         }
      },
      /**
       * Устанавливает функцию фильтрации
       * @param {Function} filter Функция, принимает запись и объект с фильтром
       */
      setFilter: function(filter){
         this._options.filter = filter;
      },
      /**
       * "Выполняет запрос" с указанным фильтром
       * @param {Object} filter  фильтр
       */
      setQuery: function(filter) {
         this._expand = filter['Разворот'] === 'С разворотом';
         return RecordSetStatic.superclass.setQuery.apply(this, arguments);
      },
      /**
       * Возвращает модель представления колонок набора данных
       * @return Object
       */
      getColumns: function() {
         return cMerge({}, this._options.defaultColumns);
      },
      /**
       * Перестраивает индексы в рекордсете
       * @private
       */
      _rebuild: function() {
         this._pkIndex = {};
         this._level = {};
         for (var i = 0, len = this._hiddenData.length; i < len; ++i) {
            if (i in this._hiddenData) {
               var tempId = this._hiddenData[i].getKey();
               this._level[tempId] = 0;
               this._pkIndex[tempId] = i;
            }
         }
      },
      /**
       * Устанавливает записи, после установки стреляет onAfterLoad'ом
       * @param {Array} records Массив с Deprecated/Record'ами
       */
      setRecords: function(records) {
         this._hiddenData = records;
         this._rebuild();
         this._beginLoad();
      },
      /**
       * Добавляет указанные записи у уже существующим
       * @param {Array} records Массив с новыми записями, instanceof Deprecated/Record
       */
      addRecords: function(records) {
         this._hiddenData = this._hiddenData.concat(records);
         if (this._pocketAppending === false) {
            this._rebuild();
            this._beginLoad();
         }
      },
      /**
       * Получает запись по ее первичному ключу
       * @param {Number} primaryKey Первичный ключ записи
       * @returns {Deprecated/Record}
       */
      getRecordByPrimaryKey: function(primaryKey) {
         if (primaryKey in this._pkIndex) {
            return this._hiddenData[this._pkIndex[primaryKey]];
         }
         throw new Error("Record with primary key " + primaryKey + " is not found");
      },
      /**
       * Возвращает в колбэке новую "пустую" строку "из базы", предзаполненную переданным фильтром
       * @param {Object} [filter] Фильтр
       * @returns {Core/Deferred}
       */
      createRecord: function(filter) {
         filter = filter || {};
         var result = new Deferred(),
            columns = this._columns,
            maxIndex = 0;
         for (var i = 0, len = this._hiddenData.length; i < len; ++i) {
            if (!this._hiddenData[i]) {
               continue;
            }
            var tempKey = this._hiddenData[i].getKey();
            if (maxIndex < tempKey) {
               maxIndex = tempKey;
            }
         }
         var row = [],
            hierarchy = this._options.hierarchyField;
         for (var j in columns) {
            if (columns.hasOwnProperty(j)) {
               row[columns[j].index] = null;
            }
         }
         row[this._pkColumnIndex] = 'null';
         if (hierarchy) {
            var hierarchyData = filter[hierarchy].hierarchy;
            if (hierarchyData) {
               if (hierarchyData[0] === 'null') {
                  hierarchyData[0] = null;
               }
               row[columns[hierarchy].index] = hierarchyData[0];
               row[columns[hierarchy + "@"].index] = hierarchyData[1];
               row[columns[hierarchy + "$"].index] = false;
            }
         }
         var Record = require('Deprecated/Record');
         result.callback(new Record({
            row: row,
            colDef: this._options.defaultColumns,
            parentRecordSet: this,
            pkValue: 'null'
         }));
         return result;
      },
      /**
       * Если id не задан - возвращает в колбэке новую "пустую" строку "из базы" (в рекордсет запись не вставляется)
       * иначе возвращет строку из базы по id
       * @param {String} id идентификатор запрашиваемой записи
       * @returns {Core/Deferred} асинхронное событие стреляет готовым рекордом
       */
      readRecord: function(id) {
         if (id === undefined || this._pkIndex[id] === undefined || !this._hiddenData[this._pkIndex[id]]) {
            return this.createRecord();
         }
         var result = new Deferred();
         result.callback(this._hiddenData[this._pkIndex[id]]);
         return result;
      },
      /**
       * @param {Deprecated/Record} record
       * @returns {Core/Deferred|Boolean}
       */
      updateRecord: function(record) {
         var tempKey = record.getKey(),
            result = new Deferred();

         if (tempKey === 'null') {
            var key = 0;
            Object.keys(this._pkIndex).forEach(function(curKey) {
               var intCurKey = parseInt(curKey, 10) || 0;
               if (key < intCurKey) {
                  key = intCurKey;
               }
            });
            record.setKey(tempKey = key + 1, this._pkColumnIndex);
         }

         if (this._pkIndex[tempKey] !== undefined) {
            this._hiddenData[this._pkIndex[tempKey]] = record;
         }
         else {
            this._hiddenData.push(record);
            this._pkIndex[tempKey] = this._hiddenData.length - 1;
         }
         if (this._options.hierarchyField) {
            var parentId = record.get(this._options.hierarchyField);
            this._level[tempKey] = ((parentId !== undefined && this._level[parentId]) ? (this._level[parentId] + 1) : 0);
         }
         else {
            this._level[tempKey] = 0;
         }
         this._notify('onRecordUpdated', record);

         result.callback(tempKey);

         return result;
      },
      /**
       * Ничего не делаем
       */
      addPkIndex: function() {
      },
      /**
       * Удаляет запись с указанным ключом, извещает об удалении
       * @param {String|Number} key Первичный ключ указанной записи
       * @returns {Boolean} Нашлась ли запись
       * @private
       */
      _deleteRecord: function(key) {
         var pkIndex = this._pkIndex[key],
            record, i, l, deletedRecord, keys, k;
         if (pkIndex !== undefined && pkIndex !== null) {
            deletedRecord = this._hiddenData[pkIndex];
            keys = Object.keys(this._pkIndex);
            for (i = 0, l = keys.length; i < l; i++) {
               k = keys[i];
               if (this._pkIndex[k] > pkIndex) {
                  this._pkIndex[k]--;
               }
            }
            this._hiddenData.splice(pkIndex, 1);
            delete this._level[key];
            delete this._pkIndex[key];
            for (i = 0; i < this._data.length; ++i) {
               record = this.at(i);
               if (record && record.getKey() == key) {
                  this._data.splice(i, 1);
                  break;
               }
            }
            this._isChanged = true;
            this._notify('onRecordDeleted', key + '', deletedRecord);
            return true;
         }
         return false;
      },

      /**
       * Очистка всех записей, parent которых - указанный, а также всех зависимых от них и т д
       * Возвращает массив с ключами удалённых записей
       * @param {String} pId Парент очищаемых записей
       */
      clearNode: function(pId) {
         if (this._pkIndex[pId] === undefined) {
            return [];
         }
         var arrToClear = this.recordChilds(pId);
         for (var i = 0; i < arrToClear.length; i++) {
            this._deleteRecord(arrToClear[i]);
         }
         var tempData = this._hiddenData;
         this._hiddenData = [];
         for (var j = 0, len2 = tempData.length; j < len2; ++j) {
            if (tempData[j]) {
               this._hiddenData.push(tempData[j]);
            }
         }
         this._refreshPkIndex();
         return arrToClear;
      },
      /**
       * Удалить запись (как из набора так и из внешнего источника)
       * @param {String|Number} key первичный ключ записи, которую необходимо удалить
       * @return {Core/Deferred}
       */
      deleteRecord: function(key) {
         var result = new Deferred();
         result.addErrback(function (e) {
            return e;
         });
         try {
            this._deleteRecord(key);
            result.callback(key);
         } catch (e) {
            result.errback(e);
         }
         return result;
      },
      /**
       * Удаляет массив записей с указанными ключами
       * @param {Array} keys Массив с ключами записей
       */
      deleteRecords: function(keys) {
         for (var i = 0, len = keys.length; i < len; ++i) {
            this._deleteRecord(keys[i]);
         }
      },
      /**
       * Загружает нужный узел (для иерархии)
       * @param {Number|Array}   id             идентификатор нужного узла или массив с ними ('Выборка')
       * @param {Boolean}        clear          очищать ли рекордсет
       * @param {Boolean}        pageNum        грузить ли следующую страницу или 0
       * @param {Boolean}        expand         загружать ли с разворотом
       */
      loadNode: function(id, clear, pageNum, expand, shadow, options) {
         this._parentNode = id;
         this._pageNum = (pageNum ? pageNum : 0);
         this._notify('onPageChange', this._pageNum);
         this._expand = expand;
         var info = this._createLoadingInfo(options);
         this._beginLoad(undefined, clear, info);
         return info.deferred;
      },
      /**
       * Возвращает общее число записей
       * @returns {Number}
       */
      hasNextPage: function() {
         var self = this,
            getFullCount = function() {
               var result = 0,
                  filter = self._options.filter;
               for (var i = 0, len = self._hiddenData.length; i < len; ++i) {
                  if (self._hiddenData[i] && (!filter || filter(self._hiddenData[i], self._options.filterParams))) {
                     ++result;
                  }
               }
               return result;
            };
         if (this._usePages === 'parts') {
            return getFullCount() > (this._pageNum + 1) * this._options.rowsPerPage;
         }
         return getFullCount();
      },
      /**
       * Возвращает количество записей с учётом фильтрации
       * @returns {Number}
       */
      getRecordCount: function() {
         return this._data.length;
      },
      /**
       * Создаёт запись из данных
       * @param {Object} rowData Набор данных вида ключ-значение
       * @param {Number} index Номер добавляемой записи
       * @return {Deprecated/Record}
       * @private
       */
      _recordFromData: function(rowData, index) {
         var columns = this._columns,
            row = [];
         for (var i in columns) {
            if (columns.hasOwnProperty(i)) {
               var value;
               if (i in rowData) {
                  value = rowData[i];
               }
               else if (columns[i].index === this._pkColumnIndex) {
                  value = this._hiddenData.length + index;
               }
               else {
                  value = null;
               }
               row[columns[i].index] = value;
            }
         }

         this._pkIndex[row[this._pkColumnIndex]] = this._hiddenData.length + index;
         var Record = require('Deprecated/Record');

         return new Record({
            colDef: columns,
            row: row,
            pkValue: row[this._pkColumnIndex],
            parentRecordSet: this
         });
      },
      /**
       * Производит действия, необходимые для импорта записи в рекордсет. Дополнительно проставляет ключ, если его нет
       * @param {Deprecated/Record} record Запись, которую импортируют
       * @private
       */
      _importRecord: function(record) {
         RecordSetStatic.superclass._importRecord.apply(this, arguments);
         if (record.getKey() === undefined) {
            record.setKey(this._hiddenData.length, this._pkColumnIndex)
         }
      },
      /**
       * Начинает пакетную обработку добавления записей в рекордсет
       */
      beginBatchAppend: function() {
         this._pocketAppending = true;
      },
      /**
       * Заканчивает пакетную обработку добавления записей в рекордсет
       */
      endBatchAppend: function() {
         if (this._pocketAppending === true) {
            this._pocketAppending = false;
            this._rebuild();
            this._beginLoad();
         } else {
            ioc.resolve('ILogger').log("RecordSet:endBatchAppend", "Trying to complete batch processing, which is not started. Use beginBatchAppend before appendRecord.");
         }
      },
      /**
       * Добавляет запись или массив записей из данных вида ключ-значение
       * @param {Array|Object|Deprecated/Record} data Данные
       * @return {Deprecated/Record}
       */
      appendRecord: function(data) {
         var isArray = (data instanceof Array),
            Record = require('Deprecated/Record');

         if (isArray === true) {
            this.beginBatchAppend();
         } else {
            data = [data];
         }
         data = map(data, function(record) {
            if (!(record instanceof Record)) {
               record = this._recordFromData(record, 0);
            } else {
               this._importRecord(record);
            }
            return record;
         }, this);
         this.addRecords(data);
         if (isArray === true) {
            this.endBatchAppend();
            return data;
         } else {
            return data[0];
         }
      },
      at: function(idx) {
         return this._data[idx];
      },
      /**
       * Добавляет в рекордсет новые записи
       * @param {Array} data Массив хэш-мэпов ключ-значение для новых записей
       * @returns {Array} Массив получившихся записей
       */
      appendData: function(data) {
         var records = [];
         for (var j = 0, len = data.length; j < len; ++j) {
            records.push(this._recordFromData(data[j], j));
         }
         this.addRecords(records);
         return records;
      },
      /**
       * Вставляет запись после записи с указанным ключом. Если записи с указанным ключом не будет существовать, вставит в начало рекордсета
       * @param {String} key Ключ
       * @param {Deprecated/Record} record Запись, которую нужно вставить в рекордсет
       * @return {Deprecated/Record}
       */
      insertAfter: function(key, record) {
         var pkIndex = this._pkIndex[key];
         if (pkIndex !== undefined && pkIndex !== null) {
            this._hiddenData.splice(pkIndex + 1, 0, record);
         }
         else {
            this._hiddenData.unshift(record);
         }
         this._rebuild();
         this._beginLoad();
         return record;
      },
      /**
       * Уничтожает все записи
       */
      clear: function() {
         this._hiddenData = [];
         this._rebuild();
      },
      /**
       * Возврвщает все записи из рекордсета
       * @param {Boolean} allRecords Если true, в случае иерархии возвращает все записи независимо от текущей ноды
       * @return {Array}
       */
      getRecords: function(allRecords) {
         if (allRecords) {
            return this._hiddenData;
         }
   
         return this._data;
      },
      /**
       * Возвращает дочерние узлы записи с указанным идентификатором
       * @param {String} key Ключ записи
       * @return {Array}
       */
      recordChilds: function(key) {
         var result = [];
         for (var i = 0, len = this._hiddenData.length; i < len; ++i) {
            if (this._hiddenData[i] && this._hiddenData[i].get(this._options.hierarchyField) == key) {
               result.push(this._hiddenData[i].getKey());
            }
         }
         return result;
      },
      /**
       * Прерывает загрузку рекордсета
       */
      abort: function() {
         this._notify('onAbort');
      },
      /**
       * Перестраивает внутри себя иерархические данные
       * @private
       */
      _buildHierarchyData: function() {
      },
      /**
       * Удаляет запись, альтернативный способ (оставлен для совместимости)
       * @param {String|Number} key Первичный ключ записи
       */
      clearRecord: function(key) {
         this._deleteRecord(key);
      },
      /**
       * Сериализует рекордсет
       * @returns {{s: Array, d: Array}}
       */
      toJSON: function() {
         var retval = {"s": [], "d": []};
         this.each(function(record, idx) {
            if (idx === 0) {
               var dataRow = record.toJSON();
               retval.s = dataRow.s;
               retval.d.push(dataRow.d);
            } else {
               retval.d.push(record.getDataRow());
            }
         });
         return retval;
      },
      /**
       * Считает итоги по колонке
       * @param {Object} column - колонка
       * @return {Number | String}
       * @private
       */
      _calcResults: function(column) {
         var sum = 0,
            bigNumSum = 0,
            self = this,
            passResultType = function(record) {
               var
                  hierarchyField = self.getHierarchyField(),
                  isFolder = false;
   
               if (hierarchyField) {
                  //имеет ли рекорд потомков? если да, значит "folder", иначе - "leaf"
                  isFolder = record.get(hierarchyField + "$");
               }
   
               if (isFolder && self._options.resultType == 'folders' || !isFolder && self._options.resultType == 'leaves') {
                  return true;
               }
   
               return false;
            };
         var bigCalcSum = this.getBigCalcSum();

         this.each(function(record) {
            if (record.hasColumn(column.title) && (this._options.resultType == 'foldersAndLeaves' || passResultType(record))) {
               if (column.type == RecordTypes.FIELD_TYPE_MONEY && column.p) {
                  bigNumSum = bigCalcSum(bigNumSum, record.get(column.title), column.p);
               } else {
                  sum += record.get(column.title);
               }
            }
         });

         return sum || bigNumSum;
      },

      /**
       * Устанавливает функцию для сложения больших чисел
       * @param bigCalcSum {Function}
       */
      setBigCalcSum: function (bigCalcSum){
         if (getType(bigCalcSum) == 'function') {
            this._options.bigCalcSum = bigCalcSum;
         } else {
            ioc.resolve('ILogger').error("RecordSet:setBigNumSum","Argument must be a function")
         }
      },
      /**
       * Возвращает функцию для сложения больших чисел
       * @returns {Function}
       */
      getBigCalcSum: function () {
         var def = function (a, b) {
            return parseFloat(a) + parseFloat(b);
         };
         return this._options.bigCalcSum ? this._options.bigCalcSum : def;
      },
      /**
       * Возвращает запись с "итогами"
       * @return {Deprecated/Record}
       */
      getResults: function() {
         var columns = this.getColumns(),
            row = [],
            Record = require('Deprecated/Record');

         for (var i in columns) {
            if (columns.hasOwnProperty(i)) {
               var column = columns[i],
                  type = column.type;
               if (type === RecordTypes.FIELD_TYPE_MONEY || type === RecordTypes.FIELD_TYPE_INTEGER ||
                   type === RecordTypes.FIELD_TYPE_DOUBLE) {
                  row[column.index] = this._calcResults(column);
               }
            }
         }
         return new Record({
            row: row,
            colDef: columns
         });
      },
      /**
       * Устанавливает тип "итогов"
       * @param {String} resultType Тип итогов: 'leaves', 'folders' либо 'foldersAndLeaves'
       */
      setResultType: function(resultType){
         this._options.resultType = resultType;
      }
   });

   return RecordSetStatic;
});
