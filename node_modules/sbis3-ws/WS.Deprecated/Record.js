define('Deprecated/Record', [
   'Core/core-clone',
   'require',
   'Core/constants',
   'Core/Context',
   'Core/Deferred',
   'Deprecated/Enum',
   'Core/TimeInterval',
   'Core/EventBus',
   'Deprecated/RecordTypes',
   'Deprecated/SerializatorSBIS',
   'Core/core-instance',
   'Core/helpers/Object/getPropertyType',
   'Core/helpers/Object/sortedPairs',
   'Core/helpers/Array/clone',
   'Deprecated/helpers/parseIdentity',
   'Core/IoC',
   'Deprecated/helpers/String/parseComplexKey',
   'Deprecated/Adapter',
   'Deprecated/Parser',
   'Deprecated/Reader'
], function(
   cClone,
   require,
   _const,
   Context,
   Deferred,
   Enum,
   TimeInterval,
   EventBus,
   RecordTypes,
   SerializatorSBIS,
   cInstance,
   getPropertyType,
   sortedPairs,
   cloneArray,
   parseIdentity,
   IoC,
   parseComplexKey
) {
   var Record;

   /**
    * Редьюсер для получения сериализованной записи только с измененными колоноками
    * @private
    */
   // TODO Не надо ли его сделать именованной функцией НЕ в прототипе
   function onlyChangedFields(memo, colDef, colIdx) {
      if (colDef.n in memo.changed) {
         memo.s.push(colDef);
         memo.d.push(this._row[colIdx]);
      }
      return memo;
   }

   function prepareMoneyByPrecision(value, precision ) {
      var groups = /^\-?(\d+)(\.\d{0,})?$/.exec(value);
      if (groups !== null) {
         precision = +precision||4;
         var floatPart = groups[2],
            realPart = groups[1] ;
         if (typeof floatPart === 'undefined') {
            floatPart = '.';
         }
         var len = precision - floatPart.length + 1;
         if (len > 0) {
            for (var i=0;i < len; i++) {
               floatPart += '0';
            }
         } else if(len < 0) {
            floatPart = floatPart.slice(0, len);
         }
         return realPart+floatPart;
      } else {
         IoC.resolve('ILogger').error('prepareMoneyByPrecision', 'Value containing not valid characters only numbers allowed.');
      }
      return value;
   }

   /**
    * Сравнивает два значения
    * @param {*} value0 Первое значение
    * @param {*} value1 Второе значение
    * @return {Boolean}
    * @private
    */
   function isValueEqual(value0, value1) {
      if(value0 === value1){
         return true;
      }
      if(value0 instanceof Array && value1 instanceof Array){
         if(value0.length === value1.length){
            for(var i = 0; i < value0.length; ++i){
               if(value0[i] !== value1[i]){
                  return false;
               }
            }
            return true;
         }
      }

      // Когда в сравнение значением прилетает enum и конкретно значение.
      if (value0 instanceof Enum || value1 instanceof Enum){
         //Если оба значение - Enum, то выполняем штатную проверку equals
         if (value0 instanceof Enum && value1 instanceof Enum){
            return value0.equals(value1);
         }
         var enumVal0 = (value0 instanceof Enum) ? value0.getCurrentValue(): value0,
            enumVal1 = (value1 instanceof Enum) ? value1.getCurrentValue(): value1;
         return enumVal0 === enumVal1;
      }

      if(value0 && value0.equals && typeof(value0.equals) =='function') {
         return value0.equals(value1);
      }
      return false;
   }

   /**
    * Класс записи - обертки над данными, которые представлены в виде строки таблицы (объект с набором полей и их значений).
    * @class Deprecated/Record
    * @author Мальцев А.А.
    * @public
    * @deprecated Используйте класс {@link WS.Data/Entity/Record}.
    */
   Record = (/** @lends Deprecated/Record.prototype */function() {
      /**
       * @event onFieldChange Происходит при изменении полей записи.
       * @remark
       * Может быть инициировано функциями {@link set} или {@link rollback}.
       * Не вызывается, если массив изменившихся полей пуст.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Array} fields Список изменившихся полей.
       * @example
       * <pre>
       * var
       *    record = new Record({});
       *    record.addColumn('v', Record.FIELD_TYPE_STRING);
       *    record.addColumn('s', Record.FIELD_TYPE_STRING);
       *    record.subscribe('onFieldChange', function(eventObject, fields){
       *    var text = '';
       *    text += 'Количество изменившихся полей: ' + fields.length + '.\n';
       *    for(var i=0; i< fields.length; ++i) {
       *       text +=  '   ' + fields[i] + ': "' + this.get(fields[i]) + '".\n';
       *    }
       *    helpers.alert(text);
       * });
       * record.set('v', 'Some text.');
       * record.set('s', 'Some other text.');
       * record.rollback();
       * </pre>
       * @see set
       * @see rollback
       */
      /**
       * @cfg {Array} Массив данных, соответствующий этой записи.
       * @name Deprecated/Record#row
       */
      /**
       * @cfg {Object} Массив описания колонок.
       * @name Deprecated/Record#colDef
       */
      /**
       * @cfg {Deprecated/RecordSet} Набор записей, от которого получена эта строка.
       * @name Deprecated/Record#parentRecordSet
       */
      /**
       * @cfg {Number} Значение первичного ключа, соответствующего этой строке.
       * @name Deprecated/Record#pkValue
       */
      /**
       * @alias Deprecated/Record
       */
      function Record(cfg) {
         this._objectName = '';
         this._primaryColumnName = '';
         this._row = [];
         this._colDef = [];
         this._parentRecordSet = null;
         this._pkValue = undefined;
         this._columnIndex = {};
         this._changedFields = [];
         this._forGetValues = [];
         this._settedValues = [];
         this._columnNames = null;
         this._hasSetted = false;
         this._eventBusChannel = false;
         this._originalRow = false;


         if (cfg) {
            if (Object.keys(cfg).length == 1 && cfg.primaryColumnName) {
               this._primaryColumnName = cfg.primaryColumnName;
               return;
            }
            this._prepareData(cfg.row);
            this._colDef = cfg.colDef;
            this._parentRecordSet = cfg.parentRecordSet;
            this._pkValue = cfg.pkValue;
            this._parentId = cfg.parentId;
            this._objectName = cfg.objectName;
            //this.commit();
            // Если вдруг передали описание по старому формату, приведем его к новому
            if (!cfg.colDef || Object.prototype.toString.call(cfg.colDef) == "[object Object]") {
               var res = SerializatorSBIS.serializeData(this._row, this._colDef);
               this._colDef = res.s;
               this._row = [];
               var colName = "",
                  l = this._colDef.length,
                  i = 0;
               while (i < l) {
                  colName = this._colDef[i].n;
                  this._addColumnIdx(colName, i);
                  this._row.push(res.d[i]);
                  i++;
               }
            } else {
               var cnt = this._colDef.length,
                  j = 0;
               while (j < cnt) {
                  this._addColumnIdx(this._colDef[j].n, j);
                  j++;
               }
            }
         }
      }

      Record.prototype._moduleName = 'Deprecated/Record';

      Record.prototype._addColumnIdx = function(colName, index) {
         this._columnIndex[colName] = index;
      };
      /**
       * Редьюсер для получения сериализованной записи только с измененными колоноками
       * @private
       */
      // TODO Не надо ли его сделать именованной функцией НЕ в прототипе
      Record.prototype._onlyChangedFields = function(memo, colDef, colIdx) {
         if(colDef.n in memo.changed) {
            memo.s.push(colDef);
            memo.d.push(this._row[colIdx]);
         }
         return memo;
      };
      /**
       * При сохранении только измененных колонок, добавляет все колонки, отвечающие за иерархию в набор измененных
       * @private
       */
      Record.prototype._addHierarchyColumnsToChanged = function(changes) {
         this._colDef.reduce(function(memo, field) {
            if (field.s == RecordTypes.FIELD_TYPE_HIERARCHY) {
               memo[field.n] = 1;
            }
            return memo;
         }, changes);
      };
      Record.prototype._addKeyColumnToChanged = function(changes) {
         var keyColumnIndex;

         keyColumnIndex = this._parentRecordSet && this._parentRecordSet._pkColumnIndex || 0;

         if (keyColumnIndex < 0) {
            keyColumnIndex = 0;
         }

         changes[this._colDef[keyColumnIndex].n] = 1;
      };
      /**
      * Сериализует запись в формат, пригодны для конвертации в JSON.
      * @param {Object} [options]
      * @param {Boolean} [options.diffOnly=false] Только измененные колонки.
      * @param {Boolean} [options.fields=false] Только указанные в fields колонки.
      * @returns {*}
      */
      Record.prototype.toJSON = function(options) {
         var result, changes;
         this._originalRow = cloneArray(this._row);
         // Обновление только измененных полей доступно только тогда, когда у записи есть ключ
         if (options && (options.diffOnly || options.fields) && this.getKey()) {
            changes = this.getChangedColumns();
            if (options.fields) {
               for (var idx in changes) {
                  if (changes.hasOwnProperty(idx)) {
                     if (options.fields.indexOf(idx) == -1) {
                        delete changes[idx];
                     }
                  }
               }
            }
            this._addKeyColumnToChanged(changes);
            // Всегда должны присутствовать в отправляемом наборе все колонки иерархии
            this._addHierarchyColumnsToChanged(changes);
            if (options.fields) {
               this.prepareToSerialize(changes);
            } else {
               this.prepareToSerialize();
            }
            result = this._colDef.reduce(onlyChangedFields.bind(this), {
               changed: changes,
               s: [],
               d: [],
               _mustRevive: true,
               _type: 'record',
               _key: this.getKey()
            });
            delete result.changed;
            this._row = this._originalRow;
            return result;
         } else {
            return {
               s : this._colDef,
               d : this._prepareRawData(),
               _key: this.getKey(),
               _mustRevive: true,
               _type: 'record'
            };
         }
      };
      /**
        * Возвращает признак: является ли данная запись типом "Узел".
        * @remark
        * Подробнее о типах записей вы можете прочитать в разделе <a href='https://wi.sbis.ru/doc/platform/developmentapl/workdata/structure/vocabl/tabl/relations/#hierarchy'>Иерархия</a>.
        * @returns {Object}
        */
      Record.prototype.isBranch = function() {
         if (!this._parentRecordSet) {
            throw new Error('Method isBranch() can be called only for Record attached to the RecordSet.');
         }
         var hierField = this._parentRecordSet.getHierarchyField();
         if (hierField) {
            return this.get(hierField + "@");
         }
      };
      /**
        * Возврашает признак: могут ли быть дочерние записи.
        * @returns {Object}
        */
      Record.prototype.hasChildren = function() {
         if (!this._parentRecordSet) {
            throw new Error('Method hasChildren() can be called only for Record attached to the RecordSet.');
         }
         var hierField = this._parentRecordSet.getHierarchyField();
         if (hierField) {
            return this.get(hierField + "$");
         }
      };
      /**
        * Возвращает идентификатор родительской записи.
        * @remark
        * Когда возвращается null - данная запись находится в корне иерархии.
        * @returns {Object}
        */
      Record.prototype.getParentKey = function() {
         if (!this._parentRecordSet) {
            throw new Error('Method getParentKey() can be called only for Record attached to the RecordSet.');
         }
         var hierField = this._parentRecordSet.getHierarchyField();
         if (hierField) {
            return this.get(hierField);
         }
      };
      Record.prototype._prepareData = function(row) {
         this._row = row;
      };
      /**
       * Создание строки начальных значений
       * @param {Array} row
       * @returns {Array}
       */
      Record.prototype._createOriginalRow = function(row) {
         var originalRow = [];
         for (var i = 0, l = row.length; i < l; i++) {
            var element = row[i];
            if (getPropertyType(element, 'valueOf') === 'function') {
               element = element.valueOf();
            }
            originalRow[i] = element instanceof Array ? cClone(element) : element;
         }
         return originalRow;
      };
      /**
       * Копирует запись.
       * @param {Boolean} [attached] Определяет, будет ли привязана к рекордсету.
       * @returns {Deprecated/Record} Клон текущей записи.
       */
      Record.prototype.cloneRecord = function(attached) {
         var curRow = this._prepareRawData();
         var config = {
            row: curRow, // Отдаем копию данных, чтобы при изменении клонированной записи наша не изменилась
            colDef: this._colDef,
            pkValue: this._getKeyValue(),
            objectName: this._objectName,
            parentRecordSet: null
         };
         if(attached || attached === undefined){
            config.parentRecordSet = this._parentRecordSet;
         } else
            config.colDef = config.colDef.slice();
         return new Record(config);
      };
      /**
       * @typedef {String} RecordFieldType
       * @variant "Выборка" Значение хранится в константе RecordTypes.FIELD_TYPE_QUERY.
       * @variant "Запись" Значение хранится в константе RecordTypes.FIELD_TYPE_RECORD.
       * @variant "Число целое" Значение хранится в константе RecordTypes.FIELD_TYPE_INTEGER.
       * @variant "Строка" Значение хранится в константе RecordTypes.FIELD_TYPE_STRING.
       * @variant "Число вещественное" Значение хранится в константе RecordTypes.FIELD_TYPE_DOUBLE.
       * @variant "Деньги" Значение хранится в константе RecordTypes.FIELD_TYPE_MONEY.
       * @variant "Дата" Значение хранится в константе RecordTypes.FIELD_TYPE_DATE.
       * @variant "Дата и время" Значение хранится в константе RecordTypes.FIELD_TYPE_DATETIME.
       * @variant "Время" Значение хранится в константе RecordTypes.FIELD_TYPE_TIME.
       * @variant "Массив" Значение хранится в константе RecordTypes.FIELD_TYPE_ARRAY.
       * @variant "Логическое" Значение хранится в константе RecordTypes.FIELD_TYPE_BOOLEAN.
       * @variant "Перечисляемое" Значение хранится в константе RecordTypes.FIELD_TYPE_ENUM.
       * @variant "Флаги" Значение хранится в константе RecordTypes.FIELD_TYPE_FLAGS.
       * @variant "Связь" Значение хранится в константе RecordTypes.FIELD_TYPE_LINK.
       * @variant "Двоичные данные" Значение хранится в константе RecordTypes.FIELD_TYPE_BINARY.
       * @variant "UUID" Значение хранится в константе RecordTypes.FIELD_TYPE_UUID.
       * @variant "Файл-RPC" Значение хранится в константе RecordTypes.FIELD_TYPE_RPCFILE.
       * @variant "Временной интервал" Значение хранится в константе RecordTypes.FIELD_TYPE_TIME_INTERVAL.
       */
      /**
       * Добавляем колонку в запись.
       * @param {String} name Название колонки.
       * @param {RecordFieldType} type Тип колонки.
       * @param {String} [details] Дополнительные сведения о типе колонки.
       * Параметр используется, когда в параметре type (Тип колонки) используется Массив, Перечисляемое или Связь.
       * Тогда в параметре передают тип массива, структуру перечисляемого или имя связанной таблицы соответственно.
       * @param {Boolean} [fromRecordSet] Вызов из рекордсета, только добавить индекс новой колонки.
       * @param {Boolean} [colsCfg] Описание колонки для добавления в запись, на случай если колонки записи не смотрят на колонки рекордсета.
       * @returns {Boolean} Добавлена ли колонка.
       *
       * FIXME: Видимо не правильно что добавление в _row делается то из Record, то из RecordSet
       */
      Record.prototype.addColumn = function(name, type, details, colsCfg) {
         var result = false;
         if (cInstance.instanceOfModule(this._parentRecordSet, 'Deprecated/RecordSet') && this._parentRecordSet.contains(this.getKey())){
            if(colsCfg) {
               colsCfg.cols.forEach(function(col, idx){
                  var name = col.n;
                  // Поправим собственный индекс колонок
                  this._addColumnIdx(name, this._row.length);
                  // Если колонка нам еще не известна - добавим
                  // В записи, связанной с рекордсетом, колонка может быть уже видна "по ссылке" из рекордсета
                  if(this._colDef[this._columnIndex[name]] === undefined) {
                     this._colDef.push(col);
                  }
                  // Добавим данные. Рекордсет в своей реализации не добавляет данные в data для индексов, для которых существуют записи
                  this._row.push(colsCfg.data[idx]);
               }, this);
               result = true;
            } else {
               throw new Error('Record:addColumn - ' + rk('Нельзя изменять набор колонок в записи выборки'));
            }
         } else if(!this.hasColumn(name)){
            var config = SerializatorSBIS.getColumnConfigByType(name, type, details);
            if(config !== false){
               config.cols.forEach(function(col, idx){
                  this._addColumnIdx(col.n, this._row.length);
                  this._colDef.push(col);
                  this._row.push(config.data[idx]);
               }, this);
               result = true;
            }
         }
         // Если колонка добавлена - сбросим кэш имен
         if (result) {
            this._columnNames = null;
         }
         return result;
      };
      /**
       * Удаляет колонку.
       * @param {String} name Имя колонки, которую надо удалить.
       * @param {Boolean} fromRecordSet Вызов из рекордсета.
       * @returns {Boolean} Удалена колонка, или нет.
       */
      Record.prototype.removeColumn = function(name, fromRecordSet) {
         if (cInstance.instanceOfModule(this._parentRecordSet, 'Deprecated/RecordSet') &&
             fromRecordSet !== true && this._parentRecordSet.contains(this.getKey())) {
            throw new Error('Record:removeColumn - ' + rk('Нельзя изменять набор колонок в записи выборки'));
         } else {
            if (this.hasColumn(name)) {
               var idx = this.getColumnIdx(name);
               for (var colName in this._columnIndex) {
                  if (this._columnIndex.hasOwnProperty(colName) && this._columnIndex[colName] > idx) {
                     this._columnIndex[colName]--;
                  }
               }
               delete this._columnIndex[name];
               this._changedFields.splice(idx, 1);
               this._forGetValues.splice(idx, 1);
               this._settedValues.splice(idx, 1);
               if (fromRecordSet !== true) {
                  this._row.splice(idx, 1);
                  this._colDef.splice(idx, 1);
                  this._columnNames = null;
               }
               return true;
            } else {
               return false;
            }
         }
      };
      Record.prototype.getDataRow = function() {
         this.prepareToSerialize();
         return this._row;
      };
      /**
       * Возвращает строку в виде объекта.
       * @param recursive
       * @returns {Object}
       */
      Record.prototype.toObject = function(recursive) {
         var colDef,
            retval = {},
            l = this._colDef.length,
            i = 0;
         while (i < l) {
            colDef = this._colDef[i];
            retval[colDef.n] = this.get(colDef.n);
            if (recursive === true && retval[colDef.n] && retval[colDef.n].toObject) {
               retval[colDef.n] = retval[colDef.n].toObject();
            }
            i++;
         }
         return retval;
      };
      /**
       * @returns {Array} Массив имен, имеющихся в записи колонок.
       */
      Record.prototype.getColumns = function() {
         var i = 0, l;

         if (!this._columnNames) {
            this._columnNames = [];
            l = this._colDef.length;
            while (i < l) {
               this._columnNames.push(this._colDef[i].n);
               i++;
            }
         }

         return this._columnNames;
      };
      /**
       * Возвращает запись в виде массива.
       * @returns {Array}
       */
      Record.prototype.toArray = function() {
         var colDef,
            retval = [],
            l = this._colDef.length,
            i = 0;
         while (i < l) {
            colDef = this._colDef[i];
            retval.push(this.get(colDef.n));
            i++;
         }
         return retval;
      };
      /**
       * Возвращает индекс колонки по ее имени.
       * @param {String} columnName Имя колонки.
       * @returns {Number}
       */
      Record.prototype.getColumnIdx = function(columnName) {
         if (columnName in this._columnIndex) {
            return this._columnIndex[columnName];
         } else {
            throw new TypeError("Column " + columnName + " is not defined");
         }
      };
      /**
       * Возвращает тип колонки по ее имени.
       * @param {String} columnName Имя колонки.
       * @returns {String}
       */
      Record.prototype.getColumnType = function(columnName) {
         return this._getColumnTypeByIndex(this.getColumnIdx(columnName));
      };
      /**
       * Возвращает данные о колонке по ее имени.
       * @param {String} columnName Имя колонки.
       * @returns {Object}
       */
      Record.prototype.getColumnDefinition = function(columnName) {
         var idx = this.getColumnIdx(columnName),
            colDef = {},
            type;
         colDef["title"] = this._colDef[idx].n;
         colDef["index"] = idx;
         type = this._colDef[idx].t;
         if (typeof(type) == 'object') {
            colDef["type"] = type.n;
            switch (type.n) {
               case "Флаги":
               case "Перечисляемое":
                  colDef["s"] = type.s;
                  break;
               case "Связь":
                  colDef["table"] = type.t;
                  break;
               case "Массив":
                  colDef["arrayType"] = type.t;
                  break;
               default:
                  break;
            }
         } else {
            colDef["type"] = type;
            if (this._colDef[idx].s == "Иерархия") {
               colDef["s"] = "Иерархия";
            }
         }
         return colDef;
      };
      /**
       * Присутствует ли указанная колонка в данной записи.
       * @param {String} columnName Имя колонки.
       * @returns {Boolean} Присутствует или нет указанная колонка в данной записи.
       */
      Record.prototype.hasColumn = function(columnName) {
         return columnName in this._columnIndex;
      };
      /**
       * @returns {Deprecated/RecordSet}
       */
      Record.prototype.getRecordSet = function() {
         return this._parentRecordSet;
      };
      /**
       * Устанавливает recordSet для записи.
       * @param {Deprecated/RecordSet} recordSet Рекордсет, к которому должна обращаться запись.
       * @param {Boolean} useForce если true переопределит родительский рекордсет в любом случае.
       */
      Record.prototype.setRecordSet = function(recordSet, useForce) {
         if (recordSet != this._parentRecordSet && useForce) { // если меняют родительский рекордсет, то сохраним в записи лишь копию колонок, а не ссылку на них
            this._colDef = this._colDef.slice();
         }
         if (!this._parentRecordSet || useForce) {
            this._parentRecordSet = recordSet;
         }
      };
      /**
       * Получаем значение столбца, отвечающего за первичный ключ.
       */
      Record.prototype._getKeyValue = function(pkColumnIndex) {
         if (pkColumnIndex === undefined && !this._primaryColumnName) {
            return this._pkValue;
         }
         return this._row[
            pkColumnIndex === undefined ? this.getColumnIdx(this._primaryColumnName) : pkColumnIndex
         ];
      };
      /**
       * Получает первичный ключ записи.
       * @param {Number} [pkColumnIndex] Номер колонки с первичным ключом у записи, хранится в рекордсете.
       * @returns {String|Number} Первичный ключ записи.
       */
      Record.prototype.getKey = function(pkColumnIndex) {
         var curKey = this._getKeyValue(pkColumnIndex);
         if (typeof curKey == 'number' || (typeof curKey == 'string' && curKey.indexOf(_const.IDENTITY_SPLITTER) == -1)) {
            if (this._objectName)
               return (curKey + _const.IDENTITY_SPLITTER + this._objectName);
         }
         return curKey;
      };
      /**
       * Получает первичный ключ записи со сложным идентификатором.
       * @returns {Object} Объект состоящий из имени объекта БЛ и его Ид.
       */
      Record.prototype.getComplexKey = function() {
         return parseComplexKey(this.getKey());
      };
      Record.prototype._importValueForGet = function(value, type, typeConf) {
         switch (type) {
            case RecordTypes.FIELD_TYPE_DATE:
            case RecordTypes.FIELD_TYPE_DATETIME:
            case RecordTypes.FIELD_TYPE_TIME:
               var date = Date.fromSQL(value),
                  serializeMode;
               switch (type) {
                  case "Дата и время":
                     serializeMode = true;
                     break;
                  case "Время":
                     serializeMode = false;
                     break;
               }
               date.setSQLSerializationMode(serializeMode);
               return date;
            case RecordTypes.FIELD_TYPE_IDENTITY:
               return parseIdentity(value);
            case RecordTypes.FIELD_TYPE_ENUM:
               return new Enum({
                  availableValues: typeConf.s,
                  currentValue: value
               });
            case RecordTypes.FIELD_TYPE_FLAGS:
               var st = {},
                  pairs = sortedPairs(typeConf.s),
                  fData = [];
               for (var pI = 0, pL = pairs.keys.length; pI < pL; pI++) {
                  st[pI] = {
                     type: "Логическое",
                     title: pairs.values[pI],
                     index: pairs.keys[pI]
                  };
                  fData[pI] = value[pI];
               }
               return new Record({
                  row: fData,
                  colDef: st,
                  parentRecordSet: null,
                  pkValue: null
               });
            case RecordTypes.FIELD_TYPE_RECORD:
               if (value === null) {
                  return null;
               } else if (value instanceof Record) {
                  return value;
               } else {
                  return new Record({
                     row: value.d,
                     colDef: value.s,
                     parentRecordSet: null,
                     pkValue: null
                  });
               }
            case RecordTypes.FIELD_TYPE_QUERY:
               if (value === null) {
                  return null;
               } else if (cInstance.instanceOfModule(value, 'Deprecated/RecordSet')) {
                  return value;
               } else {
                  var RecordSet = require('Deprecated/RecordSet');
                  return new RecordSet({
                     readerParams: {
                        adapterType: 'TransportAdapterStatic',
                        adapterParams: {
                           data: {
                              d: value.d || [],
                              s: value.s || [],
                              r: value.r,
                              n: value.n,
                              p: value.p
                           }
                        }
                     }
                  });
               }
            case RecordTypes.FIELD_TYPE_MONEY:
               return value === undefined ? null : value;
            case RecordTypes.FIELD_TYPE_TIME_INTERVAL:
               return new TimeInterval(value);
            default:
               return value === undefined ? null : value;
         }
      };
      /**
       * Возвращает значение в зависимости от типа колонки
       */
      Record.prototype._importValueForSet = function(value, type, typeConf) {
         switch (type) {
            case RecordTypes.FIELD_TYPE_DATE:
            case RecordTypes.FIELD_TYPE_DATETIME:
            case RecordTypes.FIELD_TYPE_TIME:
               var serializeMode;
               switch (type) {
                  case "Дата и время":
                     serializeMode = true;
                     break;
                  case "Время":
                     serializeMode = false;
                     break;
               }
               return value instanceof Date ? value.toSQL(serializeMode) : null;
            case RecordTypes.FIELD_TYPE_INTEGER:
               return (typeof(value) == 'number') ? value : (isNaN(parseInt(value, 10)) ? null : parseInt(value, 10));
            case RecordTypes.FIELD_TYPE_IDENTITY:
               return SerializatorSBIS.serializeHierarchyIdentity(value);
            case RecordTypes.FIELD_TYPE_ENUM:
               if (value instanceof Enum) {
                  var eV = value.getCurrentValue();
                  return eV === null ? null : parseInt(eV, 10);
               } else
                  return value;
            case RecordTypes.FIELD_TYPE_FLAGS:
               if (value instanceof Record) {
                  var s = {},
                     t = value.getColumns(),
                     dt = [];
                  for (var x = 0, l = t.length; x < l; x++) {
                     s[value.getColumnIdx(t[x])] = t[x];
                  }
                  var sorted = sortedPairs(s),
                     rO = value.toObject();
                  for (var y = 0, ly = sorted.keys.length; y < ly; y++) {
                     dt.push(rO[sorted.values[y]]);
                  }
                  return dt;
               } else if (value instanceof Array) {
                  return value;
               } else {
                  return null;
               }
            case RecordTypes.FIELD_TYPE_RECORD:
            case RecordTypes.FIELD_TYPE_QUERY:
               if (value === null) {
                  return null;
               } else if (value instanceof Record || cInstance.instanceOfModule(value, 'Deprecated/RecordSet')) {
                  return value.toJSON();
               } else {
                  return SerializatorSBIS.serialize(value);
               }
            case RecordTypes.FIELD_TYPE_STRING:
               return value === null ? null : value + "";
            case RecordTypes.FIELD_TYPE_LINK:
               return value === null ? null : parseInt(value, 10);
            case RecordTypes.FIELD_TYPE_MONEY:
               if (typeConf.p > 3) {
                  return prepareMoneyByPrecision(value, typeConf.p);
               } else {
                  var floatVal = parseFloat(value);
                  return value && !isNaN(floatVal) ? floatVal : value;
               }
            case RecordTypes.FIELD_TYPE_TIME_INTERVAL:
               if(value === null) {
                  return null;
               } else if(value instanceof TimeInterval){
                  return value.toString();
               } else {
                  return TimeInterval.toString(value);
               }
            default:
               return value;
         }
      };
      /**
       * Получить значение до первого изменения.
       * @remark
       * Возвращает значение столбца записи в состоянии до первого изменения
       * (т.е. то, которое получится при использовании rollback).
       *
       * Если изменений не было, то вернёт текущее значение колонки (результат работы get(columnName)).
       *
       * @param {String} columnName Имя колонки.
       * @return {*} Значение столбца записи в состоянии до первого изменения.
       * @throws TypeError Если колонка с заданным именем отсутствует в записи.
       * @see rollback
       * @see get
       */
      Record.prototype.getOriginal = function(columnName) {
         var
            idx = this._columnIndex[columnName],
            type,
            typeName,
            value;

         if (idx === undefined) {
            throw new TypeError("Column " + columnName + " is not defined");
         } else {
            type = this._colDef[idx].t;
            typeName = typeof(type) == 'object' ? type.n : type;
            value = this._row[idx];
            if (value !== null || typeName in {"Перечисляемое": 0, "Запись": 0, "Выборка": 0}) {
               value = this._importValueForGet(value, typeName, type);
            }
            return value;
         }
      };
      /**
       * Возвращает значение столбца записи по имени столбца.
       * @param {String} columnName Имя колонки.
       * @returns {Object}
       */
      Record.prototype.get = function(columnName) {
         var idx = this._columnIndex[columnName],
            type, typeName,
            value;
         if (idx === undefined) {
            throw new TypeError("Column " + columnName + " is not defined");
         } else {
            if (this._hasSetted && this._settedValues[idx] !== undefined) {
               value = this._settedValues[idx];
            } else if (this._forGetValues[idx] !== undefined) {
               type = this._colDef[idx].t;
               typeName = typeof(type) == 'object' ? type.n : type;
               value = this._forGetValues[idx];
            }
            if (value === undefined) {
               type = this._colDef[idx].t;
               typeName = typeof(type) == 'object' ? type.n : type;
               value = this._row[idx];
               if (value !== null || typeName in {"Перечисляемое": 0, "Запись": 0, "Выборка": 0})
                  value = this._importValueForGet(value, typeName, type);
               this._forGetValues[idx] = value;
            }
            return value;
         }
      };
      Record.prototype._setField = function(columnName, value) {
         var idx = this._columnIndex[columnName],
            isValueChanged = false;
         if (idx === undefined) {
            throw new TypeError("Column " + columnName + " is not defined");
         } else if (value === undefined) {
            throw new TypeError("Value for column " + columnName + " is not valid");
         } else if (value && typeof value === 'object' && String(value._moduleName).substr(0, 8) === 'WS.Data/') {
            throw new TypeError("Value type for column " + columnName + " is not supported");
         } else {
            var type = this._colDef[idx].t,
               typeName = typeof(type) == 'object' ? type.n : type,
               v0, v1;

            if (this._settedValues[idx] === undefined) {
               v0 = this._importValueForSet(value, typeName, type);
               v1 = this._row[idx];
               // Для колонки с типом Enum:
               // текущее значение в _forGetValues может отличаться от того что лежит в _row.
               // Поэтому если в _forGetValues лежит объект с типом Enum, текущее значение возьмём из него
               if (typeName == RecordTypes.FIELD_TYPE_ENUM) {
                  var curVal = this._forGetValues[idx];
                  if (curVal instanceof Enum) {
                     curVal = curVal.getCurrentValue();
                     v1 = curVal === null ? null : parseInt(curVal, 10);
                  }
               }
            } else {
               v0 = value;
               v1 = this._settedValues[idx];
            }
            // ToDo: выпилить этот кусок кода и поддержать сохранение формата в toSQL/fromSQL
            // http://youtrack.sbis.ru/issue/wi_sbis-322
            if (type == 'Дата и время' || type == 'Дата' || type == 'Время') {
               if (typeof v0 == 'string') {
                  v0 = Date.fromSQL(v0);
               }
               if (typeof v1 == 'string') {
                  v1 = Date.fromSQL(v1);
               }
            }
            if (!isValueEqual(v0, v1)) {
               isValueChanged = true;
            }
            if (isValueChanged) {
               this._hasSetted = true;

               switch(typeName) {
                  case RecordTypes.FIELD_TYPE_TIME_INTERVAL:
                     this._settedValues[idx] = (value !== null? new TimeInterval(value): null);
                     break;
                  case RecordTypes.FIELD_TYPE_MONEY:
                     //если тип данных "Деньги" с определенной точностью, то сохранить строку
                     if(type.p > 3) {
                        this._settedValues[idx] = prepareMoneyByPrecision(value, type.p);
                     } else {
                        var floatVal = parseFloat(value);
                        this._settedValues[idx] = value && !isNaN(floatVal) ? floatVal : value;
                     }
                     break;
                  default:
                     this._settedValues[idx] = value;
               }

               //в взятых значениях значение уже не актуально, забудем про него
               this._forGetValues[idx] = undefined;
               // Если у нашей колонки тип идентификатор, то в конечном итоге он запишется он как массив,
               // По этому для проверки на изменение нам надо, при необходимости, привести к массиву.
               if (this.getColumnType(this._colDef[idx].n) == RecordTypes.FIELD_TYPE_IDENTITY && !(value instanceof Array)) {
                  value = SerializatorSBIS.serializeHierarchyIdentity(value);
               }
               // тут мы проверяем на ситуацию когда в _row было 1, потом положили 2, а потом снова 1
               // тогда не должно считаться, что запись поменялась
               this._changedFields[idx] = !isValueEqual(value, this._row[idx])
            }
         }
         return isValueChanged;
      };
      /**
       * устанавливает внутрь записи значение, непосредственно в _row
       * @returns {Boolean} успешно ли прошла установка значения
       */
      Record.prototype._setInnerField = function(columnName, value, rows) {
         try {
            var idx = this.getColumnIdx(columnName),
               type = this._colDef[idx].t,
               typeName = typeof(type) == 'object' ? type.n : type;
            value = this._importValueForSet(value, typeName, type);
            rows[idx] = value;
            return true;
         } catch (e) {}
         return false;
      };
      Record.prototype._getColumnTypeByIndex = function(idx) {
         var type = this._colDef[idx].t;
         if(typeof(type) == "string")
            return type;
         else
            return type && type.n;
      };
      Record.prototype._prepareRawData = function(availableColumns) {
         var l = this._forGetValues.length,
            i = 0,
            self = this,
            curRow = cloneArray(this._row),
            natSort = function(a, b) {
               a = parseInt(a, 10);
               b = parseInt(b, 10);
               return a < b ? -1 : 1;
            },
            field,
            type;
         while (i < l) {
            if (this._forGetValues.hasOwnProperty(i)) {
               field = this._forGetValues[i];
               type = this._getColumnTypeByIndex(i);
               if (type == RecordTypes.FIELD_TYPE_FLAGS && field instanceof Record) {
                  // Флаги нужно сложить строго по порядку индексов, поэтому и сортировка и т.п.
                  curRow[i] = [];
                  var sortedFlags = Object.keys(this._colDef[i].t.s).sort(natSort);
                  sortedFlags.forEach(function(n, idx) {
                     curRow[i][idx] = field.get(self._colDef[i].t.s[n]);
                  });
               }
               else if (field instanceof Record || cInstance.instanceOfModule(field, 'Deprecated/RecordSet')) {
                  curRow[i] = field.toJSON();
               }
               else if (field instanceof Enum) {
                  var eV = field.getCurrentValue();
                  curRow[i] = (eV === null ? null : parseInt(eV, 10));
               }
            }
            i++;
         }
         for (i = 0, l = this._colDef.length; i < l; ++i) {
            type = this._colDef[i].t;
            if (type === RecordTypes.FIELD_TYPE_IDENTITY && !(curRow[i] instanceof Array)) {
               curRow[i] = [curRow[i]];
            }
         }

         var l = this._settedValues.length,
            i = 0;
         while (i < l){
            if(this._settedValues[i] !== undefined) {
               if (!availableColumns || availableColumns[this._colDef[i].n] !== undefined) {
                  this._setInnerField(this._colDef[i].n, this._settedValues[i], curRow);
               }
            }
            i++;
         }
         return curRow;
      };
      Record.prototype.prepareToSerialize = function(availableColumns){
         this._row = this._prepareRawData(availableColumns);
      };
      /**
       * @returns {Array|null}
       * @private
       */
      Record.prototype._prepareChangedFields = function() {
         if (!this._eventBusChannel) {
            return null;
         }
         return Object.keys(this.getChangedColumns());
      };
      /**
       * Сообщить об изменившихся полях
       * Вызывает событие onFieldChange для записи если на него кто-то подписался.
       * @param {Array} fields Массив изменившихся полей
       * @protected
       */
      Record.prototype._notifyFieldsChanged = function(fields) {
         if (!this._eventBusChannel) {
            return;
         }
         if (!fields || !fields.length) {
            return;
         }
         this._eventBusChannel.notify('onFieldChange', fields);
      };
      /**
       * Добавить обработчик на событие.
       * @remark
       * Подписиывает делегата на указанное событие текущего объекта.
       * @param {String}   event    Имя события, на которое следует подписать обработчик.
       * @param {Function} handler  Функция-делегат, обработчик события.
       * @param {*}        [ctx]    Контекст выполнения
       * @returns {Deprecated/Record} Возвращает себя.
       */
      Record.prototype.subscribe = function(event, handler, ctx) {
         if (!this._eventBusChannel) {
            this._eventBusChannel = EventBus.channel({subscribeOnPS: true});
            this._eventBusChannel.publish('onFieldChange');
         }
         if (ctx === undefined) {
            ctx = this;
         }
         this._eventBusChannel.subscribe(event, handler, ctx);
         return this;
      };
      /**
       * Снять подписку заданного обработчика с заданного события.
       * @param {String}   event    Имя события, на которое следует подписать обработчик.
       * @param {Function} handler  Функция-делегат, обработчик события.
       * @param {*}        [ctx]    Контекст выполнения
       * @returns {Deprecated/Record} Возвращает себя
       */
      Record.prototype.unsubscribe = function(event, handler, ctx) {
         if (this._eventBusChannel) {
            this._eventBusChannel.unsubscribe(event, handler, ctx);
         }
         return this;
      };
      /**
       * Присваивает значение столбцу записи по имени столбца без изменений в базе.
       * @remark
       * При выполнении метода происходит событие {@link onFieldChange}.
       * @param {String} columnName имя колонки
       * @param {Object} value значение
       * @see onFieldChange
       */
      Record.prototype.set = function(columnName, value) {
         var
            self = this,
            changedFields = [],
            setFieldInner = function(key, value) {
               // меняем поле в записи
               if (self._setField(key, value)) {
                  // поле действительно изменилось изменилось
                  changedFields.push(key);
               }
            };
         // А вдруг кто-то передал объект
         if (typeof( columnName ) != 'object') {
            setFieldInner(columnName, value);
         } else {
            for (var key in columnName) {
               if (columnName.hasOwnProperty(key)) {
                  setFieldInner(key, columnName[key]);
               }
            }
         }
         this._notifyFieldsChanged(changedFields);
      };
      /**
       * Возвращает название колонки, в которой лежит первичный ключ.
       * @returns {String}
       */
      Record.prototype.getKeyField = function() {
         var index;
         if (this._parentRecordSet) {
            index = this._parentRecordSet.getPkColumnIndex();
         }
         else {
            index = 0;
         }
         return this._colDef[index].n;
      };
      /**
       * Присваивает значение столбцу записи по имени столбца без изменений в базе.
       * @param {Number} pkValue Новое значение первичного ключа этой записи.
       * @param {Number} [pkColumnIndex] Номер колонки с первичным ключом у записи, хранится в рекордсете.
       *
       */
      Record.prototype.setKey = function(pkValue, pkColumnIndex) {
         var field = (pkColumnIndex === undefined
            ? this.getKeyField()
            : (this._colDef[pkColumnIndex] ? this._colDef[pkColumnIndex].n : undefined)
         );

         if (field) {
            this._setField(field, pkValue);
         }
         this._pkValue = pkValue;
         if (this._parentRecordSet) {
            this._parentRecordSet.addPkIndex(pkValue);
         }
         if (!this._objectName) {
            this._objectName = parseComplexKey(pkValue).objName;
         }
      };
      /**
       * Удаляет запись из источника.
       * @returns {Core/Deferred|Boolean}
       */
      Record.prototype.destroy = function() {
         var self = this;
         if (!this._parentRecordSet) {
            throw new Error('Method destroy() can be called only for Record attached to the RecordSet.');
         }
         return this._parentRecordSet.deleteRecord([this._getKeyValue()]).addCallback(function(result) {
            self.commit();
            if (self._eventBusChannel) {
               self._eventBusChannel.destroy();
            }
            return result;
         });
      };
      /**
       * Записывает текущее состояние записи в базу.
       * @param {Object} [options] Опции, модифицирующие процедуру обновления
       * @param {Boolean} [options.consistencyCheck = false] Отслеживать целостность записи ?
       * @param {Boolean} [options.diffOnly = false] Сохранять только измененные поля
       * @param {Boolean} [options.fields=false] Только указанные в fields колонки
       * @returns {Core/Deferred}
       */
      Record.prototype.update = function(options) {
         var self = this;

         if (options && options.diffOnly && this.getKey() && !this.isChanged()) {
            return new Deferred().callback(this.getKey());
         }

         if (!this._parentRecordSet) {
            throw new Error('Method update() can be called only for Record attached to the RecordSet.');
         }
         return this._parentRecordSet.updateRecord(this, options).addCallback(function(r) {
            if (options && options.fields) {
               self.commit.apply(self, options.fields);
            } else {
               self.commit();
            }

            return r;
         });
      };
      /**
       * Помечаем запись как неизменённую, без записи в базу, после вызова функции isChanged вернёт false.
       * @remark
       * После этого rollback вернёт нас к этому зафиксированному состоянию.
       * @param {Object} arguments Названия полей, по которым надо провести commit.
       */
      Record.prototype.commit = function() {
         var fullRecord = (arguments.length > 0) ? false : true,
            l = (arguments.length > 0) ? arguments.length : this._forGetValues.length,
            i = 0,
            colDef, colType, idx;
         if (fullRecord) {
            this._changedFields = [];
         }
         var tryCommit = function(fieldValue, i) {
            if (fieldValue !== undefined) {
               if (getPropertyType(fieldValue, 'commit') === 'function') {
                  fieldValue.commit();
               }
               colDef = this._colDef[i];
               colType = typeof(colDef.t) == 'string' ? colDef.t : colDef.t.n;
               if (!fullRecord){
                  delete this._changedFields[i];
               }
               this._row[i] = this._importValueForSet(fieldValue, colType, colDef.t);
            }
         };
         while (i < l) {
            if (fullRecord) {
               tryCommit.apply(this, [this._forGetValues[i], i]);
            } else {
               idx = this.getColumnIdx(arguments[i]);
               tryCommit.apply(this, [this._forGetValues[idx], idx]);
            }
            i++;
         }
         l = (arguments.length > 0) ? arguments.length : this._settedValues.length;
         i = 0;
         while (i < l) {
            if (fullRecord) {
               tryCommit.apply(this, [this._settedValues[i], i]);
            } else {
               idx = this.getColumnIdx(arguments[i]);
               tryCommit.apply(this, [this._settedValues[idx], idx]);
            }
            i++;
         }
         if (fullRecord) {
            this._originalRow = undefined;
         }
      };
      /**
       * Если в идентификаторе связи нет разделителя и у нас задано имя объекта, добавим имя объекта
       * @param linkId Идентификатор связи
       * @return {*} Исправленные идентификатор связи
       * @private
       */
      Record.prototype._rewriteLinkId = function(linkId) {
         if (this._objectName) {
            if (("" + linkId).indexOf(_const.IDENTITY_SPLITTER) == -1) {
               linkId = linkId + _const.IDENTITY_SPLITTER + this._objectName;
            }
         }
         return linkId;
      };
      /**
       * @param {Number} linkId
       * @param {String} linkName
       * @returns {Core/Deferred}
       */
      Record.prototype.updateLink = function(linkId, linkName) {
         var self = this;
         return this.readLink(this._rewriteLinkId(linkId), linkName).addCallback(function(spec) {
            spec.each(function(col, val) {
               try {
                  self.set(col, val);
               } catch (e) { }
            });
            return spec;
         })
      };
      /**
        *
        * @param linkId
        * @param linkName
        * @returns {Core/Deferred}
        */
      Record.prototype.readLink = function(linkId, linkName) {
         if (!this._parentRecordSet) {
            throw new Error('Method readLink() can be called only for Record attached to the RecordSet.');
         }
         return this._parentRecordSet.readRecord(this._rewriteLinkId(linkId), undefined, linkName);
      };
      /**
       * Откат записи в состояние последнего update/rollback.
       * @remark
       * При выполнении метода происходит событие {@link onFieldChange}.
       * @param {Object} arguments Названия полей, по которым необходимо провести rollback.
       * @see onFieldChange
       */
      Record.prototype.rollback = function() {
         var changedFields = this._prepareChangedFields();
         if (arguments.length === 0) {
            this._changedFields = [];
            this._settedValues = [];
            this._forGetValues = [];
            if (this._originalRow) {
               this._row = this._originalRow;
               this._originalRow = undefined;
            }
         } else {
            var args = Array.prototype.slice.call(arguments),
               idx, i, len;
            for (i = 0; i < args.length; i++) {
               idx = this.getColumnIdx(args[i]);
               delete this._changedFields[idx];
               delete this._settedValues[idx];
               delete this._forGetValues[idx];
            }
            changedFields = changedFields.filter(function(item) {
               return (args.indexOf(item) !== -1);
            });
         }
         this._notifyFieldsChanged(changedFields);
      };
      /**
       * Редьюсер для получения измененных колонок
       * @private
       */
      // TODO Не надо ли его сделать именованной функцией НЕ в прототипе
      Record.prototype._reduceChanged = function(memo, val, fld) {
         if (!!val) {
            memo[this._colDef[fld].n] = 1;
         }
         return memo;
      };
      /**
       * Редьюсер для получения измененных колонок
       * @private
       */
      // TODO Не надо ли его сделать именованной функцией НЕ в прототипе
      Record.prototype._reduceComplex = function(memo, value, fld) {
         if (value && typeof(value.isChanged) == 'function' && value.isChanged()) {
            memo[this._colDef[fld].n] = 1;
         }
         return memo;
      };
      /**
       * Отдает хэш-мэп имен измененных полей данной записи. В качестве ключа - название колонки, в качестве значения - 1.
       * @param {array} [availableColumns = false] - массив полей, изменения которых мы отслеживаем.
       * @returns {Object}
       */
      Record.prototype.getChangedColumns = function() {
         var changedFields = {};
         this._changedFields.reduce(this._reduceChanged.bind(this), changedFields);
         this._settedValues.reduce(this._reduceComplex.bind(this), changedFields);
         this._forGetValues.reduce(this._reduceComplex.bind(this), changedFields);
         return changedFields;
      };
      /**
       * Позволяет выяснить, менялось ли содержимое записи с последнего update/rollback.
       * @param {String} [fieldName] - имя поля. Если указан, то проверять только поле fieldName на изменение.
       * @returns {Boolean}
       */
      Record.prototype.isChanged = function(fieldName) {
         var checkValue = function(value){
            if(value && typeof(value.isChanged) == 'function' && value.isChanged())
               return true;
            return false;
         };
         if(fieldName === undefined){
            for(var i = 0, l = this._changedFields.length; i < l; i++){
               if(this._changedFields[i])
                  return true;
            }
            var check = function(values){
               for(var i = 0, l = values.length; i < l; i++){
                  if(checkValue(values[i]))
                     return true;
               }
               return false;
            };
            if(check(this._settedValues))
               return true;
            if(check(this._forGetValues))
               return true;
            return false;
         }
         else{
            var idx = this.getColumnIdx(fieldName);
            if(this._changedFields[idx] === true)
               return true;
            if(checkValue(this._settedValues[idx]))
               return true;
            if(checkValue(this._forGetValues[idx]))
               return true;
            else
               return false;
         }
      };
      /**
       * Позволяет вручную установить признак изменённости записи.
       * @remark
       * Бывает нужно для тех случаев, когда метод update должен сохранить даже фактически неизменнёную запись (или ещё каких-то подобных случаев).
       * @param {String} [fieldName] - имя поля. Если не указано, то пометить все поля как изменённые.
       */
      Record.prototype.setChanged = function(fieldName) {
         var idx;
         if (fieldName === undefined){
            for (var col in this._columnIndex) {
               if (this._columnIndex.hasOwnProperty(col)) {
                  idx = this.getColumnIdx(col);
                  this._changedFields[idx] = true;
               }
            }
         }
         else {
            idx = this.getColumnIdx(fieldName);
            this._changedFields[idx] = true;
         }
      };
      /**
       * Запускает перебор колонок записи.
       * @param {Function} f Функция, вызываемая для каждой колонки.
       * В аргументах приходит имя колонки и ее значение
       * Если вернуть из функции false, перебор остановится.
       */
      Record.prototype.each = function(f) {
         var l = this._colDef.length,
            colName;
         for (var i = 0; i < l; i++) {
            if (i in this._colDef) {
               colName = this._colDef[i].n;
               if (f.apply(this, [colName, this.get(colName)]) === false) {
                  return;
               }
            }
         }
      };
      /**
       * Проверяет: совпадает ли переданный объект с данным.
       * @param {Deprecated/Record} other Запись, с которой производится сравнение.
       * @returns {Boolean}
       */
      Record.prototype.equals = function(other) {
         if (other instanceof Record) {
            if (this.getColumns().length !== other.getColumns().length) {
               return false;
            }

            var result = true;
            this.each(function(colName, currentValue){
               if(!other.hasColumn(colName)) // no column - they are different
                  return (result = false); // stop enumeration
               if(currentValue && currentValue.equals) { // complex type
                  if(!currentValue.equals(other.get(colName))) // if not equals
                     return (result = false); // stop enumeration, they are different
               } else { // simple type
                  if(currentValue !== other.get(colName)) // they are different
                     return (result = false); // stop enumeration
               }
            });
            return result;
         } else
            return false;
      };

      for (var index in RecordTypes) {
         if (RecordTypes.hasOwnProperty(index)) {
            Record[index] = RecordTypes[index];
         }
      }
      var
         RecordFieldProxy = function(record, fieldName) {
            this.record = record;
            this.fieldName = fieldName;
         },
         RecordFieldType = {
            //TODO: обработка в методах спец-типов полей:
            // FIELD_TYPE_ARRAY
            // FIELD_TYPE_HIERARCHY
            // FIELD_TYPE_ENUM FIELD_TYPE_FLAGS
            // FIELD_TYPE_LINK FIELD_TYPE_BINARY

            name: 'RecordFieldType',

            is: function(value) {
               return value instanceof Record;
            },

            //Встроенный record отдаёт значения только по одному уровню
            get: function(value, keyPath) {
               var
                  NonExistentValue = Context.NonExistentValue,
                  key, result, subValue, subType;

               if (keyPath.length !== 0) {
                  key = keyPath[0];
                  if (value.hasColumn(key)) {
                     subValue = value.get(key);
                     subType = Context.getValueType(subValue);
                     result = subType.get(subValue, keyPath.slice(1));
                  } else {
                     result = NonExistentValue;
                  }
               } else {
                  result = value;
               }

               return result;
            },

            setWillChange: function(oldValue, keyPath, value) {
               var result, subValue, key, subType;

               if (keyPath.length !== 0) {
                  key = keyPath[0];
                  result = oldValue.hasColumn(key);
                  if (result) {
                     subValue = oldValue.get(key);
                     subType = Context.getValueType(subValue);
                     result = subType.setWillChange(subValue, keyPath.slice(1), value);
                  }
               } else {
                  result = !RecordFieldType.is(value) || !oldValue.equals(value);
               }

               return result;
            },

            set: function(oldValue, keyPath, value) {
               var result, subValue, key, subType;

               if (keyPath.length !== 0) {
                  key = keyPath[0];
                  if (oldValue.hasColumn(key)) {
                     if (keyPath.length === 1) {
                        oldValue.set(key, value);
                     }
                     else {
                        subValue = oldValue.get(key);
                        subType = Context.getValueType(subValue);
                        subType.set(subValue, keyPath.slice(1), value);
                     }
                  }
                  result = oldValue;
               } else {
                  result = value;
               }

               return result;
            },

            remove: function(oldValue, keyPath) {
               var
                  key, subValue, subType,
                  newValue, length, i, changed,
                  record = oldValue;

               changed = keyPath.length !== 0;
               if (changed) {
                  key = keyPath[0];
                  changed = record.hasColumn(key);
                  if (changed) {
                     subValue = record.get(key);
                     changed = keyPath.length === 1;
                     if (changed) {
                        if (subValue instanceof Enum) {
                           changed = subValue.getCurrentValue() !== null;
                           if (changed) {
                              subValue.set(null);//TODO: зачем два сброса??? значение в методе set удаляется из рекорда
                              record.set(key, null);
                           }
                        } else if (record.getColumnType(key) === RecordTypes.FIELD_TYPE_FLAGS) {
                           newValue = [];
                           length = Array.isArray(subValue) ? subValue.length : subValue.getColumns().length;

                           for (i = length; i > 0; --i) {
                              newValue.push(null);
                           }
                           record.set(key, newValue);
                        } else {
                           changed = subValue !== null;
                           if (changed) {
                              record.set(key, null);
                           }
                        }
                     } else {
                        subType = Context.getValueType(subValue);
                        changed = subType.remove(subValue, keyPath.slice(1)).changed;
                     }
                  }
               }
               return {
                  value: record,
                  changed: changed
               };
            },

            toJSON: function(value, deep) {
               return deep ? value.toObject() : value;
            },

            subscribe: function(value, fn) {
               value.subscribe('onFieldChange', fn);
               return function() {
                  value.unsubscribe('onFieldChange', fn);
               };
            }
         },
         RecordFieldProxyType = {
            name: 'RecordFieldProxyType',

            is: function(value) {
               return value instanceof RecordFieldProxy;
            },

            get: function(value, keyPath) {
               var recPath = [value.fieldName].concat(keyPath);

               return RecordFieldType.get(value.record, recPath);
            },

            setWillChange: function(oldValue, keyPath, value) {
               var recPath = [oldValue.fieldName].concat(keyPath);

               return RecordFieldType.setWillChange(oldValue.record, recPath, value);
            },

            set: function(oldValue, keyPath, value) {
               var recPath = [oldValue.fieldName].concat(keyPath);

               RecordFieldType.set(oldValue.record, recPath, value);

               return oldValue;//сам прокси не меняется - меняется поле, на которое он указывает
            },

            isProxy: true,

            clear: function(value) {
               var res = RecordFieldType.remove(value.record, [value.fieldName]);

               //сам прокси не меняется - меняется поле, на которое он указывает
               return {
                  changed: res.changed,
                  value: value
               };
            },

            remove: function(value, keyPath) {
               var recPath = [value.fieldName].concat(keyPath),
                  res = RecordFieldType.remove(value.record, recPath);

               //сам прокси не меняется - меняется поле, на которое он указывает
               return {
                  value: value,
                  changed: res.changed
               };
            },

            toJSON: function(value, deep) {
               var
                  val = RecordFieldProxyType.get(value, []),
                  vtype = Context.getValueType(val);

               return vtype.toJSON(val, deep);
            },

            subscribe: function(value, fn) {
               function handler(event, fields) {
                  if (fields.indexOf(value.fieldName) !== -1) {
                     fn();
                  }
               }

               value.record.subscribe('onFieldChange', handler);

               return function() {
                  value.record.unsubscribe('onFieldChange', handler);
               };
            }
         };

      Context.registerFieldType(RecordFieldProxyType);
      Context.registerFieldType(RecordFieldType);

      Context.RecordFieldProxy = RecordFieldProxy;

      return Record;

   })();

   return Record;
});
