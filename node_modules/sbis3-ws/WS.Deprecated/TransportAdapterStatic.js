define('Deprecated/TransportAdapterStatic', [
   'Core/Deferred',
   'Deprecated/TransportAdapterAbstract'
], function(Deferred, TransportAdapterAbstract) {
   var TransportAdapterStatic;

   /**
    * @class Deprecated/TransportAdapterStatic
    * @extends Deprecated/TransportAdapterAbstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   TransportAdapterStatic = TransportAdapterAbstract.extend(/** @lends Deprecated/TransportAdapterStatic.prototype */{
      $protected: {
         _options: {
            /**
             * @cfg {Object} Статические данные для передачи в Reader
             */
            data: {}
         },
         _pkColumnIndex: 0,
         _pkIndex: null,
         _pkColumnName: undefined,
         _columns: [],
         _data: [],
         _columnsName: "s",
         _dataName: "d",
         _countName: "n",
         _columnTypeName: "t",
         _columnTitleName: "n",
         _pkName: "ИдО",
         _isStandartReader: true
      },
      $constructor: function() {
         if (typeof(this._options.data) === 'string') {
            this._options.data = JSON.parse(this._options.data);
         }
         var data = this._options.data;
         this._isStandartReader = !(data.cols && data.data);
         if (!this._isStandartReader) {
            this._columnsName = "cols";
            this._dataName = "data";
            this._columnTypeName = "type";
            this._columnTitleName = "name";
            this._pkName = "pk";
         }
         this._columns = data[this._columnsName];
         this._data = data[this._dataName];
         this._pkColumnIndex = data.k = data.k || 0;
         if (this._pkColumnIndex >= 0 && this._columns && this._columns[this._pkColumnIndex] !== undefined) {
            this._pkColumnName = this._columns[this._pkColumnIndex][this._columnTitleName];
         }
      },
      getRPCClient: function() {
         return null;
      },
      _refreshPkIndex: function() {
         var dataRow;
         this._pkIndex = {};
         for (var i = 0, l = this._data.length; i < l; i++) {
            dataRow = this._data[i];
            this._pkIndex[dataRow[this._pkColumnIndex]] = i;
         }
      },
      list: function(args) {
         var paging = this._isStandartReader && args["Навигация"] || ( args && args.usePages ? args : false ),
             data = {},
             count = this._data.length,
             firstRecordNumber = 0,
             lastRecordNumber = count;
         data[this._countName] = count;
         if (paging) { // если используется постраничная навигация, то обработаем ее
            var pageNumber, recordsPerPage, hasMore;
            if (this._isStandartReader) {
               for (var j = 0, l = paging[this._columnsName].length; j < l; j++) {
                  switch (paging[this._columnsName][j].n) {
                     case "Страница":
                        pageNumber = paging[this._dataName][j];
                        break;
                     case "РазмерСтраницы":
                        recordsPerPage = paging[this._dataName][j];
                        break;
                     case "ЕстьЕще":
                        hasMore = paging[this._dataName][j];
                        break;
                     default:
                        break;
                  }
               }
            } else {
               pageNumber = paging.pageNum;
               recordsPerPage = paging.pageCount;
               hasMore = paging.usePages == "full";
            }
            if (pageNumber == -1) {
               pageNumber = parseInt(count / recordsPerPage, 10);
            }
            firstRecordNumber = pageNumber * recordsPerPage;
            lastRecordNumber = Math.min(firstRecordNumber + recordsPerPage, count);
            if (hasMore) {
               data[this._countName] = !!this._data[lastRecordNumber];
            }
         }
         data[this._dataName] = this._data.slice(firstRecordNumber, lastRecordNumber);
         data[this._columnsName] = this._columns;
         if (this._options.data.r !== undefined) {
            //если нам отдали итоги, то отдадим их как есть в ответ
            data.r = this._options.data.r;
         }
         if(this._options.data.n !== undefined) {
            //если нам отдали кол-во записей, то отдадим их как есть в ответ
            data.n = this._options.data.n;
         }
         if(this._options.data.p !== undefined) {
            //если нам отдали путь, то отдадим его как есть в ответ
            data.p = this._options.data.p;
         }
         return new Deferred().callback(data);
      },
      update: function(args) {
         if (this._pkColumnIndex < 0) {
            return Deferred.fail(new Error(rk("Запрещено редактирование записей в списке без ключа")));
         }
         this._buildPkIndexIfNeeded();
         var record = args["Запись"][this._dataName],
             pk = record[this._pkColumnIndex],
             newRecord = this._pkIndex[pk] === undefined ? [] : this._data[this._pkIndex[pk]];
         for (var i = 0, l = this._columns.length; i < l; i++) {
            newRecord[i] = record[i];
         }
         if (this._pkIndex[newRecord[this._pkColumnIndex]] === undefined) {
            this._data.push(newRecord);
            this._pkIndex[newRecord[this._pkColumnIndex]] = this._data.length - 1;
         }
         return new Deferred().callback(newRecord[this._pkColumnIndex]);
      },
      destroy: function(args) {
         if (this._pkColumnIndex < 0) {
            return Deferred.fail(new Error(rk("Запрещено удаление записей в списке без ключа")));
         }
         this._buildPkIndexIfNeeded();
         var pk = args[this._pkName];
         if (this._pkIndex[pk] !== undefined) {
            this._data.splice(this._pkIndex[pk], 1);
         }
         this._refreshPkIndex();
         return new Deferred().callback(true);
      },
      read: function(args) {
         this._buildPkIndexIfNeeded();
         var pk = args[this._pkName],
             dataRow = this._data[this._pkIndex[pk]];
         return new Deferred().callback(this._getRecordByConfig(dataRow));
      },
      copy: function(args) {
         if (this._pkColumnIndex < 0) {
            return Deferred.fail(new Error(rk("Запрещено копирование записей в списке без ключа")));
         }
         var dResult = new Deferred(),
             self = this;
         this.read(args).addCallback(function(record) {
            record[self._dataName][self._pkColumnName] = null;
            dResult.callback(record);
            return record;
         });
         return dResult;
      },
      create: function(args) {
         if (this._pkColumnIndex < 0) {
            return Deferred.fail(new Error(rk("Запрещено создание записей в списке без ключа")));
         }
         return new Deferred().callback(this._getRecordByConfig(args && args["Фильтр"]));
      },
      /**
       * @param [dataRow] массив значений, по которым заполняем запись
       */
      _getRecordByConfig: function(dataRow) {
         var record = {},
             column = {},
             columnTitle,
             data,
             filterCols, filterData;
         if (Object.prototype.toString.call(dataRow) == "[object Object]") {
            filterCols = dataRow[this._columnsName];
            filterData = dataRow[this._dataName];
         }
         record[this._dataName] = [];
         record[this._columnsName] = this._columns;
         for (var i = 0, l = this._columns.length; i < l; i++) {
            column = this._columns[i];
            columnTitle = column[this._columnTitleName];
            data = null;
            if (Object.prototype.toString.call(dataRow) == "[object Object]") {
               for (var j = 0, len = filterCols.length; j < len; j++) {
                  if (filterCols[j][this._columnTitleName] == columnTitle && filterData[j] !== undefined) {
                     data = filterData[j];
                  }
               }
            } else if (Object.prototype.toString.call(dataRow) == "[object Array]") {
               if (dataRow[i] !== undefined) {
                  data = dataRow[i];
               }
            }
            record[this._dataName].push(data);
         }
         return record;
      },
      _buildPkIndexIfNeeded: function() {
         if (!this._pkIndex) {
            this._refreshPkIndex();
         }
      },
      /**
       * Прерывает загрузку
       */
      abort: function() {
      }
   });

   return TransportAdapterStatic;
});