/**
 * Created by aa.adilov on 08.04.14.
 */
define('Deprecated/Controls/FilterButton/plugins/RequestHistory-plugin', [
   'Core/helpers/String/escapeTagsFromStr',
   'Core/core-clone',
   'Core/core-instance',
   'Core/core-merge',
   'Deprecated/Record',
   'Deprecated/RecordSet',
   'Transport/serializeURLData',
   'Transport/deserializeURLData',
   'Core/helpers/Number/randomId',
   'Core/helpers/Function/forAliveOnly',
   'Core/UserConfig',
   'Core/ParallelDeferred',
   'Core/Deferred',
   'Core/constants',
   'Deprecated/Controls/FilterButton/FilterButton'
], function(
   escapeTagsFromStr,
   coreClone,
   cInstance,
   cMerge,
   dTransportRecord,
   dTransportRecordSet,
   serializeURLData,
   deserializeURLData,
   randomId,
   forAliveOnly,
   UserConfig,
   cParallelDeferred,
   cDeferred,
   cConstants,
   FilterButton
) {

   var MAX_HISTORY_REQUESTS = 10,
      MAX_MINIMIZE_HISTORY_REQUESTS = 3,
      MAX_HISTORY_BUTTON_TOOLTIP = 'Свернуть',
      MIN_HISTORY_BUTTON_TOOLTIP = 'Развернуть';

   /**
    * @class Deprecated/Controls/FilterButton/plugins/RequestHistory-plugin
    * @extends Deprecated/Controls/FilterButton/FilterButton
    * @author Крайнов Д.О.
    * @plugin
    * @public
    * @deprecated
    */
   FilterButton.RequestHistoryPlugin = FilterButton.extendPlugin(/** @lends Deprecated/Controls/FilterButton/plugins/RequestHistory-plugin.prototype */{
      /**
       * @event onCreateRequest Событие при добавлении запроса в историю
       * Если вернуть строку, то она будет представлена в истории вместо строки, сформированной по умолчанию
       * @param {Core/EventObject} eventObject Объект события
       * @param {Object} filter Объект с фильтром
       * @param {Object} stringFilter Фильтр со строковыми значениями
       * @example
       * <pre>
       *    filterButton.subscribe('onCreateRequest', function(e, filter, stringFilter) {
       *       var request = '';
       *
       *       for (var i in stringFilter) {
       *          if (stringFilter.hasOwnProperty(i)) {
       *             if (request) {
       *                request += ', ';
       *             }
       *
       *             request += i + ': ' + stringFilter[i];
       *          }
       *       }
       *
       *       e.setResult(request);
       *    });
       * </pre>
       */
      /**
       * @event onBeforeAddHistoryRequest Событие перед добавлением запроса в историю
       * @param {Core/EventObject} eventObject Объект события
       * @param {Object} filter Объект с фильтром
       * @param {Object} filters Объект с фильтрами, которые содержатся в текущей истории
       * @return {Object|Boolean|*} Если передать:
       * <ol>
       * <li>Object – станет новым фильтром,</li>
       * <li>false – запрос не добавится в историю,</li>
       * <li>любой иной тип данных – будет использован стандартный фильтр.</li>
       * </ol>
       * @example
       * <pre>
       *    filterButton.subscribe('onBeforeAddHistoryRequest', function(e, filter) {
       *       var newFilter = {};
       *       for (var i in filter) {
       *          if (filter.hasOwnProperty(i)) {
       *             if (filter[i] !== -1) {
       *                newFilter[i] = filter[i];
       *             }
       *          }
       *       }
       *
       *       e.setResult(newFilter);
       *    });
       * </pre>
       */
      /**
       * @event onBeforeHistoryRender Событие перед отрисовкой истории фильтров
       *  даёт возможность менять историю фильтров
       * @param {Core/EventObject} eventObject Объект события
       * @param {Object} history Объект с историей фильтров
       * @return {Object} история фильтров.
       * @example
       * <pre>
       *    FilterButton.subscribe('onBeforeHistoryRender', function(e, history) {
       *        history = {}; // do something with history
       *        e.setResult(history);
       *     });
       * </pre>
       */
      /**
       * @event onBeforeSaveHistory Событие перед сохранением текущего набора фильтров в историю
       * @param {Core/EventObject} eventObject Объект события
       * @param {Boolean} history Объект с историей фильтров
       * @param {Boolean} clear Происходит очистка фильтров
       * @example
       */
      $protected: {
         _options: {
            /**
            * @cfg {Boolean} Отображать ли историю выбора
            *
            * В истории отображаются ранее выбранные значения, по которым осуществлялась фильтрация.
            * При этом возможно отметить значения, нажав на иконку кнопки рядом. Значения с отметкой будут подняты в начало списка истории.
            * Возможные значения:
            * <ol>
            *    <li>true - показывать историю выбора. Отображение происходит во всплывающей панели, указанной в опции {@link  FilterButton#template template}.
            *    Панель при этом самостоятельно подстраивается по высоте в зависимости от количества записей в истории;</li>
            *    <li>false - не показывать историю.</li>
            * </ol>
            * @see setShowHistory
            * @see clearHistory
            */
            showHistory: false
         },
         _filterView: undefined,
         _filters: {},
         _history: {},
         _remember: [],
         _appliedRequest: undefined,
         _isRememberedFilter: false,
         _requestsView: undefined,
         _requestHistory: undefined,
         _minimizeIcon: undefined,
         _uniqueName: undefined,
         _userConfigParallelDeferred: undefined,
         _initWithBrowser: undefined,
         _historyRecordSet: undefined,
         _historyTitle: undefined
      },
      $condition: function() {
         return this._options.showHistory === true;
      },
      $constructor: function() {
         this._publish('onCreateRequest', 'onBeforeAddHistoryRequest', 'onBeforeHistoryRender', 'onBeforeSaveHistory');
         this._initWithBrowser = !!this._browser;
      },
      _createFloatArea: function() {
         var
            self = this;

         this._floatAreaDeferred.addCallback(function (floatArea) {
            self._requestsView = floatArea.getChildControlByName('requestsView');
            self._requestHistory = floatArea.getChildControlByName('requestHistory');
            self._minimizeIcon = floatArea.getChildControlByName('minimizeIcon');
            self._minimizeIcon.getContainer().parent().addClass('ws-FilterButton__minimizeContainer');
            self._minimizeIcon.subscribe('onActivated', function () {
               self._showMinimizeHistory();
            });
            self._historyTitle = floatArea.getContainer().find('.ws-filter-button-history-text');

            self._initHistoryEvents();

            if (self._initWithBrowser) {
               self._readUserConfig(floatArea);
            }

            return floatArea;
         });
      },
      _readUserConfig: function(floatArea) {
         var
            self = this,
            children,
            browser = this.getBrowser(),
            name;
         this._uniqueName = this.getName();
         if (cInstance.instanceOfModule(browser, 'Deprecated/Controls/DataViewAbstract/DataViewAbstract') && (name = browser.getName())) {
            this._uniqueName += ('-' + name);
         }

         if (cConstants.userConfigSupport) {
            self._userConfigParallelDeferred = new cParallelDeferred();
            self._userConfigParallelDeferred.push(
               UserConfig.getParam(self._uniqueName + '-historyFilters').addCallback(function(result){
                  if (!self.isDestroyed()) {
                     var history = typeof(result) == 'string' ? deserializeURLData(result) : {};
                     self._history = history instanceof Object ? history : {};
                  }
               })
            );
            self._userConfigParallelDeferred.push(
               UserConfig.getParam(self._uniqueName + '-historyData').addCallback(function(result){
                  if (!self.isDestroyed()) {
                     self._historyRecordSet = typeof(result) === 'string' ? self._createHistoryRecordSet(deserializeURLData(result)) : self._createHistoryRecordSet();
                  }
               })
            );

            children = floatArea.getChildControls();

            for (var i = 0, l = children.length; i < l; i++) {
               if (cInstance.instanceOfModule(children[i], 'Deprecated/Controls/FilterView/FilterView')) {
                  self._filterView = children[i];
                  break;
               }
            }
            if (self._filterView) {
               self._userConfigParallelDeferred.push(
                  UserConfig.getParam(self._uniqueName + '-filterViewData').addCallback(function(result){
                     if (!self.isDestroyed()) {
                        var filters = typeof(result) == 'string' ? deserializeURLData(result) : {};
                        self._filters = filters instanceof Object ? filters : {};
                     }
                  })
               );
            }
            self._userConfigParallelDeferred.push(
               UserConfig.getParam(self._uniqueName + '-rememberData').addCallback(function(result){
                  if (!self.isDestroyed()) {
                     var remember = typeof(result) == 'string' ? deserializeURLData(result) : [];
                     self._remember = Array.isArray(remember) ? remember : [];
                  }
               })
            );
            self._userConfigParallelDeferred.done().getResult().addCallback(forAliveOnly(function(){
               var
                  filterIds = [],
                  filterId,
                  newHistory,
                  recordsCount;

               newHistory = self._notify('onBeforeHistoryRender', coreClone(self._history));
               if ($.isPlainObject(newHistory)) {
                  self._history = newHistory;
                  /**
                   * пока что проверяется только удаление из history
                   * проверим не удалялись ли записи из history
                   * если удалялись то удалить их из self._historyRecordSet
                   **/
                  self._historyRecordSet.each(function(k) {
                     filterId = k.getKey();
                     if (!self._history.hasOwnProperty(filterId)) {
                        filterIds.push(k.getKey());
                     }
                  });

                  self._historyRecordSet.deleteRecords(filterIds);
               }
               recordsCount =  self._historyRecordSet.getRecordCount();
               self._requestsView.setData(self._historyRecordSet, true);
               self._saveHistory();
               if (recordsCount > 0) {
                  if (recordsCount > MAX_MINIMIZE_HISTORY_REQUESTS) {
                     self._showMinimizeHistory();
                     self._setShowHistoryButtonsEnabled(true);
                  }
                  self._showHistoryTemplate();
               } else {
                  self._hideHistoryTemplate();
               }
               self._restructRemembers();
            }, self));
         }
         return floatArea;
      },
      _createHistoryRecordSet: function(data) {
         data = data || {
            s: this._requestsView.getRecordSet().getColumnsForSerialize(),
            d: []
         };
         var firstColumn = data.s[0];
         return new dTransportRecordSet({
            readerType: 'ReaderSBIS',
            readerParams: {
               pkColumnName: firstColumn ? firstColumn.n : undefined,
               adapterType : 'TransportAdapterStatic',
               adapterParams: {
                  data : data
               }
            }
         });
      },
      _showHistoryTemplate: function() {
         this._manipulateHistoryTemplate(true);
      },
      _hideHistoryTemplate: function() {
         this._manipulateHistoryTemplate(false);
      },
      _manipulateHistoryTemplate: function(toShow){
         this._requestHistory.toggle(toShow);
      },
      _addHistoryRequest: function(request, filter, stringFilter) {
         var onCreateRequestResult,
            requestsContainer,
            currentRecordSet,
            recordCount,
            deleteRowKey,
            newKey,
            self;

         if (request) {
            requestsContainer = this._requestsView.getContainer();
            currentRecordSet = this._requestsView.getRecordSet();
            recordCount = currentRecordSet.getRecordCount();
            self = this;

            this._showHistoryTemplate();

            if (this._requestsView.isMinimized()) {
               this._requestsView.showSelection(false);
               currentRecordSet = this._requestsView.getRecordSet();
               recordCount = currentRecordSet.getRecordCount();
            }

            if (recordCount === MAX_HISTORY_REQUESTS) {
               if (requestsContainer.find('.ws-FilterButton__request-remembered').length === MAX_HISTORY_REQUESTS) {
                  this._showMinimizeHistory();

                  return;
               }

               deleteRowKey = requestsContainer.find('[rowkey]:last').attr('rowkey');
               delete this._history[deleteRowKey];
               delete this._filters[deleteRowKey];
               currentRecordSet.clearRecord(deleteRowKey);
               this._requestsView.refresh();
            }

            onCreateRequestResult = this._notify('onCreateRequest', coreClone(filter), stringFilter);

            if (typeof onCreateRequestResult === 'string') {
               request = onCreateRequestResult;
            }

            newKey = randomId();
            currentRecordSet.createRecord({
               key: newKey,
               request: request,
               isRemembered: false
            }).addCallback(function(record) {
               var tmpArr = [],
                  data = [],
                  badValues =  {
                     'parent': true,
                     'element': true,
                     'context': true,
                     'linkedContext': true
                  },
                  query,
                  cfg;
               currentRecordSet.insertAfter(self._getKeyToInsertAfter(record.getKey(), true), record);

               self._history[newKey] = coreClone(filter);
               //Будем хранить даты в SQL формате, чтобы при отдаче их на сериализацию JSON.stringify верно их преобразовывал
               //Иначе дата 01.01.YYYY 00:00:00 преобразуется в 31.12.YYYY 00:00:00
               for (var key in self._history[newKey]) {
                  if (self._history[newKey].hasOwnProperty(key)) {
                     var
                        value = self._history[newKey][key];
                     if (value instanceof Date) {
                        self._history[newKey][key] = value.toSQL(true);
                     }
                  }
               }

               if (self._filterView && !self._filterView.isDestroyed()) {
                  tmpArr = self._filterView.getFiltersData();
                  query = self._filterView.getQuery();
                  for (var i = 0, l = tmpArr.length; i < l; i++) {
                     if (tmpArr[i].hasOwnProperty('config')) {
                        //При сериализации получаем ошибку циклических зависимостей
                        //Куча кода, потому что мы не можем удалить из объекта с фильтрами ничего, так как
                        //они переданы по ссылке, а клонировать контекст мы не можем
                        cfg =  tmpArr[i].config[1];
                        data.push({
                           'title': tmpArr[i].title,
                           'config': []
                        });
                        data[i].config.push(tmpArr[i].config[0]);
                        data[i].config.push({});
                        for (var j in cfg) {
                           if (cfg.hasOwnProperty(j)) {
                              if (!badValues[j]) {
                                 data[i].config[1][j] = cfg[j];
                              }
                           }
                        }
                        data[i].value = query[data[i].title];
                     } else {
                        data.push(tmpArr[i]);
                     }
                  }

                  self._filters[newKey] = data;
               }
               self._saveHistory();
               self._showMinimizeHistory();
               if (recordCount === MAX_MINIMIZE_HISTORY_REQUESTS) {
                  self._setShowHistoryButtonsEnabled(true);
               }
            });
         }
      },

      _setShowHistoryButtonsEnabled: function(enable) {
         this._minimizeIcon.setEnabled(enable);
         this._historyTitle.toggleClass('ws-filter-button-history-text-enabled', enable);
      },

      _initHistoryEvents: function() {
         var self = this,
            floatAreaCont = this._floatArea.getContainer(),
            parentCont = $(floatAreaCont[0]);

         floatAreaCont.find('.ws-filter-button-history-text').click(this._showMinimizeHistory.bind(this));

         parentCont.on('mouseup', '.ws-FilterButton__historyIcon', this._rememberRequest.bind(this));
         parentCont.on('mouseenter mouseleave', '.ws-FilterButton__request', this._hoverRequest.bind(this));

         this._requestsView.subscribe('onRowClick', this._applyRequest.bind(this));
         this._floatArea.subscribe('onAfterClose', this._restructRemembers.bind(this));
      },
      _hoverRequest: function(e) {
         var target = $(e.currentTarget);

         if (!target.hasClass('ws-FilterButton__request-remembered')) {
            target.find('.ws-FilterButton__historyIcon').toggleClass('icon-Pin icon-disabled', e.type === 'mouseenter');
         }
      },
      /**
        *
        * Очистить историю выбора.
        * @example
        * <pre>
        *     btn.subscribe('onActivated', function(){
        *        //Очистить историю запросов по клику на кнопку
        *        filterButton.clearHistory();
        *     });
        * </pre>
        * @see showHistory
        * @see setShowHistory
        */
      clearHistory: function() {
         if (this._options.showHistory) {
            if (this._requestsView.isMinimized()) {
               this._showMinimizeHistory();
               this._setShowHistoryButtonsEnabled(false);
               this._toggleMinimizeIcon(true);
            }
            this._hideHistoryTemplate();
            this._history = {};
            this._filters = {};
            this._remember = [];
            this._clearHistory();
            this._requestsView.setData(this._createHistoryRecordSet());
         }
      },
      _clearHistory: function() {
         this._saveHistory(true);
      },
      /**
        *
        * Установить отображение истории выбора.
        * @example
        * <pre>
        *     switcher.subscribe('onChange', function(e, value){
        *        //Показать или скрыть историю запросов в зависимости от состояния переключателя
        *        filterButton.setShowHistory(value);
        *     });
        * </pre>
        * @param value
        * @see showHistory
        * @see clearHistory
        */
      setShowHistory: function(value) {
         var show = !!value;
         if (!show) {
            this.clearHistory();
         }
         this._options.showHistory = show;
      },
      _showMinimizeHistory: function() {
         var records = this._requestsView.getRecordSet().getRecords(),
            count = records.length,
            isMinimize = this._requestsView.isMinimized(),
            keys = [];
         if (isMinimize) {
            this._requestsView.showSelection(false);
            this._requestsView.removeSelection();
         } else if (count > MAX_MINIMIZE_HISTORY_REQUESTS) {
            for (var i = 0; i < MAX_MINIMIZE_HISTORY_REQUESTS; i++) {
               keys.push(records[i].getKey());
            }
            this._requestsView.removeSelection();
            this._requestsView.setSelection(keys);
            this._requestsView.showSelection(true);
         } else if(!isMinimize && (count <= MAX_MINIMIZE_HISTORY_REQUESTS)) {
            this._toggleMinimizeIcon(isMinimize);
            return;
         }
         this._toggleMinimizeIcon(!isMinimize);
      },
      _getKeyToInsertAfter: function(rowKey, isRequestRemembered) {
         var requestsContainer = this._requestsView.getContainer(),
            rememberedRequests = requestsContainer.find('.ws-FilterButton__request-remembered'),
            insertAfterKey, lastRememberKey;
         if (isRequestRemembered && rememberedRequests.length > 0) {
            lastRememberKey = $(rememberedRequests[rememberedRequests.length - 1]).attr('rowkey');
            insertAfterKey = rowKey === lastRememberKey ? requestsContainer.find('[rowkey='+rowKey+']').prev().attr('rowkey') : lastRememberKey;
         }
         return insertAfterKey;
      },
      _toggleMinimizeIcon: function(isExpand) {
         var buttonContainer = this._minimizeIcon.getContainer();

         this._minimizeIcon.setTooltip(!isExpand ? MAX_HISTORY_BUTTON_TOOLTIP : MIN_HISTORY_BUTTON_TOOLTIP);
         buttonContainer.toggleClass('ws-FilterButton__minimizeIcon__iconExpand', isExpand)
            .toggleClass('ws-FilterButton__minimizeIcon__iconClose', !isExpand);
      },
      _restructRemembers: function() {
         if (this._options.showHistory && (this._remember && this._remember.length || this._appliedRequest)) {
            var record,
               pk,
               contains = {},
               rs = this._requestsView.getRecordSet();
            if (this._requestsView.isMinimized()) {
               this._requestsView.showSelection(false);
               rs = this._requestsView.getRecordSet();
            }
            if (this._remember && this._remember.length) {
               this._remember.forEach(function (pk) {
                  contains[pk] = !contains[pk];
               });
               while ((pk = this._remember.shift())) {
                  if (contains[pk]) {
                     contains[pk] = false; //чтобы не повторять действия для Record'ов которые входят 3, 5, 7... раз
                     record = rs.getRecordByPrimaryKey(pk);
                     rs.clearRecord(record._pkValue);
                     rs.insertAfter(this._getKeyToInsertAfter(record._pkValue, !record.get('isRemembered')), record);
                  }
               }
            }
            if (this._appliedRequest instanceof dTransportRecord) {
               rs.clearRecord(this._appliedRequest._pkValue);
               rs.insertAfter(this._getKeyToInsertAfter(this._appliedRequest._pkValue, !this._appliedRequest.get('isRemembered')), this._appliedRequest);
               this._appliedRequest = undefined;
            }

            this._saveHistory();
         }
         if (this._options.showHistory && this._requestsView) {
            if (!this._requestsView.isMinimized()) {
               this._showMinimizeHistory();
            }
         }
      },
      _rememberRequest: function(event) {
         var wasMinimized = this._requestsView.isMinimized(),
            row = $(event.currentTarget).closest('.ws-FilterButton__request'),
            isRequestRemembered = row.hasClass('ws-FilterButton__request-remembered'),
            rowKey = row.attr('rowkey'),
            rs = this._requestsView.getRecordSet(),
            record = rs.getRecordByPrimaryKey(rowKey);

         this._remember.push(rowKey);
         if (wasMinimized) {
            this._requestsView.showSelection(false);
         }
         record.set('isRemembered', !isRequestRemembered);
         this._saveHistory();
         if (wasMinimized) {
            this._showMinimizeHistory();
         }
         this._requestsView.removeSelection();
         this._requestsView.refresh();
      },
      _applyRequest: function(event, row, record) {
         var self = this,
            result;
         if (!this._filterSetted) {
            var key = record.getKey(),
               query = coreClone(this._history[key]);
            this._isRememberedFilter = true;
            if (this._filterView && !this._filterView.isDestroyed()) {
               var filter = this._filters[key] || [],
                  filters = [];
               //Обновляем фильтры кнопки фильтров, ибо могут закрасться старые плохие значение, происходит зацикливание
               this._filter = cMerge(this._filter, this._history[key]);
               for (var i = 0, l = filter.length; i < l; i++) {
                  filters.push(coreClone(filter[i]));
               }
               //Здесь все может сломаться, но фильтры и так заполнены, setValue только множит запросы
               //this._filterView.getLinkedContext().setValue(query);
               result = this._filterView.setFiltersData(filters);
            }
            cDeferred.callbackWrapper(result,
               function(){
                  self._setControlsValues(query);
                  self.applyFilter();
                  if (self._floatArea) {
                     self._floatArea.hide();
                  }
                  self._appliedRequest = record;
                  self._requestsView.removeSelection();
               });
         }
      },
      _processData: function(data, filter, stringFilter) {
         var
            requestText,
            isNewRequest,
            self = this,
            settedFilter,
            settedFilterClone,
            currentFilterInBrowser;

         if (cConstants.userConfigSupport && this._userConfigParallelDeferred && !this._userConfigParallelDeferred.getResult().isReady()) {
            return;
         }
         if (this._browser) {
            if (!self._isRememberedFilter) {
               currentFilterInBrowser = coreClone(self._browser._currentFilterBeforeChange);
               settedFilterClone = coreClone(filter);
               //Вмерживать нужно именно settedFilterClone в currentFilterInBrowser т.к. в settedFilterClone лежат новые значения, которые должны перебить старые.
               settedFilterClone = cMerge(currentFilterInBrowser, settedFilterClone);
               settedFilter = self._notify('onBeforeAddHistoryRequest', coreClone(settedFilterClone), coreClone(self._history));
               if (settedFilter !== false) {
                  if (!(settedFilter instanceof Object)) {
                     settedFilter = settedFilterClone;
                  }
                  data = self._prepareData(self._getTextFromFilter(settedFilter, stringFilter));

                  if (data) {
                     isNewRequest = true;
                     requestText = self._getStringRequest(settedFilter);

                     for (var i in self._history) {
                        if (self._history.hasOwnProperty(i) && requestText === self._getStringRequest(self._history[i])) {
                           isNewRequest = false;
                           break;
                        }
                     }

                     if (isNewRequest) {
                        self._addHistoryRequest(data, settedFilter, stringFilter);
                     }
                  }
               }
            } else {
               self._isRememberedFilter = false;
            }
         }
      },
      _getStringRequest: function(filter) {
         var keys = Object.keys(filter).sort(),
            sortedFilter = {},
            key;

         for (var i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            if (filter[key] instanceof Array) {
               sortedFilter[key] = filter[key].sort();
            } else {
               sortedFilter[key] = filter[key];
            }
         }
         /* Хак для испрвления даты, метод stringify сериализует дату, учитывая сдвиг (GMT/UTC)
             и в итоге мы можем получить не ту дату */
         return JSON.stringify(sortedFilter, function(key, value) {
            if(sortedFilter[key] instanceof Date) {
               return String(sortedFilter[key].toSQL(true));
            }
            return value;
         });
      },
      _prepareData: function(data) {
         if (data instanceof $) {
            data = data.text();
         }

         return escapeTagsFromStr(data, []).trim();
      },
      _saveHistory: function(toClear) {
         var dResult,
            hasFilterView,
            historyFilters,
            filterViewData,
            historyData,
            rememberData,
            result;

         if (cConstants.userConfigSupport && this._notify('onBeforeSaveHistory', this._history, !!toClear) !== false) {
            dResult = new cParallelDeferred();
            hasFilterView = this._filterView && !this._filterView.isDestroyed();
            historyFilters = serializeURLData(this._history);
            filterViewData = serializeURLData(this._filters);
            historyData = serializeURLData(this._requestsView.getRecordSet());
            rememberData = serializeURLData(this._remember);
            if (toClear) {
               historyFilters = null;
               historyData = null;
               filterViewData = null;
               rememberData = null;
            }
            dResult.push(UserConfig.setParam(this._uniqueName + '-historyFilters', historyFilters));
            dResult.push(UserConfig.setParam(this._uniqueName + '-historyData', historyData));
            dResult.push(UserConfig.setParam(this._uniqueName + '-rememberData', rememberData));
            if (hasFilterView) {
               dResult.push(UserConfig.setParam(this._uniqueName + '-filterViewData', filterViewData));
            }
            dResult.done();
            result = dResult.getResult();
         }
         return result;
      },
      _restructHistory: function() {
         var
            self = this;
         this._floatAreaReady.wait(new cDeferred().addCallback(function() {
            if (self._floatArea) {
               if (self._initWithBrowser === false || (self._initWithBrowser === undefined && !self._browser)) {
                  self._readUserConfig(self._floatArea);
               }
            } else {
               self._initWithBrowser = true;
            }
         }));
      },
      destroy: function() {
         this._history = undefined;
         this._remember = undefined;
         this._filters = undefined;
         this._filterView = undefined;
         this._requestsView = undefined;
         this._requestHistory = undefined;
         this._minimizeIcon = undefined;
         this._userConfigParallelDeferred = undefined;
         this._initWithBrowser = undefined;
      }
   });
});
