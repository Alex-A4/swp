/**
 * Created with JetBrains PhpStorm.
 * User: tm.baeva
 * Date: 21.04.13
 * Time: 18:38
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/FieldDropdown/FieldDropdown', [
   'Core/helpers/String/escapeHtml',
   'Core/core-merge',
   'Deprecated/RecordSet',
   'Core/helpers/Hcontrol/getScrollWidth',
   'Core/helpers/Hcontrol/trackElement',
   'Core/helpers/getType',
   'Core/WindowManager',
   'Core/moduleStubs',
   'Core/IoC',
   'Core/Deferred',
   'Deprecated/Enum',
   'Core/constants',
   'Deprecated/Controls/FieldAbstract/FieldAbstract',
   'Lib/Type/TDataSource/TDataSource',
   'html!Deprecated/Controls/FieldDropdown/FieldDropdown',
   'Transport/HTTPError',
   'Core/detection',
   'css!Deprecated/Controls/FieldDropdown/FieldDropdown',
   'is!browser?/cdn/jquery-ui/1.12.1.2/jquery-ui-position-min.js',
   'i18n!Deprecated/Controls/FieldDropdown/FieldDropdown'
], function(
   escapeHtml,
   cMerge,
   dTransportRecordSet,
   getScrollWidth,
   trackElement,
   getType,
   WindowManager,
   moduleStubs,
   IoC,
   cDeferred,
   dEnum,
   cConstants,
   FieldAbstract,
   TDataSource,
   dotTplFn,
   HTTPError
) {

   'use strict';

   var
      BORDER_SIZE = 2,
      MAX_HEIGHT = 300,
      MAX_WIDTH_HOVER_STYLE = 650,
      ROUNDING_WIDTH = 11,
      EMPTY_TEXT = rk('Не выбрано'),
      position = {
         my : {
            standard:   'left top-1',
            simple:     'left-2 top-4',
            hover:      'left-6 top-3'
         },
         at : {
            standard:   'left bottom',
            simple:     'left top',
            hover:      'left top'
         }
      };

   /**
    * Выпадающий список.
    *
    * Добавлен управлящий класс .ws-dropdown-fixed-width, фиксирующий ширину выпадающего списка даже при длинных значениях.
    * При этом у не поместившихся значений добавляется троеточие в конце и тултип с полным сообщением.
    * @public
    * @class Deprecated/Controls/FieldDropdown/FieldDropdown
    * @extends Deprecated/Controls/FieldAbstract/FieldAbstract
    * @author Крайнов Д.О.
    * @control
    * @initial
    * <component data-component='Deprecated/Controls/FieldDropdown/FieldDropdown'></component>
    * @category Select
    * @designTime actions Deprecated/Controls/FieldString/design/design
    * @designTime plugin /design/DesignPlugin
    * @ignoreOptions width
    * @deprecated Используйте классы {@link SBIS3.CONTROLS/ComboBox} или {@link SBIS3.CONTROLS.DropDownList}.
    */
   var FieldDropdown = FieldAbstract.extend(/** @lends Deprecated/Controls/FieldDropdown/FieldDropdown.prototype */{
      /**
       * @event onAfterLoad При окончании загрузки
       * Событие, извещающее об окончании загрузки из внешнего источника {@link dataSource}.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Boolean} isSuccess Успешна ли загрузка. true - успех.
       * @param {Object} data Полученные данные или объект ошибки в случае не успеха.
       * @example
       * <pre>
       *    dropdown.subscribe('onAfterLoad', function(event, success, data) {
       *       if (success) {
       *          if(this.getKeys().indexOf(48) !== -1) {
       *             this.insertOption(56, this.getValueByKey(48));
       *             this.removeOption(48);
       *          }
       *       }
       *    });
       * </pre>
       * @see dataSource
       */
      /**
       * @event onBeforeLoad Перед началом загрузки
       * Событие, извещающее о начале загрузки.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    dropdown.subscribe('onBeforeLoad', function(event) {
       *       helpers.message('Началась загрузка выпадающего списка!');
       *    });
       * </pre>
       */
      /**
       * @event onClickMore При клике по системной опции 'hasMore' (текст "Еще...") выпадающего списка.
       * Актуально только(!) для renderStyleHover = 'hover'
       * Опция не устанвливается в качестве выбранной. Используется в {@link Deprecated/Controls/PathFilter/PathFilter}
       * @param {Core/EventObject} eventObject Дескриптор события.
       */
      $protected: {
         _recordSet: null,
         _initialFilter: {},
         _options: {
            /**
             * @cfg {Boolean} Разрешить пустое значение
             *
             * Добавить значение null в выборку в режиме 'Источник данных'.
             * @see emptyValue
             * @see setEmptyValue
             */
            allowEmpty: false,
            /**
             * @cfg {String} Текст пустого значения
             *
             * Текст, отображаемый в null-опции при активированной опции allowEmpty.
             * @see isAllowEmpty
             * @see setAllowEmpty
             * @translatable
             * @see allowEmpty
             * @see setEmptyValue
             */
            emptyValue: '',
            /**
             * @typedef {Object} FilterParam
             * @property {string} fieldName Имя поля
             * @property {boolean} [autoreload=true] Перезагружать данные при изменении поля в контексте
             */
            /**
             * @cfg {Object.<string, boolean|number|string|FilterParam>} Параметры фильтрации списочного метода бизнес-логики
             *
             * Параметры, использующиеся для фильтрации данных при запросе их из внешних источников.
             * Могут иметь константное значение, являться результатом вызова обработчика или быть полем текущего контекста.
             * <pre>
             *    filterParams : {
             *       "Подразделение" : "Управление",
             *       "УчетныйГод" : function() {
             *          return (new Date).getFullYear();
             *       },
             *       "Сотрудник" : {
             *          "fieldName" : "Запись.ФиоСотрудника"
             *       }
             *    }
             * </pre>
             * @group Data
             */
            filterParams: {},
            /**
             * @cfg {Object} Источник данных
             *
             * Описание внешнего источника данных:
             * 1. источник статических данных;
             * 2. источник динамических данных (метод бизнес-логики);
             * @example
             * Пример задания источника динамических данных:
             * <pre>
             *     dataSource : {
             *        firstRequest : true,
             *        readerParams : {
             *           queryName : "Список",
             *           linkedObject : "СвязанныйОбъект",
             *           format : "БазовоеРасширение"
             *        }
             *     }
             * </pre>
             * @see data
             * @see mode
             * @see onAfterLoad
             * @editor TDataSourceEditorNoMethods
             * @group Data
             */
            dataSource: TDataSource,
            /**
             * @cfg {Function} Пользовательская функция рендеринга отображаемого значения
             *
             */
            // TODO описание, пример
            valueRender: '',
            /**
             * @cfg {Function} Функция рендеринга значения в контейнере выпадающего списка
             */
            titleRender: '',
            /**
             * @cfg {String} Колонка записи, используемая для отображения
             *
             * Данный параметр отвечает за текст, отображаемый в выпадающем списке.
             * Определяет колонку данных, из которой будет заполняться этот текст.
             * Работает при взятии данных с {@link dataSource}.
             * @see dataSource
             * @see mode
             * @see getDisplayColumn
             * @see setDisplayColumn
             * @group Data
             * @editor BLFieldsChooser
             */
            displayColumn: '',
            /**
             * @typedef {Object} Elements
             * @property {String} key ключ
             * @property {String} value значение
             * @translatable value
             */
            /**
             * @cfg {Elements[]} Данные, доступные для выбора из выпадающего списка
             *
             * Опция не используется в режимах month и year. Подробнее смотреть в {@link mode}.
             * Задаётся в виде [{key : <ключ1>, value : <значение1>}, {key : <ключ2>, value : <значение2>}, ...]
             * @example
             * <pre>
             *     <options name='data' type='array'>
             *        <options>
             *           <option name='key' value='ДЕТИ'></option>
             *           <option name='value' value='ДЕТИ'></option>
             *        </options>
             *        <options>
             *           <option name='key' value='ДЕКРЕТ'></option>
             *           <option name='value' value='ДЕКРЕТ'></option>
             *        </options>
             *        <options>
             *           <option name='key' value='ДОГОВОР'></option>
             *           <option name='value' value='ДОГОВОР'></option>
             *        </options>
             *     </options>
             * </pre>
             * @see setData
             * @see dataSource
             * @see mode
             * @group Data
             */
            data: '',
            //TODO FieldDropdown ширина в IE с px не поддерживается(падает).
            /**
             * @cfg {String} Ширина
             *
             * В FieldDropdown при определении ширины как string(с px), в IE падает.
             * @noShow
             */
            width: '100px',
            /**
             * @cfg {String} Режим отображения данных
             *
             * Если передать '' или не передать вовсе, то поиск данных пойдёт по пути:
             * <ol>
             * <li> сначала {@link data},</li>
             * <li> затем {@link dataSource} - внешний источник данных/метод бизнес-логики.</li>
             * </ol>
             * @see data
             * @see dataSource
             * @see firstYear
             * @see lastYear
             * @variant month отображать список месяцев
             * @variant year отображать диапазон лет
             * @variant '' для всех остальных режимов
             */
            mode: '',
            /**
             * @cfg {String} Колонка записи, используемая как ключ элемента списка
             *
             * Данный параметр отвечает за значения элементов выпадающего списка.
             * Определяет колонку данных, из которой будут браться эти значения.
             * @see getItemValueColumn
             * @see setItemValueColumn
             * @group Data
             * @editor BLFieldsChooser
             */
            itemValueColumn: '',
            /**
             * @cfg {Boolean} Разрешить перенос текста
             *
             */
            wordWrap: false,
            /**
             * @cfg {Number} Первый отображаемый год
             *
             * Год, с которого начинается диапазон лет.
             * Используется в режиме отображения year.
             * @see mode
             */
            firstYear: 2008,
            /**
             * @cfg {Number} Последний отображаемый год
             *
             * При значении 0 устанавливается текущий год.
             * Используется в режиме отображения year.
             * @see mode
             */
            lastYear : 0,
            /**
             * @cfg {Boolean} Обязательно ли выбирать значение (+ нельзя выбрать пустое значение)
             */
            required: false,
            /**
             * @cfg {String} Отображение             
             *
             * @variant standard обычный select
             * @variant simple упрощеный вариант в виде ссылки
             * @variant hover список показывается при наведении
             */
            renderStyle: 'standard',
            /**
             * @cfg {Boolean} Показывать ли текущий элемент в общем списке
             *
             */
            showSelectedInList: true,
            /**
             * @cfg {Boolean} Показывать ли подсказку в шапке выпадающего списка. Опция актуально только для renderStyle = 'Hover
             *
             */
            showTooltip : false,
            /**
             * @cfg {Boolean} Переворачивать выпадающий список, если не влазит в границу экрана
             *
             */
            flipVertical: false
         },
         _menuTarget: undefined,
         _enum: '',
         _desiredDefaultValue: '',
         _dSetReady: '',
         _valueSet: false,
         _optCont: null,
         _optContHead: null,
         _optContList: null,
         _optArrow: undefined,
         _lastQueryFilter: undefined,
         _emptyInit: false,
         _hovered: false,
         _fKeyType: '',
         _dataType: '',
         _zIndex: undefined,
         _hoverenOnChild: false
      },
      $constructor: function(){
         this._configChecking();
         this._publish('onAfterLoad', 'onBeforeLoad', 'onClickMore', 'onClickDefault');
         this._createLoadingIndicator();
         this._dSetReady = this._prepareDeferredChain();
         this._initialFilter = cMerge({}, this._options.filterParams);
         this._lastQueryFilter = this._initialFilter;
         var
            data = this._options.data,
            isUserData = this._isDataNotEmpty(data),
            self = this;
         // Взводим переменную allowEmpty если в пользовательских данных есть строка с ключем null
         if (isUserData) {
            data = this._options.data = this._convertDataToExpectedFormat(data);
            var keys = data.keys;
            for (var i = 0, l = keys.length; i < l; i++) {
               if (keys[i] === null) {
                  if (!this.isAllowEmpty() && this.getEmptyValue()) {
                     this.setAllowEmpty(true);
                  }
               } else if (typeof keys[i] !== 'string') {
                  keys[i] = keys[i].toString();
               }
            }
         }
         this._container
            .attr('title', this._options.tooltip)
            .css('width', this._options.width + 'px')
            .find('.ws-field')
            .addClass('ws-field-dropdown');
         if (cConstants.browser.isMobilePlatform) {
            if (this.isHover()) {
               // скрываем нативные списки если смотрим на мобильных устройствах в режиме hover
               this._container.addClass('ws-mobile');
            } else {
               this._container.find('.ws-native-select')
                  .height(this._container.height())
               //иначе стрелочка окажется выше селекта и он не откроется по клику
                  .css('z-index', 1);
            }
         }
         this._inputControl.css('width', this._options.width + 'px');
         this._initializeContent();
         this._bindEvents();
         this.subscribe('onAfterLoad', function() {
            self._fillDropdown();
            self._dSetReady.addCallback(function(d) {
               self._changeFunc(self._inputControl[0]);
               return d;
            });
         });
      },
      _isDataNotEmpty: function(data) {
         return $.isPlainObject(data) && !Object.isEmpty(data) || Array.isArray(data) && data.length;
      },
      _bindEvents: function() {
         var
            self = this,
            container = this._container,
            customSelect = container.find('.custom-select');
         this._optCont
            .mousedown(function(e){
               //Это нужно, чтобы на optCont не уходил фокус, и у FieldDropdown не
               //вызывалось бы setActive(false) из-за этого, поскольку на setActive(false)
               //FieldDropdown делает закрытие без выбора, а выбор делает на клик по _optCont.
               e.preventDefault();
               e.stopImmediatePropagation();
            })
            .bind('mousewheel', function(event){
               event.stopPropagation();
               return true;
            });
         customSelect
            .mousedown(function(e) {
               if (!self._optCont.hasClass('ws-hidden')) {
                  e.stopImmediatePropagation();
               }
            })
            .click(function(){
               if (!container.hasClass('ws-disabled')){
                  self._inputControl.focus();
                  self._showAndPlace();
               }
            });
         if (typeof this.getValueRender() !== 'function' && this.getRenderStyle() === 'simple') {
            this._optContList.addClass('ws-custom-options-border');
         }
         if (this.isHover()) {
            customSelect
               .mouseenter(function(){
                  if (!container.hasClass('ws-disabled')){
                     self._showAndPlace();
                  }
               })
               .mouseleave(function(){
                  self._hideOptionsAfterTimeout();
               });
            this._optContList
               .mouseleave(function(e){
                  var
                     targetContol = $(e.relatedTarget).wsControl() ? $(e.relatedTarget).wsControl().getTopParent() : undefined;
                  if (!cConstants.browser.isMobileSafari || self._optContList.closest(this).length === 0) {
                     self._hideOptionsAfterTimeout();
                  }
                  if (targetContol && targetContol._opener == self) {
                     self._hovered = true;
                     self._hoverenOnChild = true;
                     targetContol.once('onAfterClose', function(e){
                        if (self._hoverenOnChild) {
                           self._hideOptionsAfterTimeout();
                        }
                     });
                  }
               })
               .mouseenter(function(){
                  self._hovered = true;
                  self._hoverenOnChild = false;
               });
            this._optContHead
               .mouseleave(function(){
                  self._hideOptionsAfterTimeout();
               })
               .mouseenter(function(){
                  self._hovered = true;
                  self._hoverenOnChild = false;
               });
         }
         $(document).bind('mousedown.' + this.getId() + ' wsmousedown.' + this.getId(), function() {
            if (self._optCont) {
               self._hideOptions();
            }
         });
         self._container.bind('keydown', function(e) {
            if (e.which == cConstants.key.esc && self._optCont && !self._optCont.hasClass('ws-hidden')) {
               self._hideOptions();
               e.stopImmediatePropagation();
            } else if (e.altKey && (e.keyCode == cConstants.key.down || e.keyCode == cConstants.key.up)) {
               if (self.isEnabled() && self._optCont && self._optCont.hasClass('ws-hidden')) {
                  self._showAndPlace();
               }
               return false;
            } else if (e.keyCode == cConstants.key.enter && !e.ctrlKey && !e.altKey && !e.shiftKey) {
               return false;
            }
         });
         this._inputControl
            .blur(function(){
               if (!self.isActive()) {
                  self._hideOptions();
               }
            })
            .bind('change.themed keypress keyup',function() {
               if (!self._options.showSelectedInList)
                  self._fillDropdown();
               self._changeFunc(this);
               // скрываем контейнер выпадающего списка, если он открыт и мы начинаем перебирать стрелками значения
               self._hideOptions();
               self._notifyOnSizeChanged();
            });
      },

      _hoverOption: function(keyCode) {
         // двигаемся по селекту
         var listElems = $(this._optContList.find('.custom-select-option')),
            hoveredElem = $(this._optContList.find('.custom-select-option-hover')),
            startElem, nextElem;
         if (!hoveredElem.length) {
            startElem = keyCode == cConstants.key.down ? $(listElems[0]) : $(listElems[listElems.length-1]);
            listElems.removeClass('custom-select-option-hover');
            startElem.toggleClass("custom-select-option-hover");
         }
         else {
            nextElem = keyCode == cConstants.key.down ? hoveredElem.next() : hoveredElem.prev();
            if (nextElem.length) {
               listElems.removeClass('custom-select-option-hover');
               nextElem.toggleClass("custom-select-option-hover");
            }
         }
      },

      /**
        * устанавливает/убирает класс текущей строки для переданной
        * @param {jQuery} selectedOpt выбранный элемент списка
        * @param {Boolean} hasScrollbar имеет ли список список вертикальный скроллбар
        * @param {Number} scrollWidth Ширина горизонтального скролла браузера
        * @private
        */
      _getMinWidth: function(selectedOpt, hasScrollbar, scrollWidth) {
         return selectedOpt.parent().width() - ((hasScrollbar && this._isSubtractingScrollWidth()) ? scrollWidth : 0) + (this.isHover() ? ROUNDING_WIDTH : 0);
      },
      _isSubtractingScrollWidth: function() {
         return cConstants.browser.isIE && !cConstants.browser.isIE9 && !cConstants.browser.isIE8 || this.isHover();
      },
      /**
        * Перерисовать выпадающий контейнер и показать его
        * @private
        */
      _showAndPlace: function() {
         var
            self = this,
            // [Object] jQuery контейнер контрола
            container = this.getContainer(),
            // [Object] набор css-свойств контейнера выпадающего списка
            listCss = {},
            // [Object] jQuery выбранный выбранный элемент списка
            selectedOpt = container.find('.custom-select'),
            // [Boolean] итмеет ли список фиксированную ширину
            fixedWidth = self._container.hasClass('ws-dropdown-fixed-width'),
            // [Number] Ширина горизонтального скролла браузера
            scrollWidth = getScrollWidth(),
            // [Boolean] скрыт ли список
            isListHidden = self._optCont.hasClass('ws-hidden'),
            // [Number] Ширина контейнера списка
            listWidth,
            // [Boolean] имеет ли список список вертикальный скроллбар
            hasScrollbar;
         // для мобильных устройствах оставляем нативный селект (кроме режима hover)
         this._zIndex = WindowManager.acquireZIndex(false, false, true);
         WindowManager.setVisible(this._zIndex);
         this._optCont.css('z-index', this._zIndex);
         if ((cConstants.browser.isMobilePlatform) && !self.isHover()) {
            return;
         }
         $(document).bind('keydown.' + self.getId(), function (e) {
            if (~$.inArray(e.which || e.keyCode, [cConstants.key.tab, cConstants.key.esc])) {
               self._hideOptions();
            }
         });
         if (this.isHover()) {
            this._optContHead.css('margin-left', 0);
         }
         self._optCont.css('overflow-y', 'hidden').removeClass('ws-hidden');
         listWidth = self._optCont.width() + BORDER_SIZE * 2;
         hasScrollbar = ((self._optCont.get(0).scrollHeight > MAX_HEIGHT) && !self.isHover()) || //helpers.hasScrollbar(self._optCont, 'y');
            //TODO разобраться почему ie неверно расчитывает scrollHeight и clientHeight, они отличаются на 1 px
            self._optCont.get(0).scrollHeight > self._optCont.get(0).clientHeight + 1;
         // ie не включает ширину скроллбара в min-width
         listCss['min-width'] = self._getMinWidth(selectedOpt, hasScrollbar, scrollWidth);
         if (fixedWidth) {
            // но включает в max-width
            listCss['max-width'] = selectedOpt.parent().width();
         }
         if (listCss['min-width'] >= parseInt(self._optCont.css('max-width'), 10)) {
            delete(listCss['min-width']);
         }
         //В IE строго выставляем скролл
         listCss['overflow-y'] = cConstants.browser.isIE && hasScrollbar ?  'scroll' : '';
         if (hasScrollbar && self.isHover() && listWidth + scrollWidth < MAX_WIDTH_HOVER_STYLE) {
            listWidth += scrollWidth;
            listCss['width'] = listWidth;
         }
         self._optContList
            .css(listCss)
            .toggleClass('custom-options-container-with-scrollbar', hasScrollbar);
         self._menuTarget = self._container.find('.ws-field');
         self._recalculateMenu(position);
         trackElement(self._menuTarget).subscribe('onMove', function () {
            self._recalculateMenu(position);
         }, self);
         // Проставляем title опциям, которые визуально не убрались и снимаем тем, которые поместились.
         if (!cConstants.browser.isIE) {
            var
               customOpt = self._optCont.find('.custom-select-option').toArray();
            for (var key in customOpt) {
               if (customOpt.hasOwnProperty(key)) {
                  var
                     o = customOpt[key],
                     range = document.createRange(),
                     rects,
                     rect,
                     $o = $(o);
                  range.selectNodeContents(o);
                  rects = range.getClientRects();
                  rect = rects[0];
                  // если длинна элемента списка больше длинны контейнера списка
                  // и режим не hover
                  // или hover с опцией showTooltip
                  // проставим элементу значение в title, чтоб можно было видеть его в подсказке
                  if (rect && rect.width > $o.width() && (!self.isHover() || (self.isHover() && self._options.showTooltip))) {
                     $o.attr('title', $o.text());
                  }
               }
            }
         }
         // TODO выпилить стрелки\спрайты, перевести все на шрифты
         if (isListHidden) {
            if (!self.isHover()) {
               self._optArrow.addClass('custom-select-arrow-open');
            }
            self._container.trigger('wsSubWindowOpen');
         } else {
            self._hideCustomContainer();
         }
      },
      /**
       * Перерисовать выпадающий контейнер и показать его
       * @params [DOM-Object] select нативный список
       * @private
       */
      _changeFunc: function(select){
         var
            self = this,
            // [Object] jQuery контейнер контрола
            container = this.getContainer(),
            // Если отображаем выбранную запись в общем списке, то ищем её в dom, иначе - берем сохраненное в _textSelectedRow значение
            txt = (self.isShowSelectedInList() ? self._optCont.find('[value="'+ select.value +'"]').html() : self._textSelectedRow) || '&nbsp;',
            // [Object] jQuery выбранный выбранный элемент списка
            selectedOpt = container.find('.custom-select-text'),
            record = self._recordSet && self._recordSet.contains(select.value) && self._recordSet.getRecordByPrimaryKey(select.value),
            // значение элемента списка
            value,
            // [Function] функция рендеринга значения в контейнере выпадающего списка
            titleRender = self.getTitleRender(),
            // [Object] Данные ключей/значений выпадающего списка
            data = self._options.data,
            // [jQuery] элемент списка
            $option;
         for (var i = 0, len = data.k.length; i < len; ++i) {
            if (data.k[i] == select.value) {
               value = data.v[i];
               break;
            }
         }
         if (!self.isAllowEmpty() && self._options.emptyValue === '' && self._isEmptyOption(select.value, txt)) {
            selectedOpt
               .addClass('ws-dropdown-placeholder')
               .text(self.getTooltip());
         } else {
            selectedOpt.removeClass('ws-dropdown-placeholder');
            if (self.isAllowEmpty() && self._isEmptyOption(select.value, txt)) {
               txt = self.getEmptyValue();
            }
            if (typeof titleRender === 'function') {
               selectedOpt.empty().append(titleRender.apply(self, record ? [record] : [select.value, value]));
            } else {
               selectedOpt.html(txt);
            }
            self._optCont
               .find('div')
               .removeClass('selected-option')
               .each(function(){
                  $option = $(this);
                  if ($option.attr('value') == select.value) {
                     $option.addClass('selected-option');
                  }
               });
         }
      },
      _initializeContent: function() {
         var
            renderStyle = this.getRenderStyle(),
            dom = [
               '<div class="custom-select' + (renderStyle === 'simple' ? ' asLink' : '') + '">',
               '<div class="custom-select-text">' + rk("Загрузка...") + '</div>',
               '<div class="custom-select-arrow"></div>',
               '</div>'
            ],
            dropdown = [
               '<div class="custom-options-container ws-hidden not-hovered' +
                  ' custom-options-container-' + renderStyle + '"' +
                  ' dropdown-owner-name="' + (this.getName() || '') + '"' +
                  '>',
               '</div>'
            ],
            container = this.getContainer();
         container
            .find('.ws-field')
            .append(dom.join(''))
            .end()
            .find('.dropdown-fake')
            .remove();
         this._optCont = $(dropdown.join('')).addClass(this._options.cssClassName);
         this._optContHead = $(
            '<div></div>',
            {'class': 'custom-options-container-head'}
         ).appendTo(this._optCont);
         this._optContList = $(
            '<div></div>',
            {'class': 'custom-options-container-list'}
         ).appendTo(this._optCont);
         this._optArrow = container.find('.custom-select-arrow');
         if (this.isHover()) {
            this._optArrow
               .addClass('custom-select-arrow-hover icon-16 icon-DayForward icon-primary')
               .insertBefore(this._container.find('.custom-select-text'));
            this._optContHead.append('<i class="custom-options-container-head-rounding"/>');
         }
         this._optCont[0].wsControl = this;
         $('body').append(this._optCont);
      },
      _recalculateMenu: function(position) {
         var
            targetOffset = this._menuTarget.offset(),
            menuTurned,
            widthDifference,
            renderStyle = this.getRenderStyle(),
            leftMargin = 0;
         this._optCont.position({
            my: position.my[renderStyle],
            at: position.at[renderStyle],
            collision: this._options.flipVertical ? 'flip' : 'flip none',
            of: this._menuTarget,
            using: function(pos) {
               var targetOffsetLeft = targetOffset.left;
               // на мобильниках, при зуме, offset возвращает значение, учитывая положение скролла, поэтому вычтем его
               if (cConstants.browser.isMobilePlatform || $('body').hasClass('fixed-content')) {
                  targetOffsetLeft -=  window.pageXOffset;
               }
               pos.left = Math.round(pos.left);
               // Обязательно округляем отступ таргета + учитываем оффсет -6px для стиля "hover"
               menuTurned = Math.round(targetOffsetLeft) - 6 > pos.left;
               this._optCont.toggleClass('custom-options-container-left-turn', menuTurned)
                  .css(pos);
            }.bind(this)
         });
         if (this.isHover()) {
            widthDifference = this._optContList[0].offsetWidth - this._optContHead[0].offsetWidth;
            this._optCont.toggleClass('custom-options-container-widthEquals', 0 <= widthDifference && widthDifference <= 3);
            // Если сработал flip, то задаём head-контейнеру маржин, равный разнице ширин списка контейнера и заголовка (иначе - обнуляем маржин)
            if (menuTurned) {
               leftMargin = widthDifference;
               if (leftMargin < 0) {
                  leftMargin = 0;
               }
            }
            this._optContHead
               .css('margin-left', leftMargin + 'px')
               .toggleClass('custom-options-container-head-reversed', parseFloat(this._optContList.css('top')) < -1)
               // Установка title т.к. текст может не влезать.
               .attr('title', this._options.showTooltip ? this._optContHead.text() : '');
         }
      },
      /**
       * Скрытие меню без выбора значения
       */
      hideMenu : function(){
         this._hideOptions();
      },
      _hideOptionsAfterTimeout: function() {
         this._hovered = false;
         this._hoverenOnChild = false;
         var self = this;
         setTimeout(function(){
            if(self.isDestroyed()) {
               return;
            }
            if(!self._hovered) {
               self._hideOptions();
            }
         }, 42);
      },
      _configChecking: function() {
         if(this.isHover()) {
            this.setShowSelectedInList(false);
         }
      },
      _canValidate: function() {
         return this.isRequired() || FieldDropdown.superclass._canValidate.apply(this, arguments);
      },

      _isEmpty: function() {
         var value = this._curValue();
         return (typeof(value) === 'undefined' || value === null || value === null);
      },
      _invokeValidation: function() {
         // ToDo: копипаста из FieldString, нужно рефакторить
         var parentResult = FieldDropdown.superclass._invokeValidation.apply(this, arguments);
         if (this.isRequired() && this._isEmpty()) {
            parentResult.result = false;
            parentResult.errors.push(this._options.errorMessageFilling);
         }
         return parentResult;
      },
      /**
       * Отображается ли выпадающий список в режиме "по ховеру"
       * @returns {boolean}
       */
      isHover: function(){
         return this.getRenderStyle() === 'hover';
      },
      _valuesAreEqual: function(key) {
         var curval = this._curval;
         if (curval instanceof dEnum) {
            curval = curval.getCurrentValue();
         }
         return curval === null || curval === 'null'
            ? key === null || key === 'null'
            : key == curval;
      },
      _fillDropdown: function() {
         var
            data = this._options.data,
            // содержимое data
            keys, values, rendered,
            // div с выбранной записью
            row,
            // Что отображаем визуально
            visual;
         if (!data) {
            return;
         }
         keys = data.k;
         values = data.v;
         rendered = data.r;
         this._optCont
            .find('.custom-select-option')
            .unbind('click')
            .remove();
         for (var i = 0, l = keys.length; i < l; i++) {
            visual = rendered[i] || values[i];
            // Если необязательно выбирать значение или не пустой итем
            var hasMoreMultiplyMode = this.isMultiplyMode() && keys[i] == 'hasMore'; // кнопку "ещё" в режиме multiselect не нужно показывать
            if (!hasMoreMultiplyMode && (!this.isRequired() || !this._isEmptyOption(keys[i], visual))) {
               row = this._createCustomRow(keys[i], visual);
               if (this.isMultiplyMode()) {
                  this._toggleCurrentRow(row, false);
                  this._optContList.append(row);
               }
               // Если нужно показывать выбранное в общем списке или значения не равны
               if (this.isShowSelectedInList() || !this._valuesAreEqual(keys[i])) {
                  this._toggleCurrentRow(row, false);
                  this._optContList.append(row);
                  // Иначе - обрабатываем выбранную (текущую) запись
               } else {
                  this._textSelectedRow = values[i];
                  if(this.getRenderStyle() === 'simple') {
                     this._toggleCurrentRow(row, true);
                     this._optContList.prepend(row);
                  } else if (this.isHover()) {
                     if (this._options.titleRender) {
                        row = this._options.titleRender.apply(this, [keys[i], values[i]]);
                        row = this._createCustomRow(keys[i], row);
                     } else {
                        row = row.clone();
                     }
                     row
                        .prepend(
                           this._optArrow.clone()
                              .addClass('custom-select-arrow-open' + (this.isHover() ? ' icon-ArrowDown icon-hover' : ''))
                              .removeClass('icon-DayForward icon-primary'))
                        .prependTo(this._optContHead);
                     this._toggleCurrentRow(row, true);
                  }
               }
            }
         }
      },
      /**
       * устанавливает/убирает класс текущей строки для переданной
       * @param {jQuery} row Строка выпадающего списка, которая должна стать текущей
       * @param {Boolean} isCurrent - параметр указывающий на то какая строка передается для обработки
       * @private
       */
      _toggleCurrentRow: function(row, isCurrent){
         var selectedRowClass = 'ws-field-dropdown-current';
         if (isCurrent === undefined) {
            isCurrent = true;
         }
         if (!isCurrent && row.hasClass(selectedRowClass)) {
            row.removeClass(selectedRowClass);
         } else if (isCurrent) {
            // текущей может быть только одна строка, поэтому с остальных строк пометку снимаем, если найдем такие
            this._optContList.find('.' + selectedRowClass).removeClass(selectedRowClass);
            row.addClass(selectedRowClass); //Вешаем на строку класс, что она "текущая"
         }
      },
      /**
       * Является ли опция пустой
       * @param {String} key Первичный ключ
       * @param {String} value Отображаемый текст
       * @returns {Boolean}
       * @private
       */
      _isEmptyOption: function(key, value){
         value = value + '';
         return ((key === 'null' || key === null) && (value == 'null' || value.replace(/^\s+|\s+$/g, '') === '' || value === '&nbsp;')) || value === EMPTY_TEXT;
      },
      _hideCustomContainerIfVisible: function() {
         if (this._optCont && !this._optCont.hasClass('ws-hidden')) {
            this._hideCustomContainer();
         }
      },
      /**
       * Скрывает выпадающее меню и сообщает об этом
       * @private
       */
      _hideCustomContainer: function(){
         this._optArrow.removeClass('custom-select-arrow-open');
         this._optCont.addClass('ws-hidden');
         $('.custom-select-option',this._optContList).removeClass('custom-select-option-hover');
         trackElement(this._menuTarget, false);
         this._container.trigger('wsSubWindowClose');
         WindowManager.setHidden(this._zIndex);
         WindowManager.releaseZIndex(this._zIndex);
      },
      /**
       * Скрывает выпадающее меню (для кастомного выпадающего списка), если оно было открыто
       * @private
       */
      _hideOptions: function() {
         this._hideCustomContainerIfVisible();
         $(document).unbind('keypress.' + this.getId());
      },
      /**
       * Создаёт строку для кастомного списка
       * @param {*} key Ключ
       * @param {*} value Значение
       * @return {jQuery} Новая строка
       * @private
       */
      _createCustomRow: function(key, value){
         var
            custom = value instanceof jQuery,
            container = custom ? value : $('<div></div>'),
            self = this,
            isEmpty = !value;
         container
            .addClass('custom-select-option')
            .attr('value', key + '')
            .click(this._selectingEvent.bind(this))
            .hover(function(e) {
               $('.custom-select-option',this._optContList).removeClass('custom-select-option-hover');
               $(this).toggleClass('custom-select-option-hover', e.type === 'mouseenter');
            });
         if (!custom){
            if (key === "null" && this.isAllowEmpty() && this.getEmptyValue()) {
               value = this.getEmptyValue();
            } else if (isEmpty) {
               container.addClass('ws-field-dropdown-empty');
            }
            container
               .attr('title', (value === null ? '' : value))
               .css({'whiteSpace' : self.isWordWrap() ? 'normal' : 'nowrap'})
               .html(escapeHtml('' + (value === null ? '' : value)) || EMPTY_TEXT);
         }
         return container;
      },
      /**
       * Обработка события выбора элемента списка
       * @param {Event} e Передаваемое событие
       * @private
       */
      _selectingEvent: function(e) {
         this._curval = $(e.target).closest('.custom-select-option').attr('value');
         // Для режима hover не надо обрабатывать клик, если значения одинаковые - иначе слетает max-width
         if (!this.isHover() || (this._inputControl.val() !== this._curval)) {
            this._hideOptions();
            if (this._curval !== 'hasMore') {
               this._inputControl.val(this._curval);
               this._inputControl.change();
            } else if (this._curval === 'default'){
               return this._notifyDefault();
            } else {
               this._notify('onClickMore');
               return false;
            }
            this._inputControl.focus();
         }
         e.stopImmediatePropagation();
      },
      _notifyDefault: function(){
         this._notify('onClickDefault');
         return true;
      },
      _dotTplFn: dotTplFn,
      _bindInternals: function() {
         this._inputControl = this._container.find('select');
      },
      init: function(){
         this._fillData();
         FieldDropdown.superclass.init.apply(this, arguments);

         this._dSetReady.addBoth(function(res){
            this._notify("onReady");
            return res;
         }.bind(this)).addCallback(function(res){
            this._initialValueSetted = true;
            return res;
         }.bind(this));
      },
      _prepareFillData: function() {
         this._inputControl.children().remove();
         this._createLoadingIndicator(); //Для рекордСета
         this._emptyInit = false;
         this._dSetReady = this._prepareDeferredChain();
         this._initialValueSetted = true;
      },
      _fillData: function() {
         var
            data = this._options.data,
            today = new Date(),
            mode = this.getMode(),
            curYear = today.getFullYear(),
            firstYear = this.getFirstYear(),
            lastYear = this.getLastYear() || curYear;
         if (mode !== '') {
            switch (mode) {
               case 'month':
                  data = {
                     keys :   [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ],
                     values : cConstants.Date.longMonthsSmall
                  };
                  this._desiredDefaultValue = today.getMonth();
                  break;
               case 'year':
                  data = { keys: [], values: [] };
                  if (firstYear >= lastYear) {
                     lastYear = firstYear;
                  }
                  for (var year = firstYear; year <= lastYear; year++) {
                     data.keys.push(year);
                     data.values.push(year);
                  }
                  this._desiredDefaultValue = firstYear;
                  if (curYear <= lastYear && curYear >= firstYear) {
                     this._desiredDefaultValue = curYear;
                     if(!this._options.value){
                        this._options.value = curYear;
                     }
                  }
                  break;
               default:
                  throw new Error("Wrong predefined type specified for FieldDropdown: " + mode);
            }
            this._dSetReady.callback(data);
         } else if (this._isDataNotEmpty(data)) {
            this._dSetReady.callback(data);
         } else if (this._options.dataSource.isConfigured()) {
            this._prepareRecordSet();
         } else {
            this._dSetReady.callback({
               keys: [],
               values: []
            });
            this._emptyInit = true;
         }
      },
      /**
       * Помечаем, что установлено начальное значение, только после загрузки рекордсета
       * @private
       */
      _markInitialValueSetted: function(){
      },
      /**
       *
       * Установить текст пустого значения выпадающего списка или заменить текст, ранее заданный параметром {@link emptyValue}.
       * Имеет смысл только для режима 'Источник данных'.
       * @param {String} newEmptyValue Новый текст пустого значения.
       * @see mode
       * @see allowEmpty
       * @see emptyValue
       */
      setEmptyValue: function(newEmptyValue){
         if (this.isAllowEmpty() && newEmptyValue) {
            this.setValue(newEmptyValue);
            this.getEmptyValue()
               ? this.changeValueByIndex(null, newEmptyValue)
               : this.insertOption(null, newEmptyValue, this.getKeys()[0]);
            this._inputControl.trigger('change.themed');
            this._options.emptyValue = newEmptyValue;
         }
      },
      /**
       *
       * Получить параметр emptyValue — текст пустого значения выпадающего списка.
       * @return {String} свойство emptyValue выпадающего списка
       */
      getEmptyValue: function() {
         return this._options.emptyValue;
      },
      /**
       *
       * Изменить начальный год списка.
       * Имеет смысл только для режима 'Год'.
       * @param {Number} firstYear Новый начальный год.
       * @see mode
       * @see setLastYear
       */
      setFirstYear: function(firstYear){
         this.setYears(firstYear, this._options.lastYear);
      },
      /**
       * Установка максимальной ширины для выпадающих списков в режиме 'hover'
       * @param {Number} width
       */
      setMaxWidthForHoverStyle : function(width) {
         if (width && this.isHover()) {
            this._optContHead.find('div').css('max-width', width + 'px');
         }
      },
      /**
       * Установка минимальной ширины элементов выпадающего списка списка  в режиме 'hover'
       * @param {Number} width
       */
      setMinWidthListForHoverStyle: function(width){
         if (width && this._options.renderStyle === 'hover') {
            this._optContList.find('div').css('min-width', width + 'px');
            this._options.width = width + 'px';
            this._container.css('width', this._options.width + "px");
            this._inputControl.css('width', this._options.width + "px");
         }
      },
      /**
       *
       * Изменить конечный год списка.
       * Имеет смысл только для режима 'Год'.
       * @param {Number} lastYear Новый конечный год.
       * @see mode
       * @see setFirstYear
       */
      setLastYear: function(lastYear){
         this.setYears(this._options.firstYear, lastYear);
      },
      /**
       *
       * Изменяет начальный и конечный года списка.
       * @param {Number} firstYear Новый начальный год.
       * @param {Number} lastYear Новый конечный год.
       * @see mode
       * @see setLastYear
       * @see setFirstYear
       */
      setYears: function(firstYear, lastYear){
         if(this.getMode() === 'year'){
            var
               data = { keys: [], values: [] },
               currentValue = this.getValue(),
               self = this;
            if (isNaN(firstYear)) {
               firstYear = this.getFirstYear();
            } else {
               this._options.firstYear = firstYear;
            }
            if(isNaN(lastYear)) {
               lastYear = this.getLastYear();
            } else {
               this._options.lastYear = lastYear;
            }
            for (var year = firstYear; year <= lastYear; year++) {
               data.keys.push(year);
               data.values.push(year);
            }
            this._inputControl.children().remove();
            this._dSetReady = this._prepareDeferredChain();
            this._dSetReady.addCallback(function(data) {
               if (data.k.indexOf(self._castValue(currentValue)) !== -1) {
                  self.setValue(currentValue);
               } else {
                  var val = data.v[0];
                  if (val !== undefined || currentValue !== val) {
                     self.setValue(val);
                     self._notify('onChange', val);
                  }
               }
               return data;
            });
            this._dSetReady.callback(data);
         }
      },
      /**
       *
       * Возвращает свойство {@link displayColumn} — колонку записи, используемую при отображении.
       * @returns {String} Свойство displayColumn выпадающего списка.
       * @see displayColumn
       * @see setDisplayColumn
       */
      getDisplayColumn: function() {
         return this._options.displayColumn;
      },
      /**
       *
       * Возвращает свойство {@link itemValueColumn} — колонку записи, используемую для значения (ключа) элемента списка.
       * @returns {String} Свойство itemValueColumn выпадающего списка.
       * @see itemValueColumn
       */
      getItemValueColumn: function() {
         return this._options.itemValueColumn;
      },
      /**
       *
       * Устанавливает свойство displayColumn — колонку записи, используемую при отображении.
       * @param {String} displayColumn Имя колонки рекордсета, которая будет отображаться в выпадающем списке.
       * @see displayColumn
       */
      setDisplayColumn: function(displayColumn) {
         this._options.displayColumn = displayColumn;
      },
      /**
       *
       * Устанавливает свойство itemValueColumn — колонку записи, используемую для значений выпадающего списка.
       * Задайте '' для использования ключа записи.
       * @param {String} itemValueColumn Имя колонки рекордсета, которая будет использоваться для значений.
       */
      setItemValueColumn: function(itemValueColumn) {
         this._options.itemValueColumn = itemValueColumn;
      },
      /**
       *
       * Установить новые данные.
       * Возможна установка статических данных или рекордсета.
       * @param {Object|dTransportRecordSet} data Возможны два формата данных:
       * <ul>
       *    <li>[{key : <ключ1>, value : <значение1>}, {key : <ключ2>, value : <значение2>}, ...];</li>
       *    <li>{@link dTransportRecordSet RecordSet}.</li>
       * </li>
       * @see data
       * @throws {TypeError} Если в качестве data передан не объект
       * @throws {TypeError} Если data имеет два массива keys и values различной длины
       * @throws {TypeError} Если передан RecordSet, но не задана отображаемая колонка записи
       */
      setData:function (data) {
         var
            obj = data,
            self = this,
            oldValue = this.getValue();

         if(typeof data !== 'object') {
            throw new TypeError(rk('В метод setData можно передать либо простой JavaScript-объект либо RecordSet'));
         }

         if(data instanceof dTransportRecordSet) {
            if(this.getDisplayColumn() === '') {
               throw new TypeError(rk('Невозможно установить данные через RecordSet т.к. не задана отображаемая колонка записи. Задайте отображаемую конолку через setDisplayColumn.'));
            }
            // TODO Проверить, что в записях переданного рекордсета есть нужная колонка
         }

         this._prepareFillData();
         this._dSetReady.addCallback(function(data){
            self.setValue(oldValue);
            return data;
         });

         // Если пришел Object - преобразуем в нужный формат (рекордсет пробрасываем дальше)
         obj = this._convertDataToExpectedFormat(data);
         // Если у нас был рекордсет, обнулим ссылку на него чтобы не работали методы типа reload() и setQuery() со старым рекордсетом
         if (this._recordSet !== null) {
            this._recordSet = null;
         }
         this._dSetReady.callback(obj);
      },
      /**
       * Приводит статичные данные к общему виду.
       * В данном случае это объект с набором ключей и значений в виде массива строк
       * @params {Array|Object} data массив данных с объектами хранищими пары ключ значение или уже правильно определенный объект
       * @return {Object} нормализованный объект или рекордсет
       */
      _convertDataToExpectedFormat: function(data) {
         var
            obj = data,
            // приведение всех значений ключей (кроме null) к строковому типу
            convertingKey = function(key) {
               key = key === undefined ? '' : key + '';
               return key === 'null' ? null : key;
            };
         // рекодсеты не трогаем - отдаем как есть
         if (!(data instanceof dTransportRecordSet)) {
            // объект уже предположительно в нужном формате
            if (data.keys instanceof Array && data.values instanceof Array) {
               if (data.keys.length !== data.values.length) {
                  throw ('setData, keys and values have different length');
               }
            } else {
               obj = { keys:[], values:[] };
               if (getType(data) === 'array') {
                  for (var j = 0; j < data.length; ++j) {
                     obj.keys.push(convertingKey(data[j].key));
                     obj.values.push(data[j].value || '');
                  }
               } else {
                  for (var i in data) {
                     if (data.hasOwnProperty(i)) {
                        obj.keys.push(convertingKey(i));
                        obj.values.push(data[i]);
                     }
                  }
               }
            }
         }
         return obj;
      },
      _setEnabled : function(enable) {
         FieldDropdown.superclass._setEnabled.apply(this, arguments);
      },
      setActive: function(active, shiftKey, noFocus, control) {
         if (!active) {
            this._hideCustomContainerIfVisible();
         }
         // На iOS выпадающие списки <select> при получении фокуса сразу выпадают.
         // Пытаемся это предотвратить
         // Если на мобильном Safari,
         // передадим в метод родительского класса параметр noFocus == true (3 аргумент), чтобы реально фокус на элемент не перешел
         // передадим следующий контрол, куда уйдет фокус или с которого фокус уходит (4 аргумент)
         FieldDropdown.superclass.setActive.apply(this, [active, undefined, (cConstants.browser.isMobileSafari && !this.isHover()), control]);
      },
	   /**
         *
		 * Устанавливает свойство required(обязательно ли выбирать значение) в зависимости от переданного параметра
		 * @param {Boolean} required Обязательно для выбора.
         * @see isRequired
		 */
      setRequired: function(required) {
         required = !!required;
         this._options.required = required;
      },
      /**
       *
       * Возвращает, обязательно ли выбирать значение.
       * @returns {Boolean}
       */
      isRequired: function() {
         return this._options.required;
      },
      _prepareRecordSet: function() {
         if(this._recordSet === null) {
            var
               self = this,
               dataSource = cMerge({
                  handlers: {
                     onAfterLoad: function(eventState, recordSet, isSuccess, error){
                        if (self._dSetReady && self._dSetReady.isReady()) {
                           self._dSetReady = self._prepareDeferredChain();
                        }
                        if (self._dSetReady){
                           if(isSuccess){
                              self._onAfterLoadRecordSet(recordSet);
                              self._dSetReady.callback(recordSet);
                           } else if (!(error instanceof HTTPError) || error.httpError !== 0) {
                              self._dSetReady.errback(error);
                           }
                        }
                     }
                  }
               }, this._options.dataSource);
            dataSource.context = this.getLinkedContext();
            dataSource.filterParams = cMerge(dataSource.filterParams || {}, this._options.filterParams);
            this._notify('onBeforeLoad');
            moduleStubs.require('Deprecated/RecordSet').addCallbacks(function (args) {
               var RsCtor = args[0];
               self._recordSet = new RsCtor(dataSource);
               if (self._options.dataSource.firstRequest === false) {
                  self._dSetReady.callback(self._recordSet);
               }
               return self._recordSet;
            }, function (e) {
               self._dSetReady.errback(e);
               return e;
            });
         }
      },
      _onAfterLoadRecordSet:function(recordSet) {
         if (this.isHover() && recordSet.hasNextPage()) {
            this.insertOption('hasMore', rk('Еще...'));
         }
      },
      /**
       * Возвращает html-код опции для селекта
       * @param {*} key Ключ
       * @param {*} value Значение
       * @private
       */
      _optionTemplate: function(key, value){
         var optionValue = (('' + value).trim() === '' || value === null) ? EMPTY_TEXT : value;
         optionValue = escapeHtml(optionValue);
         return '<option value="' + key + '" >' + optionValue + '</option>';
      },
      /**
       * Если есть "рендер", то применяет его с указанными аргументами и возвращает результат, иначе возвращает пустую строку
       * @param {Array} args Аргументы вызова
       * @return {jQuery|String}
       * @private
       */
      _renderOrNot: function(args){
         var valueRender = this.getValueRender();
         //мобильные устройства показывают свой выпадающий список, поэтому там нельзя отдать jQuery, а только текст
         return (!cConstants.browser.isMobilePlatform || this.isHover()) && typeof valueRender === 'function' ? valueRender.apply(this, args) : '';
      },
      _prepareDeferredChain: function() {
         var
            self = this,
            isAllowEmpty = self.isAllowEmpty();

         return new cDeferred().addBoth(function(r){
            self._inputControl.find('.ws-loading-line').remove();
            return r;
         }).addCallback(function(data){ // Если пришел RecordSet - превратим его в Object
            var keysAndValues = { k: [], v: [], r: [] };

            if (data instanceof dTransportRecordSet) {

               var
                  record,
                  key,
                  displayColumn = self.getDisplayColumn(),
                  itemValueColumn = self.getItemValueColumn(),
                  displayValue;

               self._dataType = 'RecordSet';

               // Заполним пустое значение.
               if (isAllowEmpty) {
                  keysAndValues.k.push(null);
                  keysAndValues.v.push(self.getEmptyValue());
                  keysAndValues.r.push(self._renderOrNot([null]));
               }

               data.rewind();
               self._recordSet = data;
               while ((record = data.next()) !== false){
                  if (record.hasColumn(displayColumn)) {
                     displayValue = record.get(displayColumn);
                  }
                  if (itemValueColumn && record.hasColumn(itemValueColumn)) {
                     key = record.get(itemValueColumn);
                     switch (record.getColumnType(itemValueColumn)) {
                        case 'Число целое':
                        case 'Числовое значение':
                           key = Number(key);
                           break;
                        case 'Строка':
                           key += '';
                           break;
                     }
                  } else {
                     key = record.getKey();
                  }
                  displayValue = displayValue === null ? "null" : displayValue;
                  keysAndValues.k.push(key);
                  keysAndValues.v.push(displayValue);
                  keysAndValues.r.push(self._renderOrNot([record]));
               }

            } else {
               keysAndValues.k = data.keys;
               keysAndValues.v = data.values;
               keysAndValues.r = [];
               if (typeof self.getValueRender() === 'function' || self.isMultiplyMode()) {
                  for (var i = 0, l = data.values.length; i < l; i++) {
                     keysAndValues.r[i] = self._renderOrNot([data.keys[i], data.values[i]]);
                  }
               }

               /**
                * WARNING! HARDCORE FIX!
                * Исправляем баг разного порядка перебора Object через for-in в Chrome (по сравнению со всем остальными)
                * затачиваемся на то, что null всегда должен быть первым
                * Мы лечим это так на скорую руку,
                * так как по делу придется менять формат передачи на стороне БЛ
                */
               var nIdx;
               if((nIdx = keysAndValues.k.indexOf('null')) > 0) {
                  keysAndValues.k.splice(nIdx, 1);
                  var nVal = keysAndValues.v.splice(nIdx, 1);
                  var rVal = keysAndValues.r.splice(nIdx, 1);
                  keysAndValues.k.unshift('null');
                  keysAndValues.v.unshift(nVal[0]);
                  keysAndValues.r.unshift(rVal[0]);
               }
            }

            self._fKeyType = typeof (keysAndValues.k[isAllowEmpty ? 1 : 0]);

            return keysAndValues;
         }).addCallback(function(data) { // Отобразим данные в селекторе
            self._options.data = data;
            if (self._options.value !== ''){
               self._desiredDefaultValue = self._options.value;
            }

            for (var i = 0, l = data.k.length; i < l; i++) {
               var
                  val = data.r[i] || data.v[i],
                  key = data.k[i];

               if (i === 0) {
                  if(self._desiredDefaultValue === '' && self._options.value === ''){
                     self._desiredDefaultValue = key;
                     if(isNaN(self._desiredDefaultValue)){
                        self._desiredDefaultValue = key;
                     }
                  }
               }

               val = val instanceof jQuery ? val.text() : val;
               self._inputControl.append(self._optionTemplate(key, val));
            }
            self._defaultValue = self._desiredDefaultValue;

            return data;
         }).addCallbacks(function(data){
            self._notify('onAfterLoad', true, data);
            return data;
         }, function(e){
            self._notify('onAfterLoad', false, e);
            self._showError(e);
            return e;
         });
      },
      isMultiplyMode: function(){
         return false;
      },
      _onValueChangeHandler: function(){
         var val = this._inputControl.val();
         if (this._enum instanceof dEnum) {
            this._enum.set((val == 'null' || val === null) ? 'null' : parseInt(val, 10)); // В перечисялемом ключи только числа, 'null' и ничего иного
         }
         FieldDropdown.superclass._onValueChangeHandler.apply(this, arguments);
         this._valueSet = true;
      },
      /**
       *
       * Выполняет запрос к БЛ и заполняет Dropdown новыми данными.
       * @param {Object} filter Фильтр выборки.
       * @param {Boolean} [doClear=true] Признак, очищать или нет рекордсет при загрузке.
       * @example
       * <pre>
       *    onReloadButtonPressed: function() {
       *       var currentFilter = {"year" : this.getLinkedContext.getValue('Год')};
       *       this.getChildControlByName('ПричиныУвольнения').reload(currentFilter);
       *    }
       * </pre>
       */
      setQuery: function(filter, doClear){
         var self = this;
         this._lastQueryFilter = filter; // запоминаем фильт для функции reload
         doClear = doClear === undefined ? true : doClear;
         if(doClear) {
            this._inputControl.children().remove();
            this._createLoadingIndicator();
         }
         if(this._recordSet !== null) {
            this._dSetReady = this._prepareDeferredChain();
            this._dSetReady.addCallback(function(data){
               if (doClear) {
                  var currentValue = self.getValue(); // Сработает, так как берём значение из контекста. И теперь можем устанавливать значение в onAfterLoad.
                  if (data.k.indexOf(self._castValue(currentValue)) !== -1) {
                     self.setValue(currentValue);
                  } else {
                     var val;
                     val = data.k[0];
                     if(val !== undefined || currentValue !== val ){
                        self.setValue(val);
                        self._notify('onChange', val);
                     }
                  }
               }
               return data;
            });
            this._recordSet.setQuery(this._prepareFilter(filter), true);
         } else {
            throw new Error('Setting a query to FieldDropdown which has empty dataSource configuration');
         }
      },
      /**
       *
       * Перезагрузить значения из внешнего источника данных.
       * Повторно вызовет метод setQuery c последним применённым фильтром.
       * @example
       * <pre>
       *    var dropdown = $ws.single.ControlStorage.getByName('СписокРежимов');
       *    if (dropdown) {
       *       dropdown.reload();
       *    }
       * </pre>
       */
      reload: function() {
         this.setQuery(this._lastQueryFilter);
      },
      _prepareFilter: function(filter) {
         for(var fName in filter) {
            if(filter.hasOwnProperty(fName) && filter[fName] === undefined) {
               filter[fName] = this._initialFilter[fName];
            }
         }
         return filter;
      },
      _onContextValueReceived: function(ctxVal) {
         var self = this;
         if (ctxVal instanceof dEnum) {
            if (this._dSetReady.isReady() && !this._emptyInit) { // Second run
               if (this._enum !== '') { // Already built by Enum
                  if (this._enum.getCurrentValue() !== ctxVal.getCurrentValue()) { // Value is changed
                     if (ctxVal.hashCode() !== this._enum.hashCode()) {
                        // received Enum is not the same
                        throw new Error('Another Enum came from context, not the same as before (different available values)');
                     } else {
                        this._setValueInternal(ctxVal.getCurrentValue());
                        this._notifyOnValueChange(ctxVal);
                     }
                  }
               } else { // Already built and not by a Enum
                  throw new Error('FieldDropdown is already filled with data and Enum is came from context.');
               }
            } else {
               this._setValueInternal(ctxVal);
               this._notifyOnValueChange(ctxVal);
            }
         } else {
            this._dSetReady.addCallback(function(data){
               if (ctxVal !== undefined) {
                  if (!(ctxVal === null && !self.isAllowEmpty()) && (ctxVal !== self._notFormatedVal() ||
                        self._valueSet === false && ctxVal !== self._desiredDefaultValue)) {
                     var isFirstValueFromContext = !self._valueSet;
                     self._setValueInternal(ctxVal); // установит _valueSet = true
                     if(!isFirstValueFromContext){
                        self._notify('onChange', ctxVal);
                        self._notifyOnValueChange(ctxVal);
                     }
                  }
               }
               // FIXME использование 2 и 3 параметра в setValue
               if(self._valueSet === false) {
                  self.setValue(self._desiredDefaultValue, true, true);
               }
               return data;
            });
         }
      },
      _insertEnum : function(val){
         var
            self = this,
            enumVals = val.getValues(),
            enumCurVal = val.getCurrentValue(),
            kvPairs = { keys: [], values: [] };

         for (var k in enumVals) {
            if (enumVals.hasOwnProperty(k)) {
               if (k === null) {
                  this.setAllowEmpty(true);
               }
               kvPairs.keys.push(k === null ? 'null' : k);
               kvPairs.values.push(enumVals[k]);
            }
         }

         this._enum = new dEnum(val.toObject());
         this._desiredDefaultValue = enumCurVal === null ? 'null' : enumCurVal;

         this._dSetReady.callback(kvPairs).addCallback(function(data){
            self._setValueInternal(self._desiredDefaultValue);
            return data;
         });
      },
      _defaultValueHandler: function() {
         var self = this;
         this._dSetReady.addCallback(function(data){
            if(self._valueSet === false && self._desiredDefaultValue === '') {
               FieldDropdown.superclass._defaultValueHandler.apply(self, []);
            }
            return data;
         });
      },
      _curValue : function(){
         return this._notFormatedVal();
      },
      _castValue: function(value) {
         if (value === null) {
            return value;
         }
         switch (this._fKeyType) {
            case 'string':
               value = '' + value;
               break;
            case 'number':
               value = Number(value);
               break;
         }
         return value;
      },
      getStringValue: function(){
         var value = this._inputControl.val() === '' ? this._curval : this._inputControl.val();
         value = value === 'null' ? null : value;
         if(value !== null) {
            value = this._castValue(value);
         }
         if (this._options.data.v) {
            // Вернем в виде строки либо результат рендера либо значение
            var idx = this._options.data.k.indexOf(value), v;
            v = this._options.data.r[idx] || this._options.data.v[idx];
            return v instanceof jQuery ? v.text() : v;
         }
         else {
            //ToDo: Костылище! Надо разобраться с проблемой и отпилить. В панели фильтров вызывается метод до _prepareDeferredChain()
            return '' + value;
         }
      },
      /**
       *
       * При наличии RecordSet'а возвращает запись, которая сейчас выбрана, иначе undefined
       * @returns {Deprecated/Record|undefined}
       * @example
       * <pre>
       *    var record = dropdown.getSelectedRecord();
       *    if(record) {
       *       fillFieldsDataFromRec(record);
       *    }
       * </pre>
       */
      getSelectedRecord: function(){
         var
            rec,
            self = this,
            itemValueColumn,
            rs = this.getRecordSet();
         if (!rs) {
            return undefined;
         }
         if (!this._options.itemValueColumn) {
            return rs.contains(this._curValue()) ? rs.getRecordByPrimaryKey(this._curValue()) : undefined;
         } else {
            itemValueColumn = self.getItemValueColumn();
            rs.each(function(record){
               if (record.get(itemValueColumn) == self._curValue()){
                  rec = record;
                  return false;
               }
            });
            return rec;
         }
      },
      _createLoadingIndicator: function() {
         this._inputControl.append('<option class="ws-loading-line" value="">' + rk("Загрузка") + '&hellip;</option>');
      },
      _notFormatedVal: function() {
         var value;
         if (this._enum instanceof dEnum) {
            return new dEnum(this._enum.toObject());
         }
         value = this._castValue(this._inputControl.val());
         if (value === 'null' || (typeof value === 'number' && isNaN(value))) {
            value = this._curval || 'null';
         }
         if (value === 'null') {
            return null;
         } else if (value === undefined || value === '' || this._dataType === 'RecordSet') {
            return value;
         } else {
            var tryNum = Number(value);
            return isNaN(tryNum) || tryNum + '' !== value ? value : tryNum;
         }
      },
      _getElementToFocus: function(){
         return this._inputControl;
      },
      _testOnEmptyInit: function() {
         if (this._emptyInit) {
            this._emptyInit = false;
            this._dSetReady = this._prepareDeferredChain();
         }
      },
      _setValueInternal: function(val) {
         var
            // текущее значение select
            nowVal,
            // сравнение текущего значения и свойства _curval
            sameVal;
         if (val === undefined) {
            return;
         }
         if (val instanceof dEnum){
            this._testOnEmptyInit();
            if (!this._dSetReady.isReady()) {
               this._insertEnum(val);
            }
            val = val.getCurrentValue(); // val can become null here!
         }
         if (this._enum instanceof dEnum) {
            try {
               this._enum.set(val); // ok, enum handles null...
            } catch (e) {
               IoC.resolve('ILogger').log('FieldDropdown', e);
            }
         }

         function findOption(select, val) {
            var find = false;
            select.find("option").each(function() {
               if (!find) {
                  find = $(this).val() == val;
               }
            });
            return find;
         }

         this._curval = val === null ? 'null' : val; // must change to string, <select> can't handle null
         nowVal = this._inputControl.val();
         sameVal = nowVal === this._curval.toString();     // А вдруг хотим поставить то же, что там уже установлено?

         /**
          * MEGAFIX: начиная с jquery 1.10 если select'у установить ключ, которого нет,
          * то select сбросится на null, а не выставит первое значение
          * Эмулируем старое поведение jquery 1.6.4, просто не ставим ничего, если нет ключа
          */
         if (!sameVal && findOption(this._inputControl, this._curval)) {
            this._inputControl.val(this._curval);     // Поставим желаемое
         }
         if (nowVal != this._inputControl.val() || sameVal) {  // Проверим, поставилось ли
            this._valueSet = true;                 // Если поставилось - сообщим + запишем что у нас есть значение
            this._inputControl.trigger('change.themed');
            this._updateInPlaceValue(this.getStringValue());
         }
      },
      _showError: function(error) {
         this._inputControl.children().remove().end().append('<option value="">' + error.message + '</option>');
      },
      /**
       *
       * При состоянии контрола, в котором запрещена запись - прокидывать служебные клавиши(tab, esc)
       */
      _passthroughControlButtons: function(){
         var self = this;
         this._inputControl.bind('keypress.readonly, change.readonly, keyup.readonly, keydown.readonly', function(event) {
            if ((!self._isChangeable()) && event.which != cConstants.key.tab && event.which != cConstants.key.esc) {
               self._inputControl.val(self._curval);
               event.stopImmediatePropagation();
            }
         });
      },
      destroy: function() {
         this._dSetReady = null;
         this._enum = null;
         if (this._optCont) {
            this._hideCustomContainerIfVisible();
            this._optCont.empty().remove();
            this._optCont = $();
         }
         if (this._optContList ) {
            this._optContList.empty().remove();
            this._optContList = $();
         }
         if (this._optContHead) {
            this._optContHead.empty().remove();
            this._optContHead = $();
         }
         if (this._optArrow) {
            this._optArrow.empty().remove();
            this._optArrow = $();
         }
         $(document).unbind('.' + this.getId());
         FieldDropdown.superclass.destroy.apply(this, arguments);
      },
      // ToDo: лучше использовать событие onAfterLoad или этот deferred?
      /**
       *
       * Возвращает асинхронное событие готовности значения
       * Функция имеет смысл, если получает данные от бизнес-логики.
       * @example
       * <pre>
       *    dropdown.reload();
       *    dropdown.getValueDeferred().addBoth(function() {
       *       CoreFunctions.alert('Загрузка завершена!');
       *    });
       * </pre>
       * @return {Core/Deferred}
       */
      getValueDeferred: function(){
         return this._dSetReady;
      },
      /**
       * Инициализация дефолтного значения для дропдауна проходит в другом месте
       * @private
       */
      _initDefaultValue: function(){
      },
      /**
       * Обновляет классы на чётных строках выпадающего меню
       * @private
       */
      _updateOddClasses: function(){
         this._optCont.find('.ws-item-odd').removeClass('ws-item-odd');
         this._optCont.find('.custom-select-option:odd').addClass('ws-item-odd');
      },
      /**
       *
       * Добавляет опцию с указанным ключом и отображаемым значением
       * Если не указан before, то добавит в конец. Если указан - то перед элементом с ключом before.
       * @example
       * <pre>
       *    var
       *       keys = dropdown.getKeys(),
       *       lastKey = keys.length ? keys[ keys.length - 1 ] : undefined;
       *    dropdown.insertOption(998, 'Предпоследнее значение', lastKey);
       * </pre>
       * @param {*} key Ключ
       * @param {*} value Значение
       * @param {*} [before] Перед каким элементом вставлять
       */
      insertOption: function(key, value, before){
         if(this._emptyInit) { // Теоретически здесь могут возникнуть конфликты, когда значение вставят раньше, чем придёт оно из контекста.
            this._emptyInit = false;
         }
         this._dSetReady.addCallback(function() {
            var renderResult = this._renderOrNot([key, value]),
               beforeIndex,
               data = this._options.data;
            if( before !== undefined ){
               if (typeof (before) === 'boolean') {
                  beforeIndex = before ? 0 : data.k.length;
               }  else {
                  for(var i = 0; i < data.k.length; ++i){
                     if( data.k[i] == before ){
                        beforeIndex = i;
                        break;
                     }
                  }
               }
            }
            var
               option = $(this._optionTemplate(key, renderResult || value)),
               customOption = this._createCustomRow(key, renderResult || value);
            if (beforeIndex !== undefined) {
               data.k.splice(beforeIndex, 0, key);
               data.v.splice(beforeIndex, 0, value);
               data.r.splice(beforeIndex, 0, renderResult);
               option.insertBefore(this._inputControl.children().eq(beforeIndex));
               if (customOption) {
                  customOption.insertBefore(this._optContList.children().eq(beforeIndex));
               }
            } else {
               data.k.push(key);
               data.v.push(value);
               data.r.push(renderResult);
               option.appendTo(this._inputControl);
               if( customOption ){
                  customOption.appendTo(this._optContList);
               }
            }
         }.bind(this));
      },
      /**
       *
       * Удаляет опцию с указанным ключом.
       * @param {*} key Ключ опции.
       * @example
       * <pre>
       *    var uslessKey = dropdown.getKeyByValue('Текст ненужного значения');
       *    if ( uslessKey !== undefined ) {
       *       dropdown.removeOption(uslessKey);
       *    }
       * </pre>       
       */
      removeOption: function(key){
         var
            data = this._options.data,
            removingCurVal = this._inputControl.val() == key;
         this._dSetReady.addCallback(function(){
            for (var i = 0; i < data.k.length; ++i) {
               if (key == data.k[i]){
                  data.k.splice(i, 1);
                  data.r.splice(i, 1);
                  data.v.splice(i, 1);
                  this._inputControl.children().eq(i).remove();
                  this._optContList.children().eq(i).remove();
                  if (removingCurVal) {
                     this._inputControl.trigger('change.themed');
                  }
                  return;
               }
            }
         }.bind(this));
      },
      /**
       *
       * Перемещает выпадающее меню внутрь контейнера или обратно, в body. Необходимо для полноэкранного режима - когда выпадающий список в body, его не видно, если какой-то внутренний элемент body в полноэкранном режиме (ZoomPlugin)
       * @param {Boolean} [atContainer] Если передать true, то будет располагатсья внутри контейнера, иначе - внутри body
       */
      toggleOptionsToContainer: function(atContainer){
         this._optCont.appendTo(atContainer ? this._container : $('body'));
      },
      /**
       * Меняет выбранное значение на указанное число позиций вверх или вниз
       * @param {Number} by На сколько менять
       * @private
       */
      _modifyValue: function(by){
         this._dSetReady.addCallback(function(){
            var keys = this._options.data.k,
               currentValue = this.getValue(),
               currentIndex;
            for(var i = 0; i < keys.length; ++i){
               if( keys[i] == currentValue ){
                  currentIndex = i;
                  break;
               }
            }
            if( currentIndex !== undefined ){
               var selectedValue = keys[currentIndex + by];
               if( selectedValue !== undefined ){
                  this.setValue(selectedValue);
               }
            }
         }.bind(this));
      },
      /**
       *
       * Устанавливает следующее значение.
       * @example
       * <pre>
       *    onNextZoomKeyPressed = function() {
       *       var dropdown = this.getChildControlByName('МасштабСкана');
       *       if (dropdown) {
       *          dropdown.setNextValue();
       *       }
       *    }
       * </pre>
       */
      setNextValue: function(){
         this._modifyValue(1);
      },
      /**
       *
       * Устанавливает предыдущее значение.
       * @example
       * <pre>
       *    var dropdown = this.getChildControlByName('ГодОтчетности');
       *    if (dropdown && dropdown.getValue() == (new Date).getFullYear()) {
       *       // Если выбран текущий год
       *       dropdown.setPrevValue();
       *    }
       * </pre>
       */
      setPrevValue: function(){
         this._modifyValue(-1);
      },
      /**
       * Заменяет отображаемое значение для выбранного элемента
       * @param {Number} index Индекс элемента.
       * @param {String} value Новое значение.
       * @example
       * <pre>
       *    dropdown.changeValueByIndex(
       *       dropdown.getValues().indexOf('Старое отображаемое значение' ),
       *       'Новое отображаемое значение'
       *    );
       * </pre>
       */
      changeValueByIndex: function(index, value) {
         var
            keys = this._options.data.k;
         if (index >= keys.length || index < 0) {
            return;
         }
         var
            key = keys[index],
            values = this._options.data.v,
            render = this._options.data.r,
            renderResult = this._renderOrNot([key, value]),
            option = $(this._optionTemplate(key, renderResult || value)),
            customOption = this._createCustomRow(key, renderResult || value),
            curInputVal = this._inputControl.val();
         values[index] = value;
         render[index] = renderResult;
         this._inputControl.children().eq(index).replaceWith(option);
         if (customOption) {
            this._optContList.children().eq(index).replaceWith(customOption);
         }
         if (this._curval == key) { // Если заменяем установленное значение
            // то оно снималось у оригинального select'а
            this._inputControl.val(curInputVal);
            // то нужно обновить отображаемое значение
            this._inputControl.trigger('change.themed');
         }
      },
      /**
       * Получить текущий набор данных
       * @returns {dTransportRecordSet|null}
       */
      getRecordSet: function() {
         return this._recordSet;
      },
      /**
       *
       * Возвращает массив со значениями (ключами) опций
       * @returns {Array} Массив ключей с их строковыми значениями
       * @example
       * <pre>
       *    var array = this.getChildControlByName('Пол').getKeys();
       *    array.forEach(function(element, index, array) {
       *       alert('Ключ №' + index + '=' + element);
       *    });
       * </pre>
       */
      getKeys: function(){
         return [].concat(this._options.data.k);
      },
      /**
       *
       * Возвращает массив с отображаемыми значениями опций
       * @returns {Array} Массив значений
       * @example
       * <pre>
       *    var array = this.getChildControlByName('Пол').getValues(),
       *        i = 1;
       *    array.forEach(function(element, index, array) {
       *       alert('Значение №' + i + '=' + element);
       *       i++;
       *    });
       * </pre>
       */
      getValues: function(){
         return [].concat(this._options.data.v);
      },
      /**
       *
       * Возвращает отображаемое значение опции по его фактическому значению (ключу)
       * @param   {String|Number} key Ключ, по которому будет возвращено отображаемое значение.
       * @returns {String|undefined} Отображаемое значение соответствующего ключа, либо undefined если ключ отсутствует.
       */
      getValueByKey: function(key){
         var
            keys = this._options.data.k,
            values = this._options.data.v,
            index = keys.indexOf(key);
         return values[index];
      },
      /**
       *
       * Возвращает фактическое значение (ключ) опции по его отображаемому значению
       * @param   {String}                      value Отображаемое значение.
       * @returns {String|Number|undefined}         Ключ соответствующий отображаемому значению, либо undefined если значение отсутствует.
       */
      getKeyByValue: function(value){
         return this._options.data.k[this._options.data.v.indexOf(value )];
      },
      /**
       *
       * Разрешено ли "пустое значение"
       * @returns {boolean|null}
       */
      isAllowEmpty: function() {
         return this._options.allowEmpty;
      },
      /**
       *
       * Устанавливает опцию allowEmpty
       * @param {boolean|null} allowEmpty значение опции
       */
      setAllowEmpty: function(allowEmpty) {
         if (typeof allowEmpty === 'boolean' || allowEmpty === null) {
            this._options.allowEmpty = allowEmpty;
         }
         if (!allowEmpty) {
            this.removeOption('null');
         }
      },
      /**
       *
       * Возвращает режим отображения данных
       * @returns {String}
       */
      getMode: function() {
         return this._options.mode;
      },
      /**
       *
       * Разрешен ли перенос текста
       * @returns {boolean}
       */
      isWordWrap: function() {
         return this._options.wordWrap;
      },
      /**
       *
       * Устанавливает опцию wordWrap
       * @param {boolean} wordWrap значение опции
       * @see worldWrap
       */
      setWordWrap: function(wordWrap) {
         this._options.wordWrap = !!wordWrap;
      },
      /**
       *
       * Возвращает первый отображаемый год
       * @returns {Number}
       */
      getFirstYear: function() {
         return this._options.firstYear;
      },
      /**
       *
       * Возвращает последний отображаемый год
       * @returns {Number}
       */
      getLastYear: function() {
         return this._options.lastYear;
      },
      /**
       *
       * Возвращает отображение контрола
       * @returns {String}
       */
      getRenderStyle: function() {
         return this._options.renderStyle;
      },
      /**
       *
       * Показывается ли текущий элемент в общем списке
       * @returns {boolean}
       */
      isShowSelectedInList: function() {
         return this._options.showSelectedInList;
      },
      /**
       *
       * Устанавливает опцию showSelectedInList
       * @param {boolean} showSelectedInList значение опции
       */
      setShowSelectedInList: function(showSelectedInList) {
         this._options.showSelectedInList = !!showSelectedInList;
      },
      /**
       *
       * Возвращает пользовательскую функцию рендеринга отображаемого значения
       * @returns {function}
       */
      getValueRender: function() {
         return this._options.valueRender;
      },
      /**
       *
       * Возвращает функцию рендеринга значения в контейнере выпадающего списка
       * @returns {function}
       */
      getTitleRender: function() {
         return this._options.titleRender;
      }
   });

   return FieldDropdown;

});
