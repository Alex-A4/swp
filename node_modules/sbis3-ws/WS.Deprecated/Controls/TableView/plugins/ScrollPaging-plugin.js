/**
 * Created with JetBrains PhpStorm.
 * User: ad.chistyakova
 * Date: 03.03.2014
 * Time: 12:55
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/TableView/plugins/ScrollPaging-plugin', [
   'Core/helpers/Hcontrol/isElementVisible',
   'Deprecated/core-attach',
   'Core/core-instance',
   'Core/core-merge',
   'Core/helpers/Function/callBefore',
   'Core/helpers/Function/callNext',
   'Core/Deferred',
   'Core/constants',
   'Deprecated/Controls/Button/Button',
   'Deprecated/Controls/TableView/TableView',
   'Lib/LayoutManager/LayoutManager',
   'Deprecated/Controls/HierarchyView/HierarchyView',
   'Deprecated/Controls/TreeView/TreeView'
], function(
   isElementVisible,
   cAttach,
   cInstance,
   cMerge,
   callBefore,
   callNext,
   cDeferred,
   cConstants,
   Button,
   TableView,
   LayoutManager
) {
   var BOTTOM_OFFSET = 96;
   /**
 * @class SBIS3.CORE.ScrollPlugin
 * @extends Deprecated/Controls/TableView/TableView
 * @author Крайнов Д.О.
 * @plugin
 * @public
 * @deprecated
 */
   TableView.ScrollPlugin = TableView.extendPlugin(/** @lends SBIS3.CORE.ScrollPlugin.prototype */{
   /**
    * @event onScrollDataLoaded При загрузке данных скролл-рекордсетом
    * Событие происходит перед тем, как будут добавлены записи из скролл-рекрдсета в рекордсет таблицы, по сути это onAfterLoad скролл-рекордсета
    * @param {Core/EventObject} eventObject Дескриптор события.
    * @param {Deprecated/RecordSet} recordSet Экземпляр рекорд-сета
    * @param {Boolean} isSuccess успешна ли загрузка
    * @param {Error} error произошедшая ошибка (если загрузка неуспешная)
    * @example
    * <pre>
    *     dataView.subscribe('onScrollDataLoaded', function(event, rs) {
          *        //Синхронизируем колонки в рекордсете перед тем, как записи из него будут добавлены в рекордсет таблицы
          *        rs.setColumns(dataView.getRecordSet().getColumns());
          *     });
    * </pre>
    */
   /**
    * @event onAfterScrollPackRender После отрисовки полученных в результате скролла данных.
    * Событие происходит после того, как будут отрисованы записи из скролл-рекрдсета, по сути это onAfterRender скролл-рекордсета.
    * Актуально только для плоского списка и иерархии (в дереве происходит обычная перерисовка)
    * @param {Core/EventObject} eventObject Дескриптор события.
    * @example
    * <pre>
    *     dataView.subscribe('onAfterScrollPackRender', function(event) {
          *        //Оживим контролы в верстке
          *        this.getTopParent().reviveComponents();
          *     });
    * </pre>
    * onAfterScrollPackRender
    */
      $withoutCondition: [ '_onDataLoaded' ],
      /**
     * @cfg {Number} Количество запрашиваемых с БЛ записей
     * @name  TableView.ScrollPlugin#display.recordsPerPage
     *
     *
     * @remark
     * Опция задаёт количество записей при построении представления данных.
     * !Данные этой опции используются только при установке {@link constantRecordsPerPage} в true.
     * В случае дерева и иерархии:
     * <ul>
     *    <li>опция также задаёт количество подгружаемых записей кликом по кнопке "Ещё";</li>
     *    <li>как листья, так и узлы являются записями, количество записей считается относительно полностью развёрнутого
     *    представления данных - независимо от задания опции expand. Например, узел с тремя листьями - это 4 записи.</li>
     * </ul>
     * @example
     * <pre>
     *     <option name="recordsPerPage">50</option>
     * </pre>
     * @see scrollPaging
     * @see constantRecordsPerPage
     * @see getScrollRecordSet
     * @group ScrollPaging
     */
      $protected: {
         _options: {
            display: {
            /**
             * @cfg {Boolean} Обрабатывать подгрузку данных по скроллу
             * @remark
             * На работу подгрузки по скроллу влияет задание значения опции {@link constantRecordsPerPage}:
             * данные подгружаются порциями в количестве либо рассчётом по размеру экрана,
             * либо заданном в опции {@link recordsPerPage}.
             *
             *
             * @example
             * <pre>
             *     <option name="scrollPaging">true</option>
             * </pre>
             * @group ScrollPaging
             * @see setAllowScrollLoading
             * @see constantRecordsPerPage
             * @see recordsPerPage
             * @see getScrollRecordSet
             */
               scrollPaging : false,
               /**
             * @cfg {Boolean} Учитывать ли значение опции recordsPerPage
             *
             *
             * @example
             * <pre>
             *     <option name="constantRecordsPerPage">true</option>
             * </pre>
             * @remark
             * Возможные значения:
             * <ul>
             *    <li>true - количество записей, запрашиваемых с БЛ, берётся из в опции recordsPerPage;</li>
             *    <li>false - количество запрашиваемых записей будет рассчитываться по размеру экрана.</li>
             * </ul>
             * @group ScrollPaging
             * @see recordsPerPage
             * @see scrollPaging
             */
               constantRecordsPerPage: false
            }
         },
         _ready: undefined,                           //deferred готовности рекордсета
         _scrollRecordSet: undefined,                 //Рекордсет для получения данных
         _scrollDeferred: undefined,
         _firstLoad : true,
         _nowLoading: false,
         _loadingIndicator: undefined,                 //Индикатор подгрузки данных
         _scrollableContainer: null,                   // контейнер со скроллом
         _onWindowScrollHandler: undefined,
         _onAfterDataViewLoadHandler : undefined,
         _allowLoading: true,                          //Разрешение догрузки по скроллу
         _loadMoreButton: undefined,                   //Кнопка подгрузки записей
         _oldFilter: {},
         _showBranch : false
      },
      $condition: function() {
         return (!this.isDestroyed() && this._options.display.scrollPaging);
      },
      $constructor: function() {
         this._publish('onScrollDataLoaded', 'onAfterScrollPackRender');
         this._onRecordUpdated = callBefore.call(this._onRecordUpdated, this._onBeforeRecordUpdated);
         this.reload = callBefore.call(this.reload, this._reload);
         this._reloadDebounced = callBefore.call(this._reloadDebounced, this._reload);
         if (this.isHierarchy()) {
            this.showBranch = callBefore.call(this.showBranch, this._showBranchHierarchyScroll);
         }
         this._scrollDeferred = new cDeferred();
         this._onWindowScrollHandler = this._onWindowScroll.bind(this);
         this._onAfterDataViewLoadHandler = this._onAfterDataViewLoad.bind(this);
         this._addLoadingIndicator();
         if (this.isHierarchy()) {
            this._expandAll = callNext.call(this._expandAll, this._expandAllScroll);
            this._clearExpandAll = callNext.call(this._clearExpandAll, this._clearExpandAllScroll);
         }
         //Для дерева добавим кнопку "Ещё"
         if (this.isTree()) {
            this.once('onDataReady', this._createLoadMoreButton);
         }
      },
      _createLoadMoreButton: function() {
         this._footer.append('<div class="ws-browser-loadMore"></div>');
         this._loadMoreButton = new Button({
            element: this._footer.find('.ws-browser-loadMore'),
            name: 'ws-LoadButton',
            renderStyle: 'asLink',
            toolTip: 'Ещё...',
            caption: 'Ещё...',
            cssClass: 'ws-browser-loadMore-button',
            handlers: {
               'onActivated' : this._nextLoad.bind(this)
            }
         });
         if(!this._nextLoad()){
            this._loadMoreButton.hide();
         }
         this.recalcBrowserOnDOMChange();
      },
      /**
    * Получить рекордсет скролла
    * @returns {Core/Deferred} возвращает Deferred скролл рекордсета
    * @see scrollPaging
    * @see constantRecordsPerPage
    * @see isAllowScrollPaging
    */
      getScrollRecordSet: function(){
         return this._scrollDeferred.isReady() ? new cDeferred().callback(this._scrollRecordSet) : this._scrollDeferred;
      },
      _checkScrollPaging: function() {
         return false;
      },
      _configChecking: function(){
      //Отключаем контрол пейджинг
         this._options.display.showPaging = false;
         this._options.display.showRecordsCount = false;
         this._options.display.usePaging = 'parts';
         this._options.cssClass += ' ws-browser-ignore-local-page-size';
         //cConstants.Browser.minHeight - минимальная высота строки - сейчас 24
         this._options.display.recordsPerPage = this._options.display.constantRecordsPerPage ?
            this._options.display.recordsPerPage :
            parseInt(($(window).height() / cConstants.Browser.minHeight ) + 10 , 10);
      },
      /**
    * Мы достигли дна... и снизу постучали!
    * @returns {boolean}
    * @private
    */
      _isBottomOfPage : function(target) {
         var docBody = target || LayoutManager.getMainScrollingContainer()[0],
            docElem = target || document.documentElement,
            clientHeigth = Math.min (docBody.clientHeight, docElem.clientHeight),
            scrollTop = Math.max (docBody.scrollTop, docElem.scrollTop),
            scrollHeight = Math.max (docBody.scrollHeight, docElem.scrollHeight),
            parent = this.getTopParent();
         if (!clientHeigth) {
            clientHeigth = Math.max (docBody.clientHeight, parent ? parent.getContainer().height() : 0);
         }
         //Проверка сработает чуть раньше, чем мы увидим индикатор скролла (не в самом низу страницы, а на 3 размера индикатора раньше)
         return (clientHeigth + scrollTop >= scrollHeight - BOTTOM_OFFSET);
      },
      /**
   *  Общая проверка и загрузка данных для всех событий по скроллу
   */
      _checkForLoad: function(result){
         if (result && !this._nextLoad()) {
            this._removeLoadingIndicator();
         }
      },
      _onContainerScroll: function(event){
         var scrollTop = $(event.target).scrollTop(),
            off = Math.abs(this._loadingIndicator.offset().top + scrollTop - this.getContainer().height() - this.getContainer().offset().top),
            check = this._loadingIndicator ? scrollTop + cConstants.Browser.minHeight * 2 >= off : false;
         this._checkForLoad(check);
      },
      _onWindowScroll: function(event, target){
      //Может тут проверить на открыту. всплывашку RFA? и не грузить данные лишний раз....
      /* Если аргументов два, то в качестве event'a приходит забинденый элемент, у которого происходит скролл */
         this._checkForLoad(this._isBottomOfPage(arguments.length === 2 ? event[0] : null));
      },
      _onFAScroll: function(event, scrollOptions) {
         this._checkForLoad(scrollOptions.clientHeight + scrollOptions.scrollTop >= scrollOptions.scrollHeight - cConstants.Browser.minHeight);
      },
      _initDataSource: function() {
         if(this.isTree()) {
            cMerge(this._options.dataSource, {usePages: 'parts'});
         }
      },
      _initScrollRecordSet: function(){
         var cfg = cMerge( {}, this._options.dataSource, {clone: true}),
            self = this;
         cfg.usePages = 'parts';
         cfg.handlers = {
            'onBeforeLoad': this._onBeforeNextLoad.bind(this),
            'onAfterLoad': this._onNextDataLoaded.bind(this)
         };
         cfg.firstRequest = false;
         cfg.waitForPrevQuery = true;
         cfg.context = self.getRecordSet().getContext(); //А НАДО ЛИ??
         this._nowLoading = false;
         if (!this._currentRecordSet.hasNextPage(true)) {
            this._removeLoadingIndicator();
         }
         this._ready = cAttach.attachInstance('Deprecated/RecordSet', cfg).addCallback(function(instance){
            this._scrollRecordSet = instance;
            //синхронизируем фильтры текущего рекордсета и скроллрекордсета перед первой загрузкой, но не чистим filterParams
            this._scrollRecordSet.setQuery(cMerge(this._scrollRecordSet.getUpdatedQuery(), this._currentRecordSet.getQuery()), false, undefined, true);
            this._oldFilter =  this._scrollRecordSet.getQuery();
            this._scrollDeferred.callback(instance);
            this._currentRecordSet.subscribe('onPageChange', function(event, pageNum){
            // нужен из-за LoadNode, но так же срабатывает, когда ставим сами( плохой хак на страницу, но лучше пока нет
               if (pageNum > 0) {
                  self._scrollRecordSet.setPage(pageNum, true);
               }
            });
            //Для дерева не подписываемся на скролл и загружаем данные лишь по нажатию на кнопку "Ещё"
            if(!this.isTree()) {
               this._initScrollPagingEvents();
               this._loadBeforeScrollAppears();
            }
            return instance;
         }.bind(this));
      },
      _initScrollPagingEvents: function() {
         var topParent = this.getTopParent();

         if (cInstance.instanceOfModule(topParent, 'Lib/Control/FloatArea/FloatArea')) {
         //Если браузер лежит на всплывающей панели и имеет автовысоту, то скролл появляется у контейнера всплывашки (.parent())
            topParent.subscribe('onScroll', this._onFAScroll.bind(this));
         }
         var scrollableContainer = this.getContainer().closest('.ws-scrolling-content');
         if (scrollableContainer && scrollableContainer.length){
            this._scrollableContainer = scrollableContainer;
            this._scrollableContainer.bind('scroll', this._onWindowScrollHandler.bind(this, this._scrollableContainer));
         }
         else {
            $(window).bind('scroll', this._onWindowScrollHandler);
         }
         if (!this._isHeightGrowable()) {
            this.getContainer().find('.ws-browser-container').bind('scroll', this._onContainerScroll.bind(this));
         }
      },
      /**
    * Загрузка данных в скролл-рекордсет
    * @returns {boolean} true - если загрузка будет, false в противном случае
    * @private
    */
      _nextLoad: function(){
         var  pageNum;
         if (this.isHierarchy() && this._turn !== '' && this._turn !== 'OnlyLeaves' && this._turn !== 'BranchesAndLeaves') {
            return false;
         }
         //Пока решили не трогать isRecordFloatAreaOpen
         if (this._allowLoading && isElementVisible(this.getContainer()) &&
            !this._nowLoading && this._scrollRecordSet &&
            (this._scrollRecordSet.hasNextPage(true) || (this._firstLoad && this._currentRecordSet.hasNextPage(true)))) {
            pageNum = this._scrollRecordSet.getPageNumber() + 1;
            this._scrollRecordSet.setPage(pageNum, false, false);
            this._addLoadingIndicator();
            if (this.isTree()) {
               this._loadMoreButton.show();
            }
            return true;
         }
         this.getContainer().addClass('ws-ScrollPaging__dataLoaded');
         if (this.isTree()) {
            this._loadMoreButton.hide();
         }
         return false;
      },
      /**
    * Разрешить или запретить подгрузку данных по скроллу.
    * @param {Boolean} allow - true - разрешить, false - запретить
    * @param {Boolean} [noLoad] - true - не загружать сразу
    * @see scrollPaging
    * @see getScrollRecordSet
    */
      setAllowScrollLoading: function(allow, noLoad){
         this._allowLoading = allow;
         if (allow) {
            if (!noLoad && this._nextLoad()) {
               this._addLoadingIndicator();
               return;
            }
         } else {
            this._removeLoadingIndicator();
         }
      },
      /**
    * При начале загрузки добавляет индикатор в меню
    */
      _onBeforeNextLoad: function(){
         this._nowLoading = true;
         this.getContainer().removeClass('ws-DataViewAbstract__dataLoaded ws-ScrollPaging__dataLoaded');
      },
      /**
    * Обработчик загрузки данных в рекордсете
    * @param {Object} event Объект события
    * @param {Deprecated/RecordSet} recordSet Рекордсет, в котором произошла загрузка
    * @param {Boolean} isSuccess Успешно ли прошла загрузка
    * @param {Error} error Ошибка, которая могла появиться во время загрузки
    * @private
    */
      _onNextDataLoaded: function(event, recordSet, isSuccess, error){
         var scrollRecSetHasNextPage = this._scrollRecordSet.hasNextPage(true),
            isTree = this.isTree(),
            records,
            length;

         this._nowLoading = false;
         this._notify('onScrollDataLoaded', recordSet, isSuccess, error);
         if(isSuccess){
            records = recordSet.getRecords();
            this._firstLoad = false;
            this.getContainer().addClass('ws-DataViewAbstract__dataLoaded');
            //почему-то люди считают нормальным то, что в основной рекордсет не загрузились данные, а по скроллу вдруг начали подгружаться...
            //поэтому тут нам придется проверить были ли записи в основном рекодсете и скрыть текст отсутствия записей
            if(!this._currentRecordSet.getRecordCount() && records.length){
               if (this._emptyDataText) {
                  this._emptyDataBlock.addClass('ws-hidden');
               }
            }
            this._currentRecordSet.appendRecords(records, true);
            if (this._onBeforeRenderActions()) {
               this._drawLoadedRecords(records);
            }
            length = this._currentRecordSet.getRecords().length;
            if (length && length >= this.getPageSize()) {
               this._currentRecordSet.setPageSize(length, true);
            }
            if(!isTree) {
               this._loadBeforeScrollAppears();
            }
         }
         //Для дерева всегда скрываем индикатор загрузки
         if (isTree || (!isSuccess || (!this._currentRecordSet.hasNextPage(true) && !scrollRecSetHasNextPage))) {
            this._removeLoadingIndicator();

            if(isTree) {
               if(scrollRecSetHasNextPage) {
                  this._loadMoreButton.show();
               } else {
                  this._loadMoreButton.hide();
               }
            }
         }
      },
      _drawLoadedRecords: function(records){
         var container,lastTr, newElements;

         this._scrollRecordSet.rewind();
         if (!records.length) {
            return;
         }
         //TODO сделать дорисовку строк для дерева
         if(this.isTree()) {
            this._reloadBody();
         } else {
            lastTr = this._body.find('[rowkey]').eq(-1);

            //Сделаем временный tbody для правильной работы пользовательского рендера
            container = this._getBodyContainer().html(this._createRecordsTemplate(records, this._scrollRecordSet));
            this._applyRowRender(this._scrollRecordSet, container);
            newElements = container.children();

            //Если есть строка редактирование по месту, то нужно добавлять строки перед ней
            if (this._options.display.allowAddAtThePlace && lastTr.hasClass('ws-browser-row-before-add-at-place')) {
               newElements.insertBefore(lastTr);
            } else {
               lastTr.removeClass('ws-browser-table-row-last');
               newElements.eq(-1).addClass('ws-browser-table-row-last');
               this._body.append(newElements);
            }
            this.recalcBrowserOnDOMChange();
            this._notify('onAfterScrollPackRender');
         }
      },
      _onDataLoaded : function(event, recordSet, isSuccess, error){
         if (isSuccess) {
            var isTree = this.isTree();

            if (isTree && this._loadMoreButton) {
               this._loadMoreButton.hide();
            }
            if (!this._scrollRecordSet) {
            //Возможно нужно не только для дерева
               if(isTree) {
                  this._nowLoading = false;
                  this._removeLoadingIndicator();
               }
               this._initScrollRecordSet();
            }
            else {
            //ShowBranch вызывает LoadNode у currentRecordSet, и мы вообще не можем узнать, что смелся id, зато знаем, что звали загрузку и сделаем то же самое
               if (this._showBranch) {
                  this._showBranch = false;
                  this._scrollRecordSet.loadNode(this._currentRootId,  !(this._scrollRecordSet.contains(this._currentRootId) || this._isIdEqual(this._rootNode, this._currentRootId)), 1);
               }
               this._scrollRecordSet.rewind();
            }
         }
      },
      _loadBeforeScrollAppears: function() {
      //Костыльное решение. Оказывается, если я попросила 50 записей и мне отдали 2 - это нормально
      //Так что пока не появится скролл догружаем данные по очереди
      //Плохо затачиваться на конткретный класс. Если пользуемся window.scroll, то можно подгружатьл вниз пока высота
      //таблицы меньше высоты экрана, иначе смотрим на внутренний скролл по тому же принципу
         var contBrowser = this.getContainer().find('.ws-browser-container'),
            load = this._isHeightGrowable() ?  this.getContainer().height() < $(window).height() :
               contBrowser > contBrowser.find('> table').height();
         if (load){
            if (this._nextLoad()) {
               this._addLoadingIndicator();
            } else {
               this._removeLoadingIndicator();
            }
         } else {
            this._removeLoadingIndicator();
         }
      },
      _addLoadingIndicator: function(){
         if (!this._loadingIndicator ) {
            this._loadingIndicator = $('<img />', {
               'src': '/cdn/img/common/1.0.0/ajax-loader-indicator.gif',
               'class': 'ws-browser-scroll-loading-indicator' + (this.isTree() ? ' ws-hidden' : '')
            }).appendTo(this._browserContainer);
         } else {
            this._loadingIndicator.removeClass('ws-hidden');
         }
         this.recalcBrowserOnDOMChange();
      },
      _showLoadingIndicatorInTime: function(){
      //Тут  повявляется основной индикатор из браузера. По таймауту. Чтобы не было двух ромашек убираем эту.
         if (this._loadingIndicator) {
            this._loadingIndicator.addClass('ws-hidden');
         }
      },
      _clearTimeOutLoadingIndicator: function(){
         if (this._nowLoading) {
            this._addLoadingIndicator();
         }
      },
      /**
    * Удаляет индикатор загрузки
    * @private
    */
      _removeLoadingIndicator: function(){
         if( this._loadingIndicator && !this._loadingIndicator.hasClass('ws-hidden') && !this._nowLoading){
            this._loadingIndicator.addClass('ws-hidden');
            this.recalcBrowserOnDOMChange();
         }
      },
      _resetScrollRecordSet : function(){
         this._scrollRecordSet.setPage(1, true, false);
         this._currentRecordSet.setPageSize(this._options.display.recordsPerPage, true);
      },
      _reload: function () {
         this._nowLoading = true;
         if (this._currentRecordSet) {
            this._currentRecordSet.setPageSize(this._options.display.recordsPerPage, true);
         }
      },
      _folderEnterScroll: function(id, res) {
         this._removeLoadingIndicator();
         this._scrollRecordSet.abort(true);
         this._resetScrollRecordSet();
      //Загрузка будет в методе _folderEnter HV
      //this._scrollRecordSet.loadNode(id, false, 0, false);
      },
      _showBranchHierarchyScroll: function(){
         this._showBranch = true;
      },
      _onBeforeRecordUpdated: function(full, parents){

      //чтобы скролл продолжал отрабатывать или догрузить последнюю запись
         if (!this._scrollRecordSet.hasNextPage(true) && this._allowLoading) {
            this._currentRecordSet.setPageSize(this._currentRecordSet.getRecords().length + 1, true);
         }
      },
      _setPageSize: function(pageCount, noLoad){
         this._scrollRecordSet.setPageSize(pageCount, noLoad);
      },
      _onAfterDataViewLoad : function(){
         var self = this,
            noLoad = !self._currentRecordSet.hasNextPage(true);
         //filter может прийти неправильный, синхронизируем с текущим фильтром в рекордсете
         self._resetScrollRecordSet();
         //Загрузим ниже
         self.setAllowScrollLoading(true, true);
         self._nowLoading = !self._currentRecordSet.hasNextPage(true) ? false : self._nowLoading;
         if (noLoad) {
            self._removeLoadingIndicator();
         } else {
            self._addLoadingIndicator();
         }
         self._scrollRecordSet.setQuery(
            cMerge(self._scrollRecordSet.getQuery(), self._currentRecordSet.getUpdatedQuery()),
            true,
            undefined,
            noLoad);
         self.unsubscribe('onAfterLoad', self._onAfterDataViewLoadHandler);
      },
      _runQuery : function(filter, doClear, noLoad) {
         var self = this,
            onAbort = function(){
               self._nowLoading = false;
               self._scrollRecordSet.abort(true);
               //Восстановим предыдущий фильтр в скролл-рекордсете.
               self._scrollRecordSet.setQuery(self._oldFilter, true, undefined, true);
               self.unsubscribe('onAfterLoad', self._onAfterDataViewLoadHandler);
               self._currentRecordSet.unsubscribe('onAbort', onAbort);
               //TODO возможно потеряются фильтры?
               //Не нужно загружать свалившийся аборт.
               self.setAllowScrollLoading(true, true);
            };
         if (this._scrollRecordSet) {
         //Абортим текущий запрос в скролл-рекордсете
            this._scrollRecordSet.abort(true);
            this._oldFilter =  this._scrollRecordSet.getQuery();
            this._scrollRecordSet.setQuery(filter, true, undefined, true);
            //обнуляем запомненные страницы
            if(!noLoad) {
               this.setAllowScrollLoading(false);
            }

            /* Т.к. никто не знает, как это работает, добавляю костыльную проверку.
            Смысл в следующем, всегда, когда меняли фильтр, сбрасывалась и страница,
            даже если фильтр меняли без перезагрузки */
            if(!noLoad  || (noLoad && (this._scrollRecordSet.getPageNumber() !== this.getRecordSet().getPageNumber()))) {
               this._resetScrollRecordSet();
            }

            //Фильтр нам все равно надо ставить, а не вызывая загрузку данных мы это сделать не можем.
            // Но обязятельно вызывать загрузку после перезагрузки основного рекордсета (иначе записи потеряются)
            this.unsubscribe('onAfterLoad', self._onAfterDataViewLoadHandler);
            this.subscribe('onAfterLoad', self._onAfterDataViewLoadHandler);
            this._currentRecordSet.subscribe('onAbort', onAbort);
         }
      },
      _onResizeHandler: function() {

      },
      _expandAllScroll: function(withFolders, noLoad){
         this._nowLoading = true;
      },
      _clearExpandAllScroll: function(noLoad){
         this._nowLoading = false;
      },
      destroy: function() {
         if (this._scrollRecordSet) {
            if (this._scrollableContainer) {
               this._scrollableContainer.unbind('scroll', this._onWindowScrollHandler);
            }
            $(window).unbind('scroll', this._onWindowScrollHandler);
            this._scrollRecordSet.destroy();
         }
         if( this._loadingIndicator ){
            this._loadingIndicator.remove();
            this._loadingIndicator = undefined;
         }
         if (this._loadMoreButton) {
            this._loadMoreButton.destroy();
            this._loadMoreButton = undefined;
         }
      }
   });
});