/**
 * Created with JetBrains PhpStorm.
 * User: am.gerasimov
 * Date: 11.11.2014
 * Time: 13:34
 * To change this template use File | Settings | File Templates.
 */

define('Deprecated/Controls/TableView/plugins/PartScroll-plugin/PartScroll-plugin', [
   'Core/helpers/Hcontrol/isElementVisible',
   'Core/constants',
   'Deprecated/Controls/TableView/TableView'
], function(
   isElementVisible,
   cConstants,
   TableView
){

   'use strict';
   
   var TD_NOT_MOVABLE =
      (cConstants.browser.firefox && navigator && parseInt(navigator.userAgent.split("Firefox/")[1]) < 37) ||
      (cConstants.browser.isIE10 || cConstants.browser.isIE12);

   /**
    * @class Deprecated/Controls/TableView/plugins/PartScroll-plugin/PartScroll-plugin
    * @extends Deprecated/Controls/TableView/TableView
    * @plugin
    * @public
    * @author Герасимов А.М.
    * @deprecated
    */
   TableView.PartScrollPlugin = TableView.extendPlugin(/** @lends Deprecated/Controls/TableView/plugins/PartScroll-plugin/PartScroll-plugin.prototype */{
      $withoutCondition: ['_rowsEventHandler'],
      $protected: {
         _options: {
            display: {
               /**
                * @cfg {Boolean} Использовать ли широкий скролл
                *
                * @example
                * <pre>
                *     <option name="wideScroll">true</option>
                * </pre>
                * @remark
                * Скроллбар будет показываться по всей видимой ширине браузера, а не только между скроллируемыми столбцами.
                * @see startScrollColumn
                * @see usePartScroll
                * @see showScroll
                * @group Scroll
                */
               wideScroll: false,
               /**
                * @cfg {Boolean} Использовать частичный скролл при нехватке места
                *
                * @example
                * <pre>
                *     <option name="usePartScroll">true</option>
                * </pre>
                * @see wideScroll
                * @see startScrollColumn
                * @see showScroll
                * @group Scroll
                */
               usePartScroll : false,
               /**
                * @cfg {Number} Количество столбцов слева, которые будут не скролируемы
                *
                * @example
                * <pre>
                *     <option name="startScrollColumn">3</option>
                * </pre>
                * @see wideScroll
                * @see usePartScroll
                * @see showScroll
                * @group Scroll
                */
               startScrollColumn: 0
            }
         },
         _partScrollContainer: undefined,       //Контейнер скроллбара
         _currentPosition: 0,                   //Текущая позиция ползунка
         _movableElements: undefined,           //Элементы, которые двигаем
         _rightArrow: undefined,                //Контейнер для правой стрелки
         _leftArrow: undefined,                 //Контейнер для левой стрелки
         _thumbWrapper: undefined,              //Обёртка ползунка
         _thumb: undefined,                     //Контейнер для ползунка
         _thumbMargin: null,                    //Отступ ползунка
         _ratio: null,                          //Соотношение скролируемой области и скроллбара
         _isScrollVisible: false,               //Видимость скроллбара
         _stopMovingCords: {
            right: 0,
            left : 0
         }
      },
      $condition: function() {
         return this._options.display.usePartScroll;
      },
      $constructor: function(){
         this.subscribe('onAfterRender', this._onAfterRenderHandler);
         if(this._headContainer.find('.ws-browser-head-results')) {
            this.subscribe('onResultUpdate', this._findMovableCells.bind(this));
         }
      },
      /**
       * Устанавливает ширину скролла
       * @private
       */
      _setContainerWidth: function() {
         var width = this._data[0].offsetWidth,
            headWidth = this._container[0].offsetWidth,
            outOfRangeWidth = width - headWidth,
            correctWidth = 0;

         if(!this._options.display.wideScroll) {
            var tr = this._headContainer.find('tr.ws-browser-head-top:first'),
               notScrolledTds = !tr.length ?
                  this._body.find('[rowkey]').eq(0).find('.ws-browser-cell-with-noScroll') :
                  tr.find('.ws-browser-cell-with-noScroll');

            this._partScrollContainer.addClass('ws-browser-scroll-notWide');
            for(var i = 0, len = notScrolledTds.length; i < len; ++i) {
               correctWidth += notScrolledTds[i].clientWidth;
            }
            this._partScrollContainer.css('margin-left', correctWidth);
         }
         //когда посчитали ширину скрола, посчитаем соотношение,
         //как нам двигать скролируемый контент относительно ползунка
         this._ratio = outOfRangeWidth/(headWidth - correctWidth - this._thumbWrapper.width() - this._thumbMargin*2);
         this._partScrollContainer.width(headWidth-correctWidth);
         this._stopMovingCords = {
            right : this._partScrollContainer.get(0).clientWidth-this._thumbWrapper.get(0).clientWidth-this._thumbMargin*2,
            left :  correctWidth
         }
      },
      _onAfterRenderHandler: function() {
         var needShowScroll;

         if(this._columnMap.length > 0) {
            needShowScroll = this._checkContainerSize();
            //Если есть чекбоксы, им нужно тоже повесить класс
            if(this._needShowSelectionCheckbox() && this._options.display.startScrollColumn > 0) {
               this._rootElement.find('.ws-browser-checkbox-holder, .ws-browser-checkbox-emptyCell')
                  .addClass('ws-browser-cell-with-noScroll');
            }

            this._isScrollVisible ?
               needShowScroll ?
                  this._refreshScroll() :
                  this._hideScroll() :
               needShowScroll ?
                  this.showScroll() :
                  this._hideScroll();
         }
      },
      _bindHeaderEvents: function() {
         var self = this;
         if(self._options.display.showHead) {
            this._head.find('[columnId]').each(function() {
               if(parseInt(this.getAttribute('columnId')) + 1 <= self._options.display.startScrollColumn) {
                  $(this).addClass('ws-browser-cell-with-noScroll');
               } else {
                  $(this).addClass('ws-browser-cell-with-scroll');
               }
            });
         }
         this._findMovableCells();
      },
      /** Проставляет классы, находит нужные ячейки и т.д.
       * Обновляет скролл под текущий браузер
       */
      _refreshScroll: function() {
         this._findMovableCells();
         this._setContainerWidth();
         this.moveScrollAndColumns(0);
      },

      /** Проверяет размер таблицы и контейнера **/

      _checkContainerSize: function() {
         return this._container[0].offsetWidth < this._data[0].offsetWidth;
      },
      /**
       * Ищет ячейки, которые нужно двигать
       * @private
       */
      _findMovableCells: function() {
         /* FF до 37 версии не понимает свойство position у табличных элементов(кроме table)
            в 37 версии этот баг был поправлен */
         this._movableElements =
            TD_NOT_MOVABLE ?
               this._container.find('.ws-browser-cell-with-scroll').children() :
               this._container.find('.ws-browser-cell-with-scroll');
      },
      /**
       * Для столбцов, которые скролим необходимо добавить класс
       * @private
       */
      _mapColumns: function(){
         //Временно нужно для интеграционных тестов
         if(typeof this._options.display.startScrollColumn === 'string') {
            this._options.display.startScrollColumn = parseInt(this._options.display.startScrollColumn, 10);
         }
         for (var i in this._columnMap){
            if(this._columnMap.hasOwnProperty(i)) {
               if (this._options.display.usePartScroll && this._columnMap[i].index+1 > this._options.display.startScrollColumn){
                  this._columnMap[i].className += ' ws-browser-cell-with-scroll';
               } else {
                  this._columnMap[i].className += ' ws-browser-cell-with-noScroll';
               }
            }
         }
      },
      /**
       * Создает основную структуру скролла
       * @private
       */
      _createContainer: function() {
         var scrollContainer = [
            '<div class="ws-browser-scrollContainer ws-hidden">',
            '<div class="ws-browser-scrollArrow-left icon-24 icon-DayBackward  icon-disabled"></div>',
            '<div class="ws-browser-scrollWrapper">',
            '<div class="ws-browser-scroll"></div>',
            '</div>',
            '<div class="ws-browser-scrollArrow-right icon-24 icon-DayForward icon-primary action-hover"></div>',
            '</div>'].join('');

         this._headContainer.append(scrollContainer);

         this._partScrollContainer = this._headContainer.find('.ws-browser-scrollContainer');
         this._rightArrow = this._partScrollContainer.find('> .ws-browser-scrollArrow-right');
         this._leftArrow = this._partScrollContainer.find('> .ws-browser-scrollArrow-left');
         this._thumbWrapper = this._partScrollContainer.find('> .ws-browser-scrollWrapper');
         this._thumb = this._thumbWrapper.find('.ws-browser-scroll');

         this._container.addClass('ws-browser-with-partScroll');
         this._data.parent().css('overflow-x', 'hidden');
         this._thumbMargin = parseInt(this._thumbWrapper.css('margin-left'), 10);
      },
      _onResizeHandler: function() {
         var needShow = this._checkContainerSize(),
            rightSideStopCords = this._stopMovingCords.right,
            self = this;

         function setScrollPosOnResize() {
            if(rightSideStopCords < self._currentPosition) {
               self._currentPosition = rightSideStopCords;
               self._setThumbPosition(self._currentPosition);
            }
         }


         if(this._isScrollVisible) {
            if(needShow) {
               this._setContainerWidth();
               setScrollPosOnResize();
            } else {
               this._hideScroll()
            }
         } else if(needShow && this._count) {
            this.showScroll();
            setScrollPosOnResize();
         }
      },
      _hideScroll: function() {
         if(this._isScrollVisible) {
            this._isScrollVisible = false;
            this._partScrollContainer.addClass('ws-hidden');
            this._moveColumns(0);
         }
      },
      /**
       * Показывает скролл, но только если он необходим
       * @see wideScroll
       * @see usePartScroll
       * @see startScrollColumn
       */
      showScroll: function() {
         if(!this._isScrollVisible && isElementVisible(this._container)) {
            this._isScrollVisible = true;
            this._partScrollContainer.removeClass('ws-hidden');
            this._setContainerWidth();
            this._findMovableCells();
         }
      },
      _addClassesToHeader: function() {
         var self = this;
         if(self._options.display.showHead) {
            this._head.find('[columnId]').each(function() {
               if(parseInt(this.getAttribute('columnId')) + 1 <= self._options.display.startScrollColumn) {
                  $(this).addClass('ws-browser-cell-with-noScroll');
               } else {
                  $(this).addClass('ws-browser-cell-with-scroll');
               }
            });
         }
         this._findMovableCells();
      },
      /**
       * Инициализируем события скрола
       * @private
       */
      _initEvents: function() {
         var self = this;

         this._rightArrow.bind('click', self._scrollRightArrowHandler.bind(self));
         this._leftArrow.bind('click', self._scrollLeftArrowHandler.bind(self));

         if(self.isTree()) {
            self.subscribe('onFolderOpen', self._onTreeOpenBrach);
         }
         //При фокусе на обертку, которая чуть больше по высоте, навешиваем класс ховера
         //Обёртка нужна для того, чтобы пользователю было легче зацепится за ползунок
         this._thumbWrapper.bind('mouseenter mouseleave', function(e) {
            self._thumb.toggleClass('ws-browser-scroll-clicked', e.type === 'mouseenter');
         });
         this._thumbWrapper.bind('mousedown', function(e) {
            var startX = e.pageX - self._thumb.offset().left;

            self._options.display.rowOptions && self._uninitRowOptions();
            self._thumb.addClass('ws-browser-scroll-clicked');
            cConstants.$body.addClass('ws-unSelectable');
            cConstants.$doc.bind('mousemove.wsScrollMove', self._scrollMoveHandler.bind(self, startX));
            cConstants.$doc.bind('mouseup.wsScrollMove', self._scrollMoveEnd.bind(self));
         });
      },
      /**
       * Ставит положение ползунка
       * @param position
       * @private
       */
      _setThumbPosition: function(position) {
         this._thumbWrapper.get(0).style.left = position + 'px';
      },
      /**
       * При открытии ветки дерева, навешивает на новые элементы классы
       * @param event
       * @param rowKey
       * @param newRowKeys
       * @param rows
       * @private
       */
      _onTreeOpenBrach: function(event, rowKey, newRowKeys, rows) {
         var tds = rows.find('td'),
            srolledCells = [];
         if(tds.length) {
            for (var i = 0, len = tds.length; i < len; i++) {
               if(parseInt(tds[i].getAttribute('coldefindex'), 10) < this._options.display.startScrollColumn) {
                  $(tds[i]).addClass('ws-browser-cell-with-noScroll');
               } else {
                  $(tds[i]).addClass('ws-browser-cell-with-scroll');
                  srolledCells.push(tds[i]);
               }
            }
            if(TD_NOT_MOVABLE) {
               srolledCells = $(srolledCells).children();
            }
            //Оказывается, выборка jQuery не совсем массив, и метод concat с ней не работает
            this._movableElements = $.merge(this._movableElements, srolledCells);
            $(srolledCells).css('left', -this._currentPosition*this._ratio);
         }
      },
      /**
       * Обработчик движения ползунка
       * @param {Number} startPageX
       * @param event
       * @private
       */
      _scrollMoveHandler: function(startPageX, event) {
         this.moveScrollAndColumns(event.pageX - startPageX - this._partScrollContainer[0].getBoundingClientRect().left-this._thumbMargin);
      },
      /**
       * Проверяет позицию ползунка, меняет активность стрелок
       * Если ползунок пытается уйти за пределы контейнера, возвращает его обратно
       * @returns {boolean}
       * @private
       */
      _checkPosition: function() {
         var rightSideStopCords = this._stopMovingCords.right;

         if (this._currentPosition <= 0){
            this._toggleActiveArrow(this._leftArrow, false);
            this._currentPosition = 0;
         } else if (!this._leftArrow.hasClass('icon-primary')) {
            this._toggleActiveArrow(this._leftArrow, true);
         }
         //Смотрю clientWidth, это значительно быстрее чем .width()
         if (this._currentPosition >= rightSideStopCords) {
            this._toggleActiveArrow(this._rightArrow, false);
            this._currentPosition = rightSideStopCords;
         } else if (!this._rightArrow.hasClass('icon-primary')) {
            this._toggleActiveArrow(this._rightArrow, true);
         }
      },
      /**
       *
       * @param {jQuery} arrow Стрелка, которую включаем/выключаем
       * @param {Boolean} enable Если true - делаем стрелку активной, если false - неактивной
       * @private
       */
      _toggleActiveArrow: function(arrow, enable) {
         arrow.toggleClass('icon-primary action-hover', enable)
            .toggleClass('icon-disabled', !enable);
      },
      /**
       * Срабатывает, когда мы закончили скроллинг (отпустили кнопку мыши)
       * @private
       */
      _scrollMoveEnd: function() {
         if(this._options.display.rowOptions) {
            this._initRowOptions();
         }
         this._thumbWrapper.removeClass('ws-browser-scroll-clicked');
         cConstants.$body.removeClass('ws-unSelectable');
         cConstants.$doc.unbind('.wsScrollMove');
      },
      /**
       * Обработчик клика по правой стрелке
       * @private
       */
      _scrollRightArrowHandler: function() {
         this.moveScrollAndColumns(this._currentPosition + (this._partScrollContainer[0].clientWidth / 100) * 5);
      },
      /**
       * Обработчик клика по левой стрелке
       * @private
       */
      _scrollLeftArrowHandler: function() {
         this.moveScrollAndColumns(this._currentPosition - (this._partScrollContainer[0].clientWidth/100)*5);
      },
      moveScrollAndColumns : function(postition) {
         this._currentPosition = postition;
         this._checkPosition();
         this._setThumbPosition(this._currentPosition);
         this._moveColumns(this._currentPosition);
      },
      /**
       * Двигает нужные колонки в браузере
       * @param {Number} position
       * @private
       */
      _moveColumns: function(position) {
         //Делаю через нативный style, это быстрее в 2-3! раза чем .css()
         //особенно заметно, когда у нас много элементов
         var movePosition = -position*this._ratio;
         for(var i= 0, len = this._movableElements.length; i < len; i++) {
            this._movableElements[i].style.left = movePosition + 'px';
         }
      },
      /**
       * Отписка от событий
       */
      _unInitEvents: function() {
         this._thumbWrapper.unbind('mouseenter mouseleave mousedown');
         this._rightArrow.unbind('click');
         this._leftArrow.unbind('click');
         this.unsubscribe('onAfterRender', this._onAfterRenderHandler);
         if(this.isTree()) {
            this.unsubscribe('onFolderOpen', this._onTreeOpenBrach);
         }
      },
      destroy: function() {
         this._unInitEvents();
         this._movableElements = [];
         this._partScrollContainer = undefined;
         this._rightArrow = undefined;
         this._leftArrow = undefined;
         this._thumbWrapper = undefined;
         this._thumb = undefined;
      }
   });
});