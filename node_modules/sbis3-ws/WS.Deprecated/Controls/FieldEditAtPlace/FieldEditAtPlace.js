define('Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace', [
   'Core/helpers/Hcontrol/trackElement',
   'SBIS3.CONTROLS/Utils/InformationPopupManager',
   'Lib/Control/ModalOverlay/ModalOverlay',
   'Lib/Control/AreaAbstract/AreaAbstract',
   'Core/core-instance',
   'Core/helpers/Function/debounce',
   'Core/helpers/Object/find',
   'Core/helpers/Function/forAliveOnly',
   'Core/WindowManager',
   'Core/IoC',
   'Core/Deferred',
   'Core/CommandDispatcher',
   'Core/constants',
   'Lib/Control/CompoundControl/CompoundControl',
   'html!Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace',
   'Deprecated/Controls/FieldString/FieldString',
   'Deprecated/Controls/FieldDropdown/FieldDropdown',
   'Core/helpers/Function/callNext',
   'Core/detection',
   'Lib/Control/Dialog/Dialog',
   'Deprecated/Controls/FieldInteger/FieldInteger',
   'Deprecated/Controls/FieldMoney/FieldMoney',
   'Deprecated/Controls/FieldText/FieldText',
   'Deprecated/Controls/FieldDate/FieldDate',
   'Deprecated/Controls/FieldLink/FieldLink',
   'Deprecated/Controls/Button/Button',
   'css!Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace',
   'i18n!Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace'
], function(
   trackElement,
   InformPopManager,
   CModalOverlay,
   CAreaAbstract,
   cInstance,
   debounce,
   objectFind,
   forAliveOnly,
   WindowManager,
   IoC,
   cDeferred,
   CommandDispatcher,
   cConstants,
   compoundControl,
   dotTplFn,
   fString,
   fDropDown
) {

   'use strict';

   /**
       * @class Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace
       * @extends Lib/Control/CompoundControl/CompoundControl
       * @author Крайнов Д.О.
       * @public
       * @control
       * @designTime actions /design/design
       * @designTime plugin /design/DesignPlugin
       * @initial
       * <component data-component='Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace' style='width: 100px; height: 40px;'>
       *    <div>ИНН</div><component data-component='Deprecated/Controls/FieldString/FieldString' name='ИНН'></component>
       * </component>
       * @category Fields
       * @deprecated Используйте класс {@link SBIS3.CONTROLS/EditAtPlace}.
       */
   var FieldEditAtPlace = compoundControl.extend(/** @lends Deprecated/Controls/FieldEditAtPlace/FieldEditAtPlace.prototype */{
      /**
          * @event onBeforeEdit Событие перед редактированием
          * @param {Core/EventObject} eventObject Дескриптор события.
          */
      /**
          * @event onBeforeCreate Событие перед созданием контрола
          * @param {Core/EventObject} eventObject Дескриптор события.
          */
      /**
          * @event onAfterCreate Событие после создания контрола
          * @param {Core/EventObject} eventObject Дескриптор события.
          */
      /**
          * @event onApply При подтверждении редактирования
          * Событие срабатывает при нажатии:
          * <ol>
          *    <li>на кнопку сохранения,</li>
          *    <li>OK в диалоге подтверждения,</li>
          *    <li>клавиши Tab после обхода всех контролов в шаблоне редактирования заголовка закладки,</li>
          *    <li>клавиши Enter по окончании редактирования в заголовке закладки.</li>
          * </ol>
          * Если обработчик не настроен и включена опция {@link saveOnApply}, то вызовется команда {@link Deprecated/Controls/DialogRecord/DialogRecord#save save}.
          * @param {Core/EventObject} eventObject Дескриптор события.
          * @param {Object} values Хэш-мэп Пары имя-значение из контекста.
          * @example
          * После выбора пользователя по идентификатору получить ФИО:
          * <pre>
          *     control.subscribe('onApply', function (event, values) {
          *        var dRes = new cDeferred();
          *        new BLObject('Пользователь').call('ПолучитьПоИд', {'Ид': values['ИдПользователя']}, BLObject.RETURN_TYPE_ASIS).addCallback( function (record) {
          *           values['ФИО'] = record.get('ФИО');
          *           dRes.callback(values);
          *        })
          *        event.setResult(dRes);
          *     });
          * @see saveOnApply
          * @see onAfterApply
          */
      /**
          * @event onAfterApply Событие после подтверждения редактирования
          * @param {Core/EventObject} eventObject Дескриптор события.
          * @param {Object} values Хэш-мэп Пары имя-значение из контекста (возможно, измененного после вызова события onApply).
          * @see onApply
          */
      /**
          * @event onCancel Событие на отмену редактирования
          * @param {Core/EventObject} eventObject Дескриптор события.
          */
      /**
          * @event onAfterCancel Событие после отмены редактирования
          * @param {Core/EventObject} eventObject Дескриптор события.
          */
      $protected: {
         _options: {
            /**
                * @cfg {Boolean} Режим работы
                * Возможные значения:
                * <ol>
                *    <li>false - без редактирования по месту, обычные поля ввода;</li>
                *    <li>true - с редактированием по месту.</li>
                * </ol>
                */
            inPlaceEditMode: false,
            /**
                * @cfg {Boolean} Режим редактирования заголовка закладки
                * Возможные значения:
                * <ol>
                *    </li>false - обычное редактирование (во всплывающей панели);</li>
                *    <li>true - редактирование закладки по месту.</li>
                * </ol>
                */
            isTabEditor: false,
            /**
                * @cfg {Boolean} Показывать панель управления редактированием (кнопки "ок", "отмена") в режиме редактирования заголовка
                * @see isTabEditor
                */
            showControlPanel: false,
            /**
                * @cfg {Boolean} Выполнять ли команду save
                * Выполнять ли команду {@link Deprecated/Controls/DialogRecord/DialogRecord#save save} при подтверждении редактирования.
                * @see onApply
                */
            saveOnApply: true,
            /**
                * @cfg {Content} Содержимое области
                */
            content: ''
         },
         _undoBuffer: undefined,       // буфер для отмены редактирования
         _controlPanel: undefined,     // область с кнопками ок и отмена
         _dummy: null,                 // заглушка под область
         _editArea: null,              // область для панели редактирования
         _editorWrapper: null,         // область редакторов, внутри области панели редактирования
         _fieldStringArea: null,
         _hideTimeout: null,
         _stringControls: undefined,   // контролы для редактирования
         _$StringControls: undefined,  // jQuery collection
         _state: 'contents',           // 'contents' || 'edit'
         _zIndex: 0
      },

      _dotTplFn: dotTplFn,

      $constructor: function () {
         var self = this;
         self._publish('onBeforeEdit', 'onBeforeCreate', 'onAfterCreate', 'onApply', 'onAfterApply', 'onCancel', 'onAfterCancel');

         self._notify('onBeforeCreate');
         //сделаем контекст "прозрачным", чтобы контролы внутри FieldEditAtPlace работали с контекстом родителя FieldEditAtPlace
         self._craftedContext = false;
         self._context = self._context.getPrevious();
         this._keysWeHandle[cConstants.key.esc] = true;
         self._onChildFocusOutHandler = function(event, focus, focusedControl){
            self._onChildFocusOut(event, focusedControl);
         };
      },

      _setStringControlsEditMode: function (mode) {
         if (mode === undefined) {
            mode = true;
         }
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            if (this._stringControls[i].setEditAtPlace) {
               this._stringControls[i].setEditAtPlace(mode);
            }
         }
      },

      init: function () {

         FieldEditAtPlace.superclass.init.call(this);

         var self = this;
         this._undoBuffer = {};
         this._dummy = this._container.find('.ws-FieldEditAtPlace__dummy');
         this._editArea = this._container.find('.ws-FieldEditAtPlace__editArea');
         this._editorWrapper = this._editArea.find('.ws-FieldEditAtPlace__editors');
         this._controlPanel = this._container.find('.ws-FieldEditAtPlace__controlPanel');
         this._fieldStringArea = this._container.find('.ws-FieldEditAtPlace__string');

         this._stringControls = self.getChildControls().filter(function (inst) {
            return (inst instanceof fString || inst instanceof fDropDown) &&
                  inst && inst.getContainer &&
                  inst.getContainer().parents('.ws-FieldEditAtPlace__string').length;
         });
         var $StringControls = $(this._stringControls.map(
            function (elem) {
               return elem.getContainer();
            }));
         this._$StringControls = $StringControls.map(function () {
            return this.toArray();
         });
         //Отображаем кнопки подтверждения, если это не редактор вкладки, либо редактор вкладки с флагом showControlPanel
         if ( ! this._options.isTabEditor || (this._options.isTabEditor && this._options.showControlPanel)) {
            try {
               var applyButton = this.getChildControlByName(this.getName() + '_apply');
               applyButton.subscribe('onActivated', function () {
                  if (!self._checkOnEditNewRecordInTabButtons()) {
                     self._finishEdit();
                  }
               });
            } catch (e) {
               IoC.resolve('ILogger')
                  .error('FieldEditAtPlace', rk('Произошла ошибка при загрузке дочерних контролов области быстрого редактирования') + ' ' + this.getName(), e);
            }
         }
         this._controlPanel.find('.ws-FieldEditAtPlace__cancel').click(function (event) {
            event.stopImmediatePropagation();
            // Перевод фокуса на кнопку, чтобы увести фокус с контролов внутри области редактирования.
            // Фиксит ошибку с выпадающими списками, которые не закрываются при отмене редактирования.
            applyButton.setActive(true);
            self._finishEdit(false, true);
         });

         if (this._options.inPlaceEditMode) {
            this._setStringControlsEditMode(true);
         }

         var subscribeOnClick = function (ctrl) {
            ctrl.subscribe('onClick', function () {
               if (!self._options.enabled) {
                  return;
               }
               if (self._options.isTabEditor &&
                     self.getContainer().parents('.ws-tabs-button-inactive, .ws-TabButtons__button__state-inactive').length) {
                  return;
               }
               self._showEditArea(ctrl);
            });
         };
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            subscribeOnClick(this._stringControls[i]);
         }
         $('.ws-underline', this._container.get(0)).click(function(){
            self._showEditArea(self.getChildControls()[0]);
         });

         this.subscribe('onInit', function () {
            // сохранение первоначальных значений полей в буфер
            self._saveContextTo(self._undoBuffer);
         });
         if (this._options.isTabEditor) {
            this._fieldStringArea.bind('mousedown.' + this.getId() + ' wsmousedown.' + this.getId(), function (e) {
               e.stopImmediatePropagation();
            });
         } else {
            this._editArea.appendTo($('body'));
            this._editArea.bind('mousedown.' + this.getId() + ' wsmousedown.' + this.getId(), function (e) {
               e.stopImmediatePropagation();
            });
            this._editArea.keydown(function (e) {
               var result = self._notify('onKeyPressed', e);
               if (e.which in self._keysWeHandle && result !== false && self._isAcceptKeyEvents()) {
                  var res = self._keyboardHover(e);
                  if (!res) {
                     e.preventDefault();
                     e.stopPropagation();
                     return false;
                  }
                  return res;
               }
            });
            // нужно забиндить клик по высплывающей области, чтобы не терять фокус с текущего контрола
            this._editArea.bind('click', this._onClickHandler.bind(this));
         }
         self._notify('onAfterCreate');

         // если область редактирования лежит на окне или плавающей панели,
         // то при клике они помещаются на передний план и перекрывают панель
         var parent = this.getTopParent();
         if (parent && parent.moveToTop && !!objectFind(cConstants.WINDOW_CLASSES, cInstance.instanceOfModule.bind(undefined, parent))) {
            var parentMoveToTop = parent.moveToTop;
            parent.moveToTop = function(){
               if (parentMoveToTop && self.moveToTop) {
                  parentMoveToTop.apply(parent, arguments);
                  self.moveToTop.apply(parent, arguments);
               }
            };
            self.subscribe('onDestroy', function(){
               parent.moveToTop = parentMoveToTop;
               parentMoveToTop = undefined;
            });
         }
         // Блокируем показ нашего диалога подтверждения, если уже показан такой же диалог, но у RecordFloatArea
         if (cInstance.instanceOfModule(parent, 'Deprecated/Controls/RecordFloatArea/RecordFloatArea')) {
            this._recordArea = parent;
            this._recordArea.subscribe('onBeforeShowConfirmDialog', function onBeforeShowConfirmDialog(event, record) {
               self._confirm = true;
            }).subscribe('onConfirmDialogSelect', function onConfirmDialogSelect(event, result) {
               if (result && self._state !== 'contents') {
                  self._showContents();
               }
               self._confirm = false;
            });
         }
      },
      moveToTop: function () {
         if (this._options.inPlaceEditMode && this._state === 'edit' && !this._confirm) {
            this._movePanelToTop();
         }
      },
      /**
          * Динамически получать zIndex из менеджера окон для панели
          * @private
          */
      _movePanelToTop: function () {
         if (this._options.isTabEditor || !this._options.inPlaceEditMode) {
            return;
         }
         if (this._zIndex) {
            WindowManager.releaseZIndex(this._zIndex);
         }
         this._zIndex = WindowManager.acquireZIndex(true);
         WindowManager.setVisible(this._zIndex);
         CModalOverlay.adjust();
         if (this._editArea) {
            this._editArea.css('z-index', this._zIndex);
         }
      },

      /**
          * Рассчитываем отступ сверху у панели управления редактировнием так,
          * чтобы кнопки располагались напротив самого верхнего поля ввода.
          * @private
          */
      _calcControlPanelMargin: function() {
         if(this._options.isTabEditor || this._controlPanelMarginCalculated) {
            return;
         }
         this._controlPanelMarginCalculated = true;
         var pTop = this._editorWrapper.get(0).getBoundingClientRect().top,
            minTop = Infinity;
         for (var i = 0; i < this._$StringControls.length; i++) {
            var cTop = this._$StringControls.get(i).getBoundingClientRect().top;
            minTop = cTop < minTop ? cTop : minTop;
         }
         if (minTop === Infinity || minTop < pTop) {
            minTop = pTop;
         }
         this._controlPanel.css('margin-top', minTop - pTop);
      },
      /**
          *
          *
          * Находит следующий активный контрол в зависимости от того как нажат таб
          * @return {Boolean} результат выполнения функции
          */
      detectNextActiveChildControl: function () {
         var res = FieldEditAtPlace.superclass.detectNextActiveChildControl.apply(this, arguments);
         if (!res) {
            if (!this._finishEdit()) {
               return this._activeChildControl;
            }
         }
         return res;
      },
      /**
          *  Обработка клавиатурных нажатий
          * @param {Event} e
          * @returns {Boolean}
          * @private
          */
      _keyboardHover: function (e) {
         var key = e.which;
         if (this._options.inPlaceEditMode) {
            if (key === cConstants.key.enter && this._state === 'edit') {
               if (!this._checkOnEditNewRecordInTabButtons()) {
                  this._finishEdit();
               }
               return false;
            }
            if (key === cConstants.key.esc && this._state === 'edit') {
               this._finishEdit(false);
               return false;
            }
         }
         var res = FieldEditAtPlace.superclass._keyboardHover.apply(this, arguments);
         if (res === undefined) {
            res = true;
         }
         return res;
      },
      /**
          * Возвращает, может ли область получать фокус
          * @return {Boolean}
          */
      canAcceptFocus: function () {
         return false;
      },
      onBringToFront: function () {
         if (!this._options.inPlaceEditMode || (this._options.inPlaceEditMode && this._state === 'edit')) {
            if (!this._confirm) {
               this.moveToTop();
            }
            FieldEditAtPlace.superclass.onBringToFront.call(this);
         }
      },
      /**
          * Начать редактирование по месту в контроле
          * @param {Object} [control] контрол для активации
          */
      activateArea: function (control) {
         this._showEditArea(control || this.getChildControls()[0]);
      },
      /**
          * Завершить редактирование области
          * @param {Boolean} [fCancel] Если false - отмена действий пользователя
          * @param {Boolean} [noConfirm] Не выводить диалог подтверждения при отмене действий из кода
          */
      close: function(fCancel, noConfirm) {
         this._finishEdit(fCancel, noConfirm);
      },
      /**
          * Установка режима редактирования области
          * @param mode
          */
      setInPlaceEditMode: function (mode) {
         this._options.inPlaceEditMode = !!mode;
         this._setStringControlsEditMode(mode);
      },

      /**
          * Получение режима редактирования области
          * @returns {Boolean}
          */
      getInPlaceEditMode: function () {
         return this._options.inPlaceEditMode;
      },

      /**
          * Установка контекста из объекта
          * @param obj {Object} объект со значениями (либо контекст), который нужно установить в поля ввода
          * @private
          */
      _setContextFrom: function (obj) {
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            var cnt = this._stringControls[i],
               name = cnt.getName();
            if (name && cnt.setValue && cnt.getValue && (cnt.getValue() !== obj[name])) {
               cnt.setValue(obj[name]); // TODO проверить остальные параметры
            }
         }
      },

      /**
          * Сохранение текущих значений полей ввода (контекста) в объект
          * @param obj {Object} объект, куда сохранить контекст
          * @private
          */
      _saveContextTo: function (obj) {
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            var cnt = this._stringControls[i],
               name = cnt.getName();
            if (name && cnt.getValue) {
               obj[name] = cnt.getValue();
            }
         }
      },

      /**
          * Проверка значений из контекста для полей ввода на изменение
          * @returns {boolean} true - контекст изменился
          * @private
          */
      _isCtxChanged: function () {
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            var cnt = this._stringControls[i],
               name = cnt.getName();
            if (name && cnt.getValue) {
               if (this._undoBuffer[name] !== cnt.getValue()) {
                  return true;
               }
            }
         }
         return false;
      },

      /**
          * Отмена редактирования, реверт значений в контексте.
          * @private
          */
      _cancelEdit: function () {
         this._notify('onCancel');
         this._setContextFrom(this._undoBuffer);
         this._notify('onAfterCancel');
      },

      /**
          * Установка полей ввода из контекста
          * @private
          */
      _applyValues: function () {
         var values = {},
            res,
            self = this,
            setRes = function (res) {
               self._setContextFrom(res);
               self._notify('onAfterApply', res);
            };
         this._saveContextTo(values);

         // нотифаится событие onApply,
         // обработчики события могут изменить результат редактирования,
         // который затем вставляется в контекст и обновит поля ввода
         res = this._notify('onApply', values);
         if (res) {
            if (res instanceof cDeferred) {
               res.addCallback(setRes);
            } else {
               setRes(res);
            }
         } else {
            setRes(values);
            // если нет обработчиков события onApply, сохраняем рекорд диалога, где лежит наша область
            if (!this._eventBusChannel.hasEventHandlers('onApply') && this._options.saveOnApply) {
               CommandDispatcher.sendCommand(this, 'save', undefined, true);
            }
         }
      },

      /**
          * Установка enabled для всех редактируемых контролов
          * @param enabled {Boolean} устанавливаемое состояние контрола
          * @private
          */
      _setEnabledStringControls: function (enabled) {
         for (var i = 0, l = this._stringControls.length; i < l; i++) {
            this._stringControls[i].setEnabled(enabled);
         }
      },
      /**
          * Метод начинает сопровождать контейнер
          * @private
          */
      _startTrackWrapper: function() {
         trackElement(this._container).subscribe('onMove', function (event, position) {
            this._editArea.css({
               top: position.top - 4,
               left: position.left - 4
            });
         }, this);
      },
      /**
          * Метод перестает сопровождать контейнер
          * @private
          */
      _stopTrackWrapper: function() {
         trackElement(this._container, false);
      },

      getZIndex: function() {
         return this._zIndex;
      },

      /**
          * Отображение шаблона редакторов/активация полей ввода для редактирования
          * @param control {Lib/Control/Control} контрол, который начали редактировать
          * @private
          */
      _showEditArea: function (control) {
         if (!this._options.inPlaceEditMode || this._state === 'edit' || !this.isEnabled()) {
            return;
         }
         var self = this;

         var res = this._notify('onBeforeEdit');
         if (res !== false) { // разрешили редактировать
            this._state = 'edit';
            this._saveContextTo(this._undoBuffer);
            this._setStringControlsEditMode(false);
            this._container.removeClass('ws-FieldEditAtPlace__idle').addClass('ws-FieldEditAtPlace__editing');
            if (this._options.isTabEditor) {
               this._controlPanel.removeClass('ws-hidden');
            } else {
               var
                  dummySize = {
                     'width': this._container.width(),
                     'height': this._container.height()
                  },
                  size = {
                     'width': this._options.autoWidth ? 'auto' : dummySize.width + (cConstants.browser.isIE ? 1 : 0),
                     'height': this._options.autoHeight ? 'auto' : dummySize.height + (cConstants.browser.isIE ? 1 : 0)
                  };
               this._dummy.css(dummySize).removeClass('ws-hidden');
               this._editorWrapper.css(size);
               this._fieldStringArea.prependTo(this._editorWrapper);
               this._startTrackWrapper();
               // IE9 fix: Перед показом панельки посчитать её положение на экране.
               var bcr = this._container.get(0).getBoundingClientRect(),
                  position = {
                     left: bcr ? bcr.left + cConstants.$win.scrollLeft() : 0,
                     top: bcr ? bcr.top + cConstants.$win.scrollTop() : 0
                  };
               this._editArea.css({
                  top: position.top - 4,
                  left: position.left - 4
               });
               this._editArea.removeClass('ws-hidden');
               this._calcControlPanelMargin();
               this._movePanelToTop();
            }

            //событие на отмену редактирования от оверлея
            this.subscribeTo(CModalOverlay, 'onClick', function(event) {
               //Если оверлей показан для области редактирования, то нужно её закрыть
               if (CModalOverlay.isShownForWindow(self) ) {
                  event.setResult(true);
                  self._finishEdit(false);
               }
            });

            //событие на отмену редактирования от кликов по документу
            this.subscribe('onFocusOut', this._onChildFocusOutHandler);

            control.setActive(true);
            // открыть выпадающий список
            if (control instanceof fDropDown) {
               control.getContainer().find('.custom-select').trigger('click');
            }

            this._notifyOnSizeChanged(this, this, true);
         }
      },
      setActive: function(active, shiftKey, noFocus, focusedControl) {
         FieldEditAtPlace.superclass.setActive.apply(this, arguments);
         // todo: Тюрин в отпуске. Ничего хитрее придумать не удалось. Событие onChildFocusOut не стреляет, другим способом поле закрыть не удается.
         if (!active && focusedControl && this._state === 'edit') {
            this._onChildFocusOut(undefined, focusedControl);
         }
      },
      /**
          * Обработчик потери фокуса. Должен отрабатывать через debounce, асинхронно и для живых компонентов.
          * Это единственный верный способ подружить редактирование по месту с нативным фокусом.
          */
      _onChildFocusOut: debounce.call(forAliveOnly(function (event, ctrl) {
         // нельзя останавливать редактирование, если контрол, на котором произошёл клик (или его родитель),
         // открыт из области быстрого редактирования
         var self = this;
         var checkOpenerRecursive = function (control) {
            if (control) {
               var opener = null,
                  topParent = control.getTopParent();
               if (control.getOpener) {
                  opener = control.getOpener();
               } else {
                  var parentArea = control.getParentByClass(CAreaAbstract);
                  opener = parentArea ? parentArea.getOpener() : null;
               }
               if (!opener) {
                  opener = topParent.getOpener ? topParent.getOpener() : null;
               }
               if (opener) {
                  var field = opener;
                  // поищем себя среди родителей opener-а
                  while (field && field !== self) {
                     field = field.getParentByClass(FieldEditAtPlace);
                  }
                  // не нашли - рекурсивно поищем себя у opener-а
                  return (field === self) ? true : checkOpenerRecursive(opener);
               }
               return false;
            }
         };
         if (checkOpenerRecursive(ctrl)) {
            return;
         }

         // Костыль! Если мы лежим внутри RecordFloatArea при клике по браузеру не отменять редактирование,
         // т.к. DataViewAbstract наверняка захочет сменить запись в нашей RecordFloatArea, позволим ему следать это.
         // Если область редактирования по месту закрыта "на крестик", то не нужно вызывать _checkOnEditNewRecordInTabButtons
         // которая приводит к не нужной валидации.

         if ((this._state == 'edit') && this._checkOnEditNewRecordInTabButtons()) {
            return;
         } else if (this._recordArea) {
            if (cInstance.instanceOfModule(ctrl, 'Deprecated/Controls/DataViewAbstract/DataViewAbstract') && ctrl === this._recordArea.getOpener()) {
               return;
            }
         }
         // При потере фокуса заголовком (нажатие на пустую область или какой-либо элемент страницы)
         // происходит сохранение введенных данных. Инф. окна с вопросом о сохранении показываться не должны.
         if (this._options.isTabEditor && cInstance.instanceOfModule(this.getParent(), 'Deprecated/Controls/TabButtons/TabButtons')) {
            // Ниже подпорка для клика по кнопке скрытия панели с нашей областью.
            // Ошибка в разработку от 15.09.2015 №1037766
            // Сохраняется изменение названия контрагента при закрытии карточки без сохранения.
            // https://inside.tensor.ru/opendoc.html?guid=7d062f91-e0f9-4976-9527-4bf0e1e3b5a8
            if(!(ctrl && cInstance.instanceOfModule(ctrl, "Deprecated/Controls/Button/Button") && (this._recordArea === ctrl.getParent()) &&
            // Так же проверяем, что связанная запись не изменена
            // Ошибка в разработку от 10.12.2015 №1200402
            // Учет.Баланс.БухСправка (во всех документах) Дата не изменяется, при сохранение изменений после на...
            // https://inside.tensor.ru/opendoc.html?guid=1f254816-a4f3-40fe-a249-71f83c017bd2
                  !( this._recordArea && this._recordArea.getRecord() && this._recordArea.getRecord().isChanged() ))) {
               this._finishEdit(true);
            } else {
               this._finishEdit(false, true);
            }
         } else {
            this._finishEdit(false);
         }
      }), 0),

      /**
          * Функция проверяет родителя FieldEditAtPlace и, если это TabButtons и имеется recordArea с новой записью, то не сохраняем свой value в Record и на БЛ
          * @returns {boolean} Возвращает true, если контрол лежит внутри TabButtons и открыта новая запись
          * @private
          */
      _checkOnEditNewRecordInTabButtons: function() {
         if (cInstance.instanceOfModule(this.getParent(), 'Deprecated/Controls/TabButtons/TabButtons') && this._recordArea && this._recordArea.isNewRecord()) {
            //Возвращаем из "onApply" value - при текущей логике это приводит к отмене сохранения записи на БЛ
            this.once('onApply', function (event, value) {
               event.setResult(value);
            });
            this._apply();
            return true;
         }
      },

      /**
          * Скрываем панель редактирования, показываем область быстрого редактирования
          * @private
          */
      _showContents: function (nofocus) {
         this._state = 'contents';
         if (this._options.inPlaceEditMode) {
            this._setStringControlsEditMode(true);
            this._container.addClass('ws-FieldEditAtPlace__idle').removeClass('ws-FieldEditAtPlace__editing');
            if (!nofocus) {
               this._container.focus(); // IE focus bugfix.
            }
         }
         if (this._options.isTabEditor) {
            this._controlPanel.addClass('ws-hidden');
         } else {
            this._stopTrackWrapper();
            this._dummy.addClass('ws-hidden');
            this._fieldStringArea.appendTo(this._container);
            this._editArea.addClass('ws-hidden');
            WindowManager.setHidden(this._zIndex);
            CModalOverlay.adjust();
            this.unsubscribe('onFocusOut', this._onChildFocusOutHandler);
         }
         $(document).unbind('.' + this.getId());
         this._notifyOnSizeChanged(this, this, true);
      },

      /**
          * Валидация, применение изменений после редактирования
          * @returns {boolean}
          * @private
          */
      _apply: function () {
         if (this.validate(undefined, undefined, true)) {
            this._showContents();
            this._applyValues();
            return true;
         }
         return false;
      },

      /**
          * Отмена редактирования
          * @private
          */
      _cancel: function () {
         this._cancelEdit();
         this._showContents(true);
      },

      /**
          * Открывает диалог подтверждения при отмене радактирования.
          * @returns {Core/Deferred} deferred на закрытие модального диалога подтверждения.
          * @private
          */
      _openConfirmDialog: function () {
         var deferred = new cDeferred();
         InformPopManager.showConfirmDialog({
            message: rk('Сохранить изменения?'),
            details: rk('Чтобы продолжить редактирование, нажмите "Отмена".'),
            hasCancelButton: true,
            opener: this
         }, function() {
            deferred.callback('yesButton');
         }, function() {
            deferred.callback('noButton');
         }, function() {
            deferred.callback(undefined);
         });

         return deferred;
      },
      /**
          * Обработка завершения редактирования области
          * @param [fCancel] {Boolean} Если false - отмена действий пользователя
          * @param [force] {Boolean} не выводить диалог подтверждения при отмене
          * @returns {Boolean} действие завершено
          * @private
          */
      _finishEdit: function (fCancel, force) {
         var self = this,
            lastActive = this.getActiveChildControl();
         if (this._state === 'contents') {
            return true;
         }
         if (fCancel !== false) {
            return this._apply();
         }
         if (force || !this._isCtxChanged()) {
            this._cancel();
            return;
         }
         if (this._confirm) {
            return;
         }
         this._confirm = true;

         this._openConfirmDialog().addCallback(function (result) {
            self._movePanelToTop();
            switch (result) {
               case 'yesButton':
                  self._apply();
                  break;
               case 'noButton':
                  self._cancel();
                  break;
               case 'cancelButton':
                  lastActive && lastActive.setActive(true);
               default:
            }
            self._confirm = false;
         });
         return true;
      },

      destroy: function () {
         this._stopTrackWrapper();
         this._editArea.remove();
         WindowManager.releaseZIndex(this._zIndex);
         FieldEditAtPlace.superclass.destroy.call(this);
      }
   });

   return FieldEditAtPlace;
});
