/**
 * Created with JetBrains PhpStorm.
 * User: tm.baeva
 * Date: 21.04.13
 * Time: 20:09
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/FieldNumeric/FieldNumeric', [
   "Core/defaultRenders",
   "Core/constants",
   "Deprecated/Controls/FieldString/FieldString",
   "html!Deprecated/Controls/FieldNumeric/FieldNumeric",
   'Core/helpers/String/escapeASCII'
], function(defaultRenders, cConstants, FieldString, dotTplFn, escapeASCII) {

   'use strict';

   /**
    * Поле ввода числовых значений
    *
    * @class Deprecated/Controls/FieldNumeric/FieldNumeric
    * @extends Deprecated/Controls/FieldString/FieldString
    * @author Крайнов Д.О.
    * @control
    * @public
    * @initial
    * <component data-component='Deprecated/Controls/FieldNumeric/FieldNumeric' style='width: 100px'>
    * </component>
    * @category Fields
    * @designTime actions Deprecated/Controls/FieldString/design/design
    * @designTime plugin /design/DesignPlugin
    * @ignoreOptions trim password maxLength
    * @deprecated Используйте класс {@link SBIS3.CONTROLS/NumberTextBox}.
    */
   var FieldNumeric = FieldString.extend(/** @lends Deprecated/Controls/FieldNumeric/FieldNumeric.prototype */{
      $protected : {
         _emptyNegative : false,
         _options : {
            /**
             * @cfg {Number} Количество знаков после запятой
             * Отрицательное значение опции - количество знаков после запятой не ограничено
             *
             */
            decimals: 0,
            /**
             * @cfg {Number} Количество знаков до запятой
             Отрицательное значение опции - количество знаков до запятой не ограничено
             *
             */
            integers: 16,
            /**
             * @cfg {Boolean} Определяет пустое значение
             * true - null
             * false - 0
             */
            defaultValueIsNull: false,
            /**
             * @cfg {Boolean} Прятать пустые копейки
             *
             */
            hideEmptyDecimals: false,
            /**
             * @cfg {Boolean} Показывать пустые копейки при получении фокуса если включён параметр hideEmptyDecimals
             *
             */
            showEmptyDecimalsOnFocus: true,
            /**
             * @cfg {Boolean} Показывать или нет разделители триад
             * Т.е. 123 456 201
             *
             */
            delimiters: true,
            /**
             * @cfg {Boolean} Показывать только неотрицательное значения или произвольные
             *
             */
            notNegative : false,
            cssClassName: 'ws-field-numeric',
            cssClass: 'ws-field-numeric'
         }
      },
      _dotTplFn: dotTplFn,
      $constructor : function(){
         if (this._options.decimals > 0) {
            this._options.decimals = parseInt(this._options.decimals, 10);
         }
         if (this._options.integers > 0) {
            this._options.integers = parseInt(this._options.integers, 10);
         }
         if (!this._options.hideEmptyDecimals && !this._options.showEmptyDecimalsOnFocus) {
            this._options.showEmptyDecimalsOnFocus = true;
         }
      },

      _modifyOptions: function(options) {
         FieldNumeric.superclass._modifyOptions.call(this, options);

         options.escapeASCII = escapeASCII;
         options.defaultRenders = defaultRenders;

         return options;
      },
      /**
       * Инициализация событий
       * @protected
       */
      _initEvents: function() {
         var self = this;
         // в первую очередь нужно выполнить инициализоцию событий у родителя
         FieldNumeric.superclass._initEvents.apply(this, arguments);
         this._inputControl
            .keypress(function(event){
               if (!self._isChangeable()) {
                  return false;
               }
               var
                  key = event.which || event.keyCode; // Firefox как нимимум хочет и то, и другое...
               if (key && !event.ctrlKey && (key > 40 || key == 39) ||
                  self._extractKey(event) == cConstants.key.space ||
                  key <= 40 && event.shiftKey) {
                  if (/[0-9]/.test(String.fromCharCode(key))) {
                     self._typing(event);
                  }
                  if (/\.|,/.test(String.fromCharCode(key))) {
                     // Delete is not period FIX
                     // У точки и у delete 46й код
                     // Chromium & IE вообще не зайдут сюда по delete
                     // В Opera & FF при delete - event.which == 0
                     if (event.which) {
                        self._pointFunc();
                     }
                  }
                  if (event.which === 0 && event.keyCode == 45) { // insert case, not minus
                     return true;
                  }
                  if (/[\-]/.test(String.fromCharCode(key))){
                     self._negativeValue();
                  }
                  return ( !event.which && (
                  key == cConstants.key.f5    || // F5, не отменяем действие по-умолчанию
                  key == cConstants.key.f12   || // F12,не отменяем действие по-умолчанию
                  key == cConstants.key.left  || // не отменяем arrow keys (влево, вправо)
                  key == cConstants.key.right ||
                  key == cConstants.key.end   || // не отменяем home, end
                  key == cConstants.key.home
                  ));
               }
               return true;
            })
            .keydown(function(event) {
               if (!self.isEnabled()) {
                  return true;
               }
               if (
                  event.keyCode == cConstants.key.backspace ||
                  event.keyCode == cConstants.key.del && !(event.ctrlKey && event.shiftKey)
               ) {
                  if (event.keyCode == cConstants.key.del && event.ctrlKey) {
                     event.preventDefault();
                  }
                  self._typing(event);
                  return false;
               }
               return true;
            })
            .blur(function(){
               this.value = this.value.replace(/\.$/g, '');
               self._emptyNegative = false;
               self._isBluring = true;
               self._setValueInternal(self.getValue()); // При выходе убираем отображение «-0» => «0»
            });
         this.subscribe('onFocusIn', function(){
            if(self._options.hideEmptyDecimals && self.isEnabled()) {
               self._setValueInternal(self.getValue());
            }
         });
      },
      /**
       * Если значение пустое, то возвращает null или '0'(зависит от defaultValueIsNull). В противном случае возвращает исходное значение.
       * @param val исходное значение
       * @returns Преобразованное значение.
       * @protected
       */
      _selectNullValue: function(val) {
         return val === '' || val === null ? (this._options.defaultValueIsNull ? null : '0') : val;
      },
      /**
       * Возвращает дефолтное значение
       * @returns {*}
       * @protected
       */
      _getDefaultValue: function() {
         return typeof(this._options.value) === 'function'
            ? this._selectNullValue(this._options.value())
            : this._selectNullValue(this._options.value);
      },
      /**
       *
       * Метод изменения количества знаков после запятой.
       * @param {Number} c Количество знаков после запятой. -1 — неограниченное количество.
       * @public
       */
      setDecimals: function(c) {
         this._options.decimals = c >= 0 ? c : -1;
         this.setValue(this.getValue(), undefined, true);
      },
      /**
       *
       * Количество чиство цифр после запятой.
       * @returns {Number} -1 если неограничено или натуральное число — ограничение.
       * @public
       */
      getDecimals: function() {
         return this._options.decimals;
      },
      /**
       *
       * Метод изменения количества знаков в целой части.
       * @param {Number} integers Количество в целой части. -1 — неограниченное количество.
       * @public
       */
      setIntegers: function(integers) {
         this._options.integers = integers >= 0 ? integers : -1;
         this.setValue(this.getValue());
      },
      /**
       *
       * Количество чиство цифр после запятой.
       * @returns {Number} -1 если неограничено или натуральное число — ограничение.
       * @public
       */
      getIntegers: function() {
         return this._options.integers;
      },
      _negativeValue : function(){
         if (!this._options.notNegative){
            var
               value = this.getValue(),
               valIsEmpty = !value || value == 0,
               car = this._getCaret(),
               pos = value ? Math.max( car[0] + (value < 0 ? - 1 : + 1), 0) : car[0],
               pos2 = value ? car[1] + (value < 0 ? - 1 : + 1) : car[1];
            if(valIsEmpty) {
               this._emptyNegative = !this._emptyNegative;
               pos = this._emptyNegative;
               pos2 = pos + 1;
            }
            this._setValueInternal(-value);
            this._inputControl.change();
            if (valIsEmpty) {
               this._inputControl.val((this._emptyNegative ? '-' : '') + this._inputControl.val());
            }
            this._setCaret(pos,pos2);
         }
      },
      /**
       * Метод отвечающий за ввод символов с клавиатуры
       * @param event событие нажатия клавиши
       * @private
       */
      _typing : function(event){
         var
            keyCode = event.which,
            // массив положений курсора
            caretPos = this._getCaret(),
            // положение курсора начала выделения
            beginCaretPos = caretPos[0],
            // плоложение курсора конца выделения
            endCaretPos = caretPos[1],
            buf = [], buf2,
            val = this._inputControl.get(0).value,
            // символ из кода нажатой клавиши
            symbol = String.fromCharCode(keyCode),
            curVal = this._curValue(),
            // позиция точки
            dotPos = val.indexOf('.'),
            // количество символов после запятой
            decimals = this._options.decimals > 0 && !this._options.showEmptyDecimalsOnFocus ? -1 : this._options.decimals,
            hasMinus = /\-/.test(val) ? 1 : 0,
            // длина значения
            curValLength = curVal === '' || curVal === null ? (decimals > 0 ? decimals + 1 : 0) : (this._curval + '').length,
            betweenFixed = undefined,
            // количество пробелов, если есть триады
            spacesCount;

         if (dotPos == -1) {
            dotPos = val.length;
         }
         spacesCount = dotPos - val.substr(0,dotPos).replace(new RegExp(' ','g'),'').length;
         if (!this._options.readOnly && keyCode == cConstants.key.backspace && beginCaretPos == endCaretPos && beginCaretPos > 0) {
            --beginCaretPos;
            if (val.charAt(beginCaretPos) == ' ') {
               --beginCaretPos;
               --endCaretPos;
            }
         }
         if (!this._options.readOnly && keyCode == cConstants.key.del && beginCaretPos == endCaretPos && endCaretPos < curValLength) {
            ++endCaretPos;
            if (val.charAt(beginCaretPos)==' ') {
               ++beginCaretPos;
               ++endCaretPos;
            }
         }
         // beginCaretPos и endCaretPos могуть быть равны, только если это не выделение
         if (beginCaretPos != endCaretPos) {
            // если начало выделения это пробел,
            // то передвинуть начало выделения вправо на один символ
            if (val.charAt(beginCaretPos) == ' ') {
               beginCaretPos++;
            }
            // если конец выделения это пробел,
            // то передвинуть конец выделения влево на один символ
            if (beginCaretPos != endCaretPos && val.charAt(endCaretPos-1) == ' ') {
               endCaretPos--;
            }
         }
         if ( beginCaretPos == endCaretPos && (
               decimals > 0 && curValLength == endCaretPos && curValLength > decimals ||
               this._options.integers > 0 && this._options.integers + spacesCount + hasMinus <= dotPos && beginCaretPos <= dotPos // Не перезаписываем целые числа при достижении лимита
            )
         ) {
            return;
         }
         buf.push(val.substring(0, beginCaretPos));
         if (/[0-9]/.test(symbol)) {
            buf.push(symbol);
         }
         // Если точка внутри выделения ....
         if (beginCaretPos != endCaretPos &&  curValLength - beginCaretPos >= (decimals + 1) && curValLength - endCaretPos <= decimals && decimals > 0) {
            betweenFixed = true;  // ... и фиксированное количество знаков после точки
         } else if (dotPos != -1 && beginCaretPos <= dotPos && endCaretPos > dotPos) {
            betweenFixed = false; // ... и количество знаков после точки произвольное
         }
         if (betweenFixed !== undefined){
            buf.push('.');
            var
               clearedDecimals = endCaretPos - (betweenFixed ? curValLength - decimals : dotPos + 1),
               newVal;
            buf2 = buf.slice();
            if (betweenFixed === true) {                               // Поддерживаем количество знаков после запятой
               buf.push('000000000000'.substr(0, clearedDecimals)); // Вместо удалённых после точки символов пишем нули
            }
            buf.push(val.substr(endCaretPos));
            buf2.push(val.substr(endCaretPos));
            if (buf2.join('') === '.') {
               newVal = '.';
            } else {
               newVal = buf.join('');
            }
            this._setValueInternal(newVal);
            this._inputControl.change();
            if(this._curval) {
               dotPos = this._curval.indexOf('.');
               if (dotPos == -1) {
                  dotPos = this._curval.length;
               }
               this._setCaret(dotPos);
            }
            return;
         }
         // Если правили после точки при фиксированом количестве знаков там, то поддерживаем их количество
         if (curValLength - endCaretPos <= decimals && decimals > 0) {
            buf.push('000000000000'.substr( 0, endCaretPos-beginCaretPos + (/[0-9]/.test(symbol) ? -1 : 0) ));
         }
         buf.push(val.substring(curValLength - endCaretPos <= decimals && beginCaretPos == endCaretPos ? endCaretPos + 1 : endCaretPos));
         val = buf.join('');
         this._isKeypress = true;
         this._setValueInternal(val);
         this._inputControl.change();
         if (this._emptyNegative && this.getValue() > 0) {
            this.setValue(-this.getValue());
            this._emptyNegative = false;
         }
         if (keyCode != cConstants.key.backspace) {
            if (curValLength - endCaretPos <= decimals && curValLength > decimals) {
               beginCaretPos++;
               endCaretPos++;
            }
         } else if (curValLength - endCaretPos == decimals - 1) {
            endCaretPos--;
         }
         this._caretPos(curValLength - beginCaretPos, curValLength - endCaretPos);
      },
      /**
       * Высчитывает позицию каретки и устанавливает каретку в новое положение
       * @param {Number} beginPosSelection позиция начала выделения
       * @param {Number} endPosSelection позиция конца выделения
       */
      _caretPos: function(beginPosSelection, endPosSelection){
         var
            curentValueLength = (this._curval + '').length,
            caretPos;
         if (beginPosSelection < 0) {
            beginPosSelection = 0;
         }
         if (endPosSelection < 0) {
            endPosSelection = 0;
         }
         //в дробной части при удалении остаются нули, поэтому устанавливаем каретку в beginPosSelection
         caretPos = beginPosSelection !== endPosSelection && beginPosSelection < this.getDecimals() && this._options.showEmptyDecimalsOnFocus
            ? beginPosSelection
            : endPosSelection;
         this._setCaret(curentValueLength - caretPos);
      },
      _pointFunc: function(){
         var
            v = this._inputControl.val(),
            i = v.indexOf('.');
         if (this._options.decimals !== 0 && i == -1) {
            var
               caret = this._getCaret(),
               b = caret[0],
               e = caret[1],
               res = [];

            res.push(v.substring(0,b));
            res.push(v.substr(e));
            this._inputControl.val(res.join('.'));
            this._setCaret(b + 1);
         } else if (this._options.decimals !== 0) {
            if (v === '') {
               this._inputControl.val('.');
               i = 1;
            }
            this._setCaret(i + 1);
         }
      },
      /**
       * привязка "внутренностей" контрола к верстке
       * @protected
       */
      _bindInternals : function(){
         this._inputControl = this._container.find('.input-text-field');
         this._createPlaceholder();
      },
      /**
       * Возвращает массив содержащий координаты выделения
       * @return {Array} массив содержащий координаты выделения
       */
      _getCaret : function(){
         var
            obj = this._inputControl.get(0),
            b, e, l;
         if (document.selection){ // IE
            var range = document.selection.createRange();
            l = range.text.length;
            range.moveStart('textedit', -1);
            e = range.text.length;
            range.moveEnd('textedit', -1);
            b = e - l;
         } else {
            b = obj.selectionStart;
            e = obj.selectionEnd;
         }
         return [b,e];
      },
      /**
       * Выставляет каретку в переданное положение
       * @param {Number}  pos    позиция, в которую выставляется курсор
       * @param {Number} [pos2]  позиция правого края выделения
       */
      _setCaret: function(pos, pos2){
         pos2 = pos2 || pos;
         var obj = this._inputControl.get(0);
         if (document.selection){              // IE
            var r = obj.createTextRange();
            r.collapse(true);
            r.moveStart('character', pos);
            r.moveEnd('character', pos2-pos); // Оказывается moveEnd определяет сдвиг, а не позицию
            r.select();
         } else {
            obj.setSelectionRange(pos, pos2);
            obj.focus();
         }
      },
      /**
       * Получить чистое значение.
       * Приводит форматированную строку к числовому виду,
       * в обратном случае возвращает null
       * @return {Number|null}
       * @protected
       */
      _notFormatedVal : function(){
         var val = parseFloat((this._curval + '').replace(/ /g, ''));
         if (!isNaN(val)) {
            return val;
         }
         return null;
      },
      /**
       * Обрезать пустые копейки
       * @param {String} value входное значение
       * @param {Number} idx индекс дробной части, до которого вырезать нули
       * @returns {String} value обработанное значение на выходе
       * @private
       */
      _clipEmptyDecimals: function(value, idx){
         var res, dotPos;
         if (value === null) {
            return value;
         }
         dotPos = value.indexOf('.');
         if (dotPos !== -1) {
            if (!idx) {
               res = /\.?0+$/.exec(value.substr(dotPos));
               idx = res ? res.index : -1;
            }
            if(idx !== -1) {
               value = value.substr(0,dotPos+idx);
            }
         }
         return value;
      },
      /**
       * Обработка числового значения
       * @param {String} value входное значение
       * @returns {String} value обработанное значение на выходе
       * @protected
       */
      _valueInternalProcessing: function(value) {
         var v = defaultRenders.numeric(
            value,
            this._options.integers,
            this._options.delimiters,
            this._options.decimals,
            this._options.notNegative,
            this._options.maxLength
         );
         if (this._emptyNegative && (parseInt(value,10)||v === null)) {
            this._emptyNegative = false;
         }
         // если опционально задано скрытие нулей после запятой или поле неактивно
         if ( this._options.hideEmptyDecimals && (!this._options.showEmptyDecimalsOnFocus || (!this.isActive() || this._isBluring))) {
            this._isBluring = false;
            var dotPos = /\./.exec(value),
                idx = 0; //индекс до которого удалять дробную часть
            if (this._isKeypress && dotPos && dotPos.index+1 !== value.toString().length) { //если во время ввода есть дробная часть
               idx = value.toString().substr(dotPos.index).length; //расчитываем сколько цифр оставить в дробной части
            }
            v = this._clipEmptyDecimals(v, idx);
         }
         this._isKeypress = false; //обнуляемся тут, чтобы при потере фокуса не думал, что метод вызывается по нажатию клавиш
         return FieldNumeric.superclass._valueInternalProcessing.apply(this, [v]);
      }
   });

   return FieldNumeric;

});
