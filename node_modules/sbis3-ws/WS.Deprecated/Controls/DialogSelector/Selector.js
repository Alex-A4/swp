/**
 * Created by tm.baeva on 04.12.13.
 */
define('Deprecated/Controls/DialogSelector/Selector', [
   'require',
   "Core/IoC",
   'Core/Context',
   'Core/core-merge',
   'Core/ParallelDeferred',
   "Core/Deferred",
   "Core/core-instance",
   "i18n!Deprecated/Controls/DialogSelector/Selector"
], function(
   require,
   IoC,
   Context,
   cMerge,
   ParallelDeferred,
   cDeferred,
   cInstance
) {

   'use strict';

   /**
    * Описание логики выбора из диалога/панели.
    * Selector используется полем связи.
    * @mixin Deprecated/Controls/DialogSelector/Selector
    * @author Крайнов Д.О.
    * @public
    * @deprecated Используйте класс {@link https://wi.sbis.ru/docs/js/SBIS3/CONTROLS/Action/Selector/SelectorController/}.
    */
   var selectorMixinConfig = /** @lends Deprecated/Controls/DialogSelector/Selector.prototype */ {
      $protected: {
         _browser: null,
         _data: null,
         _afterRenderHandler: undefined,
         _selectionConfirmHandler: undefined,
         _dRender: null,
         _readySetupBrowser: null,
         _canceled: {},
         _options: {
           /**
            * @cfg {String} Тип выбираемых записей
            *
            * Опция задаёт тип записей, которые можно выбирать в данном представлении данных.
            * @example
            * <pre>
            *     <option name="selectionType">node</option>
            * </pre>
            * @variant node Только узлы
            * @variant leaf Только листья
            * @variant all Узлы и листья, по умолчанию
            * @see setSelectionType
            */
            selectionType: 'all',
           /**
            * @cfg {Array} Массив первичных ключей выбранных записей
            *
            * @see selectedRecords
            */
            currentValue: [],
           /**
            * @cfg {Boolean} Выделить флаги в связанном представлении данных у переданных в Selector записей
            *
            * Опция имеет смысл, если в связанном представлении данных {@link Deprecated/Controls/TableView/TableView#showSelectionCheckbox включено отображение флагов}.
            * Возможные значения:
            * <ul>
            *    <li>true - выделить переданные записи;</li>
            *    <li>false - не выделять.</li>
            * </ul>
            * @see selectedRecords
            */
            selectCurrentValue: true,
           /**
             * @cfg {Boolean} При открытии диалога открыть папку с выбранными записями
             *
             * Возможные значения:
             * <ul>
             *    <li>true - Открыть</li>
             *    <li>false - Не открывать</li>
             * </ul>
             */
            needToShowBranch: true,
           /**
            * @cfg {Array} Массив выбранных записей (Deprecated/Record)
            * @see setResult
            * @see currentValue
            * @see selectCurrentValue
            */
            selectedRecords: null,
            selectorFieldLink: false,
           /**
            * @cfg {Boolean} Разрешить множественный выбор записей
            *
            * Возможные значения:
            * <ul>
            *    <li>true - разрешён выбор нескольких записей одновременно;</li>
            *    <li>false - выбор только одной записи.</li>
            * </ul>
            * @example
            * <pre>
            *     <option name="multiSelect">true</option>
            * </pre>
            */
            multiSelect: false
         }
      },
      $constructor: function(){
         var self = this;
         self._readySetupBrowser = new cDeferred();
         this._publish('onChange');
         if( !(self._dRender instanceof cDeferred) ) {
            //Для случая выезжающей панели заполним _dRender
            self._dRender = new cDeferred();
            self.subscribe('onAfterLoad', function(){
               self._dRender.callback();
            });
         }
         this._afterRenderHandler = function(){
            var browser = this;
            if(this.isLoading() && self._options.currentValue && self._options.currentValue instanceof Array){
               var values = self._options.currentValue,
                   showBranch;
               if (this.getRecordSet().getRecords().length > 0 || this.getContainer().find('.ws-browser-empty').is(':visible')){
                  self._options.currentValue = undefined;
                  if(values[0] !== undefined && this.isHierarchyMode()){
                     var records = self._options.selectedRecords,
                         record,
                         branchKey;
                     for (var i = 0, len = records.length; i < len; i++) {
                        if (records[i] && records[i].getKey() === values[0]) {
                           record = records[i];
                           break;
                        }
                     }
                     try {
                        if (record) {
                           branchKey = record.isBranch() ? values[0] : record.getParentKey();
                           if (branchKey !== undefined) {
                              showBranch = self._options.needToShowBranch ? this.showBranch(branchKey) : undefined;
                              if (self._options.selectCurrentValue && showBranch instanceof cDeferred) {
                                 showBranch.addCallback(function(){
                                    if(browser.isMultiSelect()) {
                                       browser.setSelection(values);
                                    }
                                 });
                              }
                           }
                        }
                     } catch (e) {
                        IoC.resolve('ILogger').log('Selector', rk('Попытка чтения параметров иерархической записи не удалась'));
                     }
                  }
                  if (self._options.selectCurrentValue && values && showBranch === undefined){
                     if(this.isMultiSelect()) {
                        this.setSelection(values);
                     }
                  }
               }
            }
         };
         this._selectionConfirmHandler = function (event, result) {
            var values = self._options.selectedRecords,
                canceled = self._canceled;
            if (self._options.selectorFieldLink && self._options.multiSelect && values && values.length) {
               if (result && result.length) {
                  for (var i = 0, len = result.length; i < len; i++) {
                     if (!self._foundRecordByPK(values, result[i])) {
                        values.push(result[i]);
                     }
                  }
               }
               if (canceled && typeof canceled === 'object') {
                  for (var rec in canceled) {
                     if (!self._foundRecordByPK(result, rec)) {
                        for (var j = 0, lenValues = values.length; j < lenValues; j++) {
                           if (values[j].getKey() == rec) {
                              values.splice(j, 1);
                              break;
                           }
                        }
                     }
                  }
               }
               self._notify('onChange', values);
            } else {
               self._notify('onChange', result);
            }
         };
         this._dRender.addCallback(function(v){
            var childControls = self.getChildControls(),
                find = false;
            for(var i = 0, l = childControls.length; i < l; i++){
               var childControl = childControls[i];
               if (cInstance.instanceOfModule(childControl, 'Deprecated/Controls/DataViewAbstract/DataViewAbstract') && childControl.getName() !== 'requestsView') {
                  find = true;
                  self.setBrowser(childControl);
                  break;
               }
            }
            if(find === false){
               self._readySetupBrowser.callback();
            }
            return v;
         });
      },
      /**
       * При открытии диалога открывать или не открывать папку с выбранными записями
       * @param {booelan} needToShow - открывтаь или не открывать
       */
      setNeedToShowBranch: function(needToShow){
         this._options.needToShowBranch = needToShow;
      },
      _foundRecordByPK: function(arr, val) {
         if (val === null) {
            return false;
         }
         for (var x = 0, lenOld = arr.length; x < lenOld; x++) {
            if (arr[x].getKey() == (val.getKey ? val.getKey() : val)) {
               return true;
               }
            }
         return false;
      },
      _refreshBrowser: function(){
         if (this._browser && cInstance.instanceOfModule(this._data, 'Deprecated/RecordSet')) {
            this._browser.setData(this._data);
         }
      },
     /**
      *
      * Возвращает deferred готовности представления данных.
      * Когда построится связанное представление данных на шаблоне, находящемся внутри Selector, оно
      * пробросит событие onReady, и в этот же момент придет callback с этим представлением данным  в deferred.
      * @returns {cDeferred|*} Deferred готовности.
      * @example
      * Когда представление данных будет построено, подпишемся на клик и будем подкрашивать красным цветом каждую кликнутую строчку:
      * <pre>
      *    //при условии, что this - это DialogSelector
      *    this.getReadyDeferred().addCallback(function(browser){
      *       browser.subscribe('onRowClick', function(event, row, record){
      *          row.addClass('red-text');
      *       });
      *    })
      * </pre>
      */
      getReadyDeferred: function(){
         return this._readySetupBrowser;
      },
     /**
      *
      * Изменить набор данных в связанном представлении данных.
      * @param {dTransportRecordSet} data Новый набор данных.
      * @example
      * <pre>
      *    var self = this; // при условии, что this - это DialogSelector
      *    helpers.newRecordSet("Сотрудник", "Список").addCallback(function(recordSet){
      *       self.getReadyDeferred().addCallback(function(dataView)){
      *          dataView.setData(recordSet);
      *       });
      *    });
      * </pre>
      */
      setData: function(data){
         this._data = data;
         this._refreshBrowser();
      },
      _browserChangeSelection: function(event, data, addFlag) {
         if (!data) { //Если передан пустой data - то ничего не делаем
            return;
         }
         var i, key, len,
            isArray = Object.prototype.toString.call(data) === '[object Array]';
         if (addFlag) {
            if (isArray) {
               for (i = 0, len = data.length; i < len; i++) {
                  key = data[i].getKey();
                  if (this._canceled[key]) delete this._canceled[key];
               }
            } else {
               key = data.getKey();
               if (this._canceled[key]) delete this._canceled[key];
            }
         } else {
            if (isArray) {
               for (i = 0, len = data.length; i < len; i++) {
                  this._canceled[data[i].getKey()] = true;
               }
            } else {
               this._canceled[data.getKey()] = true;
            }
         }
      },
      /**
       *
       * Установить связанное представление данных.
       * @param {SBIS3.CORE.DataView} browser Экземпляр класса представления данных.
       * @example
       * <pre>
       *    //при условии, что this - это DialogSelector
       *    var dataView = this.getTopParent().getChildByName('myNewCreatedBrowser');
       *    this.setBrowser(dataView);
       * </pre>
       * @see getBrowser
       */
      setBrowser: function(browser){
         if(this._browser){
            try{ // тут браузер уже мог начать разрушаться
               this._browser.unsubscribe('onAfterRender', this._afterRenderHandler);
               if (this._options.selectorFieldLink) {
                  this._browser.unsubscribe('onChangeSelection', this._browserChangeSelection.bind(this));
               }
               this._browser.unsubscribe('onSelectionConfirm', this._selectionConfirmHandler);
            } catch(e){}
         }
         this._browser = browser;
         if(browser){
            this._browser.setSelectionType(this._options.selectionType);
            this._browser.setSelectionMode(true);
            this._browser.setMultiSelect(this._options.multiSelect);
            this._refreshBrowser();
            this._browser.subscribe('onAfterRender', this._afterRenderHandler);
            if (this._options.selectorFieldLink) {
               this._browser.subscribe('onChangeSelection', this._browserChangeSelection.bind(this));
            }
            this._browser.subscribe('onSelectionConfirm', this._selectionConfirmHandler);
         }

         if (!this._readySetupBrowser.isReady()) {
            this._readySetupBrowser.callback();
         }
      },
      /**
       *
       * Получить связанное представление данных.
       * @return {SBIS3.CORE.DataView}
       * @example
       * <pre>
       *     //при условии, что this - это DialogSelector
       *     var dataView;
       *     if (this.getBrowser().getName() !== 'myNewCreatedBrowser') {
       *        dataDiew = this.getTopParent().getChildByName('myNewCreatedBrowser');
       *        this.setBrowser(dataView);
       *     }
       * </pre>
       * @see setBrowser
       */
      getBrowser: function(){
         return this._browser;
      },
      /**
       * Вызывает onChange и передает в него то, что отдал пользователь
       * @param {Deprecated/Record|Array} result Набор выбранных записей.
       * @example
       * <pre>
       *     //при условии, что this - это DialogSelector
       *     this.setResult(this.getBrowser().getRecordSet().getRecords());
       * </pre>
       * @see getBrowser
       * @see selectedRecords
       */
      setResult: function(result) {
         this._notify('onChange', result);
      }
   };

      selectorMixinConfig.showSelector = function (cfg, func, ctx, constructorSelector) {
         var
            result = new cDeferred(),
            finishContextDfr = new cDeferred(),
            linkedCtx = Context.createContext(finishContextDfr, null, ctx),
            needIndic = false;

         result.addErrback(function (e) {
            return e;
         });

         require(['Lib/Control/LoadingIndicator/LoadingIndicator'], function(LoadingIndicator) {
            new constructorSelector(cMerge({
               linkedContext: linkedCtx,
               handlers: {
                  onChange: function (event, records) {
                     var self = this;
                     // если выбор только листьев, то для папки может прийти [ null ], проверка на это
                     if (records && records[0]) {
                        // чтобы дождаться всех
                        var ready = new ParallelDeferred({stopOnFirstError: false});
                        records.forEach(function () {
                           var funcRes = func.apply(self, arguments),
                              isDeferred = funcRes instanceof cDeferred;

                           // может не нужна ансинхронная обработка, тогда индикатор не покажем
                           needIndic |= isDeferred;
                           if (isDeferred) {
                              ready.push(funcRes);
                           }
                        });
                        if (needIndic) {
                           LoadingIndicator.toggleIndicator(true);
                        }
                        this.close(ready.done().getResult());
                     }
                  },
                  onAfterClose: function (event, res) {
                     //  если просто закрыли диалог, то res будет false вроде
                     if (res && res instanceof cDeferred) {
                        result.dependOn(res);
                     } else {
                        result.callback(res);
                     }
                  },
                  onDestroy: function() {
                     finishContextDfr.callback();
                  }
               }
            }, cfg));

            result.addBoth(function (res) {
               if (needIndic) {
                  LoadingIndicator.toggleIndicator(false);
               }
               return res;
            });
         });
         return result;
      };

   return selectorMixinConfig;

});
