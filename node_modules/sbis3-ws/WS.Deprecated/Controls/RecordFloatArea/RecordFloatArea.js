/**
 * Created with JetBrains PhpStorm.
 * User: ad.Chistyakova
 * Date: 24.05.13
 * Time: 12:41
 * To change this template use File | Settings | File Templates.
 */
/**
 * Модуль "Компонент RecordFloatArea".
 *
 * @description
 */
define('Deprecated/Controls/RecordFloatArea/RecordFloatArea', [
   'Deprecated/Controls/DialogRecord/DialogRecord',
   'Lib/Control/FloatArea/FloatArea',
   'Core/DependencyResolver',
   'Core/CommandDispatcher',
   'Core/IoC',
   'Core/EventBus',
   'Transport/ReportPrinter',
   'Core/core-instance',
   'Core/Deferred',
   'Core/helpers/Function/forAliveOnly',
   'Lib/Control/Dialog/Dialog',
   'Lib/Control/ModalOverlay/ModalOverlay',
   'css!Deprecated/Controls/RecordFloatArea/RecordFloatArea',
   'i18n!Deprecated/Controls/RecordArea/RecordArea'
], function(
   DialogRecord,
   FloatArea,
   DependencyResolver,
   CommandDispatcher,
   IoC,
   EventBus,
   ReportPrinter,
   coreInstance,
   Deferred,
   forAliveOnly
) {
   'use strict';

   DependencyResolver.register('Deprecated/Controls/RecordFloatArea/RecordFloatArea', [], 'Lib/Control/FloatArea/FloatArea');

   var
      globalChannel = EventBus.globalChannel(),
      logger = IoC.resolve('ILogger');

   /**
    * Для описания событий и методов можно посмотреть FloatArea
    * @public
    * @class Deprecated/Controls/RecordFloatArea/RecordFloatArea
    * @author Крайнов Д.О.
    * @extends Lib/Control/FloatArea/FloatArea
    * @deprecated
    */
   var RecordFloatArea = FloatArea.extend(/** @lends Deprecated/Controls/RecordFloatArea/RecordFloatArea.prototype */{
      /**
       * @event onChangeRecord Срабатывает при проставлении(изменении записи) в контекст. Нужен вместо onDataBind
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Deprecated/Record} record - запись, на которую изменили.
       * @param {Deprecated/Record} oldRecord - старая запись.
       */
      /**
       * @event onConfirmDialogSelect При выборе значения в методе {@link openConfirmDialog}
       * @param {Core/EventObject} eventObject
       * @param {Boolean}                 leavePage   Пользователь покидает страницу
       * @see openConfirmDialog
       */
       /**
        * @cfg {Boolean} Сохранять только изменённые значения
        * @name Deprecated/Controls/RecordFloatArea/RecordFloatArea#diffOnly
        * @example
        * <option name="diffOnly">true</option>
        * @see setSaveDiffOnly
        */
      $protected: {
         _options: {
            readOnly: false,
            /**
             * @cfg {Boolean} Тип редактируемой записи
             *
             * Для класса RecordFloatArea не существует функций, которые могли бы самостоятельно определять тип записи,
             * редактируемой на всплывающей панели. По этой причине создана опция newRecord. В ней прикладной разработчик
             * самостоятельно указывает на тип записи при создании экземпляра класса RecordFloatArea.
             *
             * Возможные значения:
             * <ul>
             *    <li>true - редактируется новая запись, которой нет в БД;</li>
             *    <li>false - редактируется запись, которая уже существует в БД.</li>
             * </ul>
             * @example
             * 1. Рассмотрим диалог оформления больничного (Сотрудники &#8594; Зарплаты &#8594; Больничные). При оформлении нового
             * больничного создаётся RecordFloatArea с опцией newRecord==true, а при редактировании уже существующего - newRecord==false.
             * Значение опции отслеживается в обработчике onBeforeSickSave, чтобы запретить оформление больничных в
             * закрытый для сотрудника отчетный период (за прошедшие месяцы).
             * <pre>
             *    onBeforeSickSave: function (event) {
             *       var self = this,
             *           def = new Deferred(),
             *           ctx = this.getTopParent().getContext(),
             *           changedCols = this.getTopParent().getRecord().getChangedColumns(),
             *           isNew = (!!self.isNewRecord() || ('Расчет.Сотрудник' in changedCols) || ('РасчетРасширение.ДатаНачала' in changedCols) || ('РасчетРасширение.ДатаКонца' in changedCols));
             *       dontSaveSickInClosedMonth(self).addCallback(function(bool){
             *          // сначала проверяем закрыт ли месяц по сотруднику
             *          if (bool && isNew){
             *             // выдать сообщение что месяц закрыт и не сохранять больничный
             *             helpers.alert("Месяц расчета по сотруднику "
             *             + (ctx.getValue('ЧастноеЛицо.Лицо.Название')?ctx.getValue('ЧастноеЛицо.Лицо.Название'):'')
             *             + " закрыт и больничный не будет сохранен.",
             *             {}, self).addCallback(function(){
             *                def.callback(false);
             *                // отменим введенные значения и закроем окно (чтобы не было предложения сохранить изменения)
             *                self.getRecord().rollback();
             *                self.close();
             *             });
             *          } else {
             *             ...
             *          }
             *       });
             *       event.setResult(def);
             *    }
             * </pre>
             * 2. В реестрах документов после изменения регламента вызывается код обновления реестра.
             * Если запись новая, то обновлять opener'a не нужно. Здесь opener - это компонент с реестром документов,
             * в контексте которого вызываем всплывающую панель.
             * <pre>
             *    if (!self.getTopParent().isNewRecord() && self.getTopParent().getOpener() && self.getTopParent().getOpener().reload) {
             *       self.getTopParent().getOpener().reload();
             *    }
             * </pre>
             * 3. При создании новой вехи (Задачи &#8594; Проекты &#8594; Вехи) происходит установка курсора в поле "Название".
             * Этот функционал реализован отдельным методом.
             * <pre>
             *    setMilestoneNameActive : function(){
             *       var dlg = this;
             *       if(dlg.isNewRecord()) {
             *          dlg.getChildControlByName('ДокументРасширение.Название').setActive(true);
             *       }
             *    }
             * </pre>
             * @see isNewRecord
             */
            newRecord: false,
            reports: {},
            doNotLossFocus: false,
            editFullScreenTemplate: '',
            /**
             * @cfg {Boolean} Отслеживает скролл
             * Если  = false, то не движется по окну за скроллом. - где выехали, там и остались
             */
            catchScroll: true,

            /**
             * @cfg {Boolean} В классе RecordFloatArea опция autoCloseOnHide по умолчанию включена,
             * а значит, метод hide работает так же, как и метод close, закрывая панель, и удалая её после закрытия
             */
            autoCloseOnHide: true,
            /**
             * @cfg {Boolean} Опция задает поведение работы панели с контекстом при переключении в реестре
             * (изменении записи c помощью {@link setRecord})
             * false - заменять только запись в контексте, другие поля не трогает
             * true - полностью заменяет(очищает) контекст и проставляет в него запись
             */
            clearContext : false,
            /**
             * @cfg {String} Текст рядом с индикатором сохранения записи
             * @example
             * <pre>
             *     <option name="indicatorSavingMessage">Занят важным делом - сохраняю ваши данные.</option>
             * </pre>
             */
            indicatorSavingMessage:  rk('Подождите, идёт сохранение')
         },
         _pending: [],
         _waiting: [],
         _record: null,
         _recordSaved: false,
         _loadingIndicator: undefined,  //Индикатор загрузки
         _saving: false,                //Сохраняется ли в данный момент
         _displaysConfirmDialog: false, //Отображен диалог подтверждения закрытия RecordFloatArea
         _reportPrinter: null,
         _printMenu: null,
         _printMenuIsShow: false,
         _lastMenuItemList: [],
         _window: {
            remove : function(){},
            hide: function(){},
            _titleBar : true
         },
         _isClosed : true,
         _standartYOffset : 1,
         _standartWindowOffset: 64,
         _onFocusOutElements: null,
         _recordIsChanged: false,
         _inHideInner: false
      },
      $constructor: function(){
         this._publish(
            'onBeforeDelete',
            'onRecordDeleted',
            'onBeforeSave',
            'onSave',
            'onSuccess',
            'onFail',
            'onRecordUpdate',
            'onConfirmDialogSelect',
            'onAfterClose',
            'onBeforeClose',
            'onBeforeShowPrintReports',
            'onPrepareReportData',
            'onSelectReportTransform',
            'onChangeRecord',
            'onBeforeShowConfirmDialog',
            'onBeforeChangeRecord'
         );

         DialogRecord.prototype.subscribeOnBeforeUnload.apply(this);
         if(this.getReports().length !== 0) {
            this._reportPrinter = new ReportPrinter({});
         }
         this.subscribe('onBeforeClose', function(){
            this._isClosed = true;
         });
         this.subscribe('onReady', this._onReady);
         //Подписались на клики по аккордеону

         this.subscribe('onAfterShow', function(){
            this._isClosed = false;
         });
         this.subscribe('onBeforeShow', function(){
            this._isClosed = false;
            if(this._options.readOnly) {
               this._setEnabledForChildControls(false);
            }
         });

         var
            declCmd = CommandDispatcher.declareCommand.bind(CommandDispatcher, this),
            Proto = DialogRecord.prototype;

         declCmd('ok', Proto.ok);
         declCmd('cancel', Proto.cancel);

         declCmd('save', function(){
            //Если отображен диалог подтверждения выхода - то обрабатывать команду "save" нельзя
            if (!this._displaysConfirmDialog) {
               return Proto.save.apply(this, arguments);
            }
         });

         declCmd('delete', Proto.delRecord);
         declCmd('print', function(event){
            Proto.print.apply(this, [event]);
         });
         declCmd('printReport', function(reportName){
            Proto.printReport.apply(this, [reportName]);
         });

         if (this._options.isNewRecord !== undefined){
            logger.error('RecordFloatArea', rk('Опция isNewRecord будет удалена в 3.8.0. Вместо нее используйте опцию newRecord'));
            this._options.newRecord = this._options.isNewRecord;
         }
      },
       /**
        * Метод установки/замены значения опции {@link diffOnly}.
        * @param {Boolean} diffOnly Сохранять только изменённые значения.
        * @example
        * <pre>
        *     //this - recordFloatArea
        *    this.setSaveDiffOnly(true);
        * </pre>
        * @see diffOnly
        */
      setSaveDiffOnly: function(){
         DialogRecord.prototype.setSaveDiffOnly.apply(this, arguments);
      },
      _onBeforeNavigate: function(event, activeElement, isIconClick){
         if (!isIconClick) {
            var noOpen = !coreInstance.instanceOfModule(this, 'Deprecated/Controls/RecordFloatArea/RecordFloatArea');
            // Выставляем результат только тогда, когда нужно запретить переход, чтобы не испортить значение,
            // которое может уже лежать в event-е от предыдущего обработчика
            if (!(noOpen || this.openConfirmDialog())) {
               event.setResult(false);
            }

         }
      },
      _createTitle: function(){
         //Важно, чтобы сначала отработал createTitle от FA!
         RecordFloatArea.superclass._createTitle.apply(this, arguments);

         //Снимаем верхний бордер
         this.getContainer().parent().addClass('ws-record-float-area-border');

         if (this._needNewPageLink()) {
            var icon = $('<div class="ws-record-float-area-icon icon-16 icon-NewTab icon-disabled action-hover"></div>');
            this._title.append(icon)
               .hover(function(){
                  icon.toggleClass('icon-hover');
               });
         }
      },

      _needNewPageLink: function() {
         return this._options.editFullScreenTemplate &&
                coreInstance.instanceOfModule(this.getOpener(), 'Deprecated/Controls/DataViewAbstract/DataViewAbstract');
      },

      _setTitleContainer: function() {
         RecordFloatArea.superclass._setTitleContainer.apply(this, arguments);

         //Если шаблон не задали - не создаем ссылку для открытия в новой вкладке
         if (this._needNewPageLink()) {
            var self = this;
            this._title.addClass('ws-record-float-area-title');
            this._title.bind('click', function(event){
               var record =  self.getRecord(),
                   columns = record.getColumns(),
                   changedParams = {},
                   recordConfig = {
                      id: record.getKey(),
                      parentId: record.getParentKey(),
                      isBranch: record.isBranch()
                   },
                   opener = self.getOpener(),
                   url;
               //TODO перевести на record.getChangedFields() - только сначала доделать саму функцию getChangedFields
               for (var i = 0, len = columns.length; i < len; i++){
                  if (record.isChanged(columns[i])){
                     changedParams[columns[i]] = record.get(columns[i]);
                  }
               }
               url = opener.isHierarchyMode() ?  opener.generateEditPageURL(recordConfig.id, recordConfig.isBranch, null, false, undefined, changedParams, self._options.editFullScreenTemplate) :
                     opener.generateEditPageURL(recordConfig.id, undefined, changedParams, self._options.editFullScreenTemplate);
               opener.openWindowRecord(recordConfig, url);
               self.hide();
               event.stopImmediatePropagation();
               return false;
            });
         }
      },
      setOpener: function(opener) {
         if (this.getOpener()) {
            this.getOpener().unsubscribe('onFocusOut', this._getOnFocusOutHandler());
         }

         RecordFloatArea.superclass.setOpener.call(this, opener);

         if (this.getOpener()) {
            this.getOpener().subscribe('onFocusOut', this._getOnFocusOutHandler());
         }
      },


      _getOnFocusOutHandler: function() {
         if (!this._onFocusOutElements) {
            var self = this;
            this._onFocusOutElements = function(event, destroyed, focusedControl){
               if (!destroyed && focusedControl && !coreInstance.instanceOfModule(focusedControl, 'Navigation/Navigation'))
               {
                  if (focusedControl === self.getOpener())
                  {
                     self.moveToTop();
                  }
                  //Есди клик был по аккордену - не обрабатываем потерю фокуса
                  else if (self.isVisible() && self.isAutoHide() && self._shouldHideByFocusMoveTo(focusedControl))
                  {
                     var
                        opener = self.getOpener(),
                        openerContainer = opener && opener.getContainer(),
                        parentWindow = focusedControl.getParentWindow(),
                        focusedContainer = focusedControl.getContainer(),
                        topParent = focusedControl.getTopParent(),
                        topParentIsModal = topParent.isModal && topParent.isModal(),
                        topParentOpener = topParent.getOpener && topParent.getOpener(),
                        myContainer = self.getContainer();

                     if (!self._isClosed && self._state !== 'hide' &&
                         openerContainer && openerContainer.find(focusedContainer).length < 1 &&
                         myContainer && myContainer.find(focusedContainer).length < 1 &&
                         !topParentIsModal &&
                         opener !== focusedControl &&
                         topParent !== this.getTopParent() &&
                         topParentOpener !== this &&
                         topParent !== self)
                     {
                        var
                           parentWinOpener = parentWindow && parentWindow.getOpener(),
                           parentWinOpenerContainer = parentWinOpener && parentWinOpener.getContainer();

                        if ((!parentWindow || !parentWinOpener) ||
                            (parentWinOpener && myContainer && myContainer.find(parentWinOpenerContainer) < 1))
                        {
                           self.hide();
                        }
                     }
                  }
               }
            };
         }
         return this._onFocusOutElements;
      },

      _onReady : function(){
         if (!this._options.doNotLossFocus) {
            return true;
         }

         var handler = this._getOnFocusOutHandler();

         //На всякий случай отпишем обработчик, потому что _onReady может быть вызвана из-за переустановки шаблона - второй раз
         globalChannel.unsubscribe('onFocusOut', handler, this);
         globalChannel.subscribe('onFocusOut', handler, this);
      },

      destroy: function(){
         globalChannel.unsubscribe('onFocusOut', this._getOnFocusOutHandler(), this);
         EventBus.channel('navigation').unsubscribe('onBeforeNavigate', this._onBeforeNavigate, this);
         RecordFloatArea.superclass.destroy.apply(this, arguments);
      },

      /**
       * открыть специальный диалог подтверждения изменения записи (по макету)
       * @param {Boolean} noHide - не закрывать панель после закрытия диалога
       * @returns {Core/Deferred || Boolean} true - если теперь можно менять запись, false в противном случае (пользователь пожелал остаться)//
       * @see onConfirmDialogSelect
       */
      openConfirmDialog : function(noHide){
         var self = this,
             deferred = new Deferred();
         this._displaysConfirmDialog = true;
         deferred.addCallback(function(result){
            self._notify('onConfirmDialogSelect', result);
            self._displaysConfirmDialog = false;
            return result;
         });
         if ((self.getRecord().isChanged() && !self.isSaved()) || self._recordIsChanged) {
            this._openConfirmDialog(false, true).addCallback(function(result){
               switch (result) {
                  case 'yesButton' : {
                     if (self._result === undefined) {
                        self._result = true;
                     }
                     self.updateRecord().addCallback(function(){
                        self._confirmDialogToCloseActions(deferred, noHide);
                     }).addErrback(function(){
                        deferred.callback(false);
                     });
                     break;
                  }
                  case 'noButton' : {
                     if (self._result === undefined) {
                        self._result = false;
                     }
                     /**
                      * Если откатить изменения в записи, поля связи, которые с ней связанны, начнут обратно вычитываться, если были изменены, а это уже не нужно
                      * Положили rollback обратно, поля связи уже так себя вести не должны, а rollback реально нужен
                      * Оставляем возможность проводить сохранение записи в прикладном коде. По задаче Алены(см коммент вверху) ошибка не повторяется, т.к. там уже юзают formController
                      */
                     self._confirmDialogToCloseActions(deferred, noHide);
                     break;
                  }
                  default : {
                     deferred.callback(false);
                  }
               }
            });
         }
         else {
            self._confirmDialogToCloseActions(deferred, noHide);
         }
         return deferred;
      },
      _confirmDialogToCloseActions: function(deferred, noHide) {
         EventBus.channel('navigation').unsubscribe('onBeforeNavigate', this._onBeforeNavigate, this);
         deferred.callback(true);
         if (!noHide) {
            RecordFloatArea.superclass.close.apply(this, arguments);
         }   
      },
      _openConfirmDialog:function(){
         return DialogRecord.prototype._openConfirmDialog.apply(this, arguments);
      },

      isSaved: function(){
         return DialogRecord.prototype.isSaved.apply(this, []);
      },
      _unbindBeforeUnload: function() {
         DialogRecord.prototype._unbindBeforeUnload.apply(this);
      },
      _beforeUnloadHandler: function() {
         return DialogRecord.prototype._beforeUnloadHandler.apply(this);
      },
      unsubscribeOnBeforeUnload: function(){
         DialogRecord.prototype.unsubscribeOnBeforeUnload.apply(this);
      },
      updateRecord: function(){
         return DialogRecord.prototype.updateRecord.apply(this, arguments);
      },
      _checkPendingOperations: function() {
         return DialogRecord.prototype._checkPendingOperations.apply(this, arguments);
      },
      save: function(){
         return DialogRecord.prototype.save.apply(this, arguments);
      },
      _processError: function(error){
         DialogRecord.prototype._processError.apply(this, [error]);
      },
      /**
       * Может ли панель менять запись
       * @returns {Boolean}
       */
      isReadOnly: function(){
         return this._options.readOnly;
      },
      ok: function(){
         DialogRecord.prototype.ok.apply(this, arguments);
      },
      _setEnabledForChildControls: function(){
         DialogRecord.prototype._setEnabledForChildControls.apply(this, arguments);
      },
      _showLoadingIndicator: function(){
         DialogRecord.prototype._showLoadingIndicator.apply(this, arguments);
      },
      _hideLoadingIndicator: function(){
         DialogRecord.prototype._hideLoadingIndicator.apply(this, arguments);
      },
      isAllReady: function(){
         return DialogRecord.prototype.isAllReady.apply(this, arguments);
      },
      getChildControls: function(){
         return DialogRecord.prototype.getChildControls.apply(this, arguments);
      },
      getReports: function(){
         return DialogRecord.prototype.getReports.apply(this, arguments);
      },
      _printMenuItemsIsChanged: function(){
         return DialogRecord.prototype._printMenuItemsIsChanged.apply(this, arguments);
      },
      _createPrintMenu: function(reportsList){
         return DialogRecord.prototype._createPrintMenu.apply(this, arguments);
      },
      showReportList: function(e){
         return DialogRecord.prototype.showReportList.apply(this, arguments);
      },
      printReport: function(isReport){
         return DialogRecord.prototype.printReport.apply(this, arguments);
      },
      _showReport: function(idReport, data, transform){
         return DialogRecord.prototype._showReport.apply(this, arguments);
      },
      print: function(event){
         return DialogRecord.prototype.print.apply(this, arguments);
      },
      _hideWindow: function(){
      },
      getRecord : function(){
         return DialogRecord.prototype.getRecord.apply(this, arguments);
      },
      _getTitle: function(){
         return document.title;
      },
      /**
       * Изменяет состояние диалога "только для чтения"
       * @param {Boolean} isReadOnly
       */
      setReadOnly: function(isReadOnly){
         DialogRecord.prototype.setReadOnly.apply(this, arguments);
      },
      /**
       * Изменить поведение метода {@link setRecord}
       * @param {String} clearContext {@link clearContext}
       *  Возможные значения
       * false - не очищать контекст, а только поменять запись
       * true - очищать контекст
       * @see clearContext
       * @see setRecord
       */
      setClearContext: function(clearContext) {
         this._options.clearContext = !!clearContext;
      },
      getClearContext: function(){
         return this._options.clearContext;
      },
      /**
       * Возвращает значение опции newRecord, которое указал прикладной разработчик при создании экземпляра класса RecordFloatArea.
       * Опция указывает на тип редактируемой записи.
       * @returns {Boolean} Возможные значения:
       * <ol>
       *    <li>true - новая запись, ещё не сохранена в БД;</li>
       *    <li>false - существующая в БД запись.</li>
       * </ol>
       * @see newRecord
       */
      isNewRecord: function(){
         return DialogRecord.prototype.isNewRecord.apply(this, arguments);
      },
       /**
        * Метод установки/замены записи.
        * @param {String} record Новая запись.
        * @param {Boolean} noConfirm Отменить появление диалога подтверждения записи.
        * @example
        * <pre>
        *    var panel = this.getTopParent();
        *    var idSpp = suggestRecord.get('ИдентификаторСПП');
        *    ContragentCardCommonFunctions.createContrLoc(panel, {idSpp: idSpp}).addCallback(function(record) {
        *       panel.setRecord(record, true);
        *    });
        * </pre>
        * @see setClearContext
        */
      setRecord : function(record, noConfirm){
         var self = this;
         if (!noConfirm) {
            this.openConfirmDialog(true).addCallback(function(result){
               if (result) {
                  self._setRecord(record);
               }
            });
         }
         else {
            this._setRecord(record);
         }
      },
      _setRecord: function(record) {
         var oldRecord = this.getRecord(),
             context = this.getLinkedContext(),
             self = this,
             setRecordFunc = function(){
                if (self._options.clearContext) {
                   context.setContextData(record);
                } else {
                   context.replaceRecord(record);
                }
                if(self.isNewRecord()){
                   self._options.newRecord = record.getKey() === null;
                }
                self._notify('onChangeRecord', record, oldRecord);//Отдаем запись, хотя здесь ее можно получить простым getRecord + старая запись
             },
             result;
         result = this._notify('onBeforeChangeRecord',record, oldRecord);
         Deferred.callbackWrapper(result, setRecordFunc.bind(this));
      },

      _hide: forAliveOnly(function() {
         var
            hideSuper = RecordFloatArea.superclass._hide,
            result;

         result = !this._inHideInner;
         if (result) {
            result = hideSuper.apply(this, arguments);
         }
         return result;
      }),

      /**
       * Скрывает контрол, в самом конце скрытия удаляет область.
       * @returns {Boolean}
       */
      _hideInner: forAliveOnly(function() {
         var
            self = this,
            args = arguments,
            hideSuper = RecordFloatArea.superclass._hideInner,
            result;

         //мы должны убедиться, что запись не просто поменяли, а еще и не сохранили
         if ((self.getRecord().isChanged() && !self.isSaved()) || self._recordIsChanged) {
            this._inHideInner = true;
            result = self.openConfirmDialog(true).addCallback(function (result) {
               if (result) {
                  return hideSuper.apply(self, args);
               } else {
                  //В случае выбора "отмены" в диалоге нужно вернуть фокус на активный контрол в панели
                  var lastActive = self.getActiveChildControl(true, true);
                  if (lastActive) {
                     lastActive.setActive(true);
                  } else {
                     self.activateFirstControl();
                  }
               }
            }).addBoth(function(res) {
               self._inHideInner = false;
               return res;
            });
         } else {
            result = hideSuper.apply(self, args);
         }
         return result;
      }),
      /**
       * Заставить при закрытии спросить о сохранении, но только если запись была только что создана
       * @param {Boolean} status - если true, то спрашивать
       */
      setChanged: function(status) {
         this._recordIsChanged = !!status;
      }
   });

   return RecordFloatArea;
});
