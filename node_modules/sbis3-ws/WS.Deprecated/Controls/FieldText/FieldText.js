/**
 * Created with JetBrains PhpStorm.
 * User: tm.baeva
 * Date: 21.04.13
 * Time: 23:04
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/FieldText/FieldText', [
   'Core/helpers/String/escapeHtml',
   'Core/helpers/String/linkWrap',
   'Core/constants',
   'Deprecated/Controls/FieldString/FieldString',
   'html!Deprecated/Controls/FieldText/FieldText',
   'Core/detection',
   'css!Deprecated/Controls/FieldText/FieldText',
   'browser!Lib/Control/Autosize-plugin'
], function(
   escapeHtml,
   linkWrap,
   cConstants,
   FieldString,
   dotTplFn
) {

   "use strict";

   /**
    * Текстовое поле, аналог textarea
    * @class Deprecated/Controls/FieldText/FieldText
    * @extends Deprecated/Controls/FieldString/FieldString
    * @author Крайнов Д.О.
    * @control
    * @public
    * @category Fields
    * @initial
    * <component data-component='Deprecated/Controls/FieldText/FieldText' style='width: 100px;'>
    *    <option name="value">Текст</option>
    * </component>
    * @designTime actions Deprecated/Controls/FieldString/design/design
    * @ignoreOptions maxlength
    * @ignoreOptions readonly
    * @ignoreOptions password
    * @deprecated Используйте класс {@link SBIS3.CONTROLS/TextArea}.
    */
   var FieldText = FieldString.extend( /** @lends Deprecated/Controls/FieldText/FieldText.prototype */{
      $protected : {
         _options : {
            linkWrap: linkWrap,
            cssClassName: 'ws-field-text',
            cssClass: 'ws-field-text',
            /**
             * @cfg {Boolean} Режим текстового поля с автовысотой
             *
             */
            autoHeight: false,
            /**
              * @cfg {Number} Минимальное количество отображаемых строк
              * Текстовое поле изначально будет состоять из заданного в данной опции количества строк.
              *
              * @see maxLinesCount
              * @see getMinVisibleLines
              * @see setMinVisibleLines
              * @see getMaxVisibleLines
              * @see setMaxVisibleLines
              */
            minLinesCount: 0,
            /**
             * @cfg {Number} Максимальное количество отображаемых строк
             * Многострочное текстовое поле может расширяться по высоте до указанного в этой опции количества строк.
             * После добавления строки по счёту max+1 текстовое поле больше не будет расширяться, появится вертикальная полоса прокрутки.
             *
             * @see minLinesCount
             * @see getMinVisibleLines
             * @see setMinVisibleLines
             * @see getMaxVisibleLines
             * @see setMaxVisibleLines
             */
            maxLinesCount: 0
            /**
              * @name Deprecated/Controls/FieldText/FieldText#value
              * @cfg {Content} Значение текстового поля.
              */
         },
         _fieldText: undefined,
         _firstSetValue: false,
         _keysWeHandle: [
            cConstants.key.enter,
            cConstants.key.del,
            cConstants.key.down,
            cConstants.key.up
         ]
      },
      $constructor: function() {
         this._prepareField();
         if (this._compareValues(this.getValue(), this._notFormatedVal())) {
            this._container.removeClass('ws-invisible');
            this._firstSetValue = true;
         }
      },

      _compareValues: function (a, b) {
         var comparisonResult;
         if (a && a.equals) {
            comparisonResult = a.equals(b);
         } else {
            comparisonResult = (a == b);
         }
         return comparisonResult;
      },

      _prepareField: function() {
         this.subscribe('onValueChange', this._applyScrollClass);
         this._inputControl.height('100%')
            .val('');   //TODO IE10 pp 9200.16438 (+/final ?)

         this._fieldText = this._container.find('.ws-field');
         this._fieldText.addClass('ws-field-fullheight');

         this._inputControl.unbind('keypress');
         if (this._options.autoHeight) {
            this._options.minLinesCount = parseInt(this._options.minLinesCount, 10);
            this._options.maxLinesCount = parseInt(this._options.maxLinesCount, 10);
            if (this._options.minLinesCount > this._options.maxLinesCount) {
               this._options.maxLinesCount = this._options.minLinesCount;
            }
            this._inputControl.data('minLinesCount', this._options.minLinesCount);
            this._inputControl.data('maxLinesCount', this._options.maxLinesCount);
            this._inputControl.autosize({
               callback: this._textAreaResize.bind(this),
               append: ''
            });
         }
      },
      _applyScrollClass: function() {
         var 
            area = this._container.find('textarea')[0],
            scrollHeight;
         if (area) {
            //в ff scrollHeight на 1 больше чем в остальных браузерах
            scrollHeight = cConstants.browser.firefox ? area.scrollHeight - 1 : area.scrollHeight;
            this._container.toggleClass('ws-field-fullheight-has-scrollbar', scrollHeight > area.clientHeight);
         }
      },
      _onResizeHandler: function() {
         this._applyScrollClass();
         this._inputControl.trigger('autosize.resize');
      },
      /**
       *
       * Изменить текущее значение.
       * @param {*} value Вставляемое значение.
       * @param {Boolean} [ignoreReadonly] Игнорировать признак "только для чтения".
       * @param {Boolean} [noRevalidate] Не проводить валидацию контрола.
       * @example
       * <pre>
       *    var field = this.getTopParent().getChildControlByName('demoFieldText');
       *    field.setValue('новое значение');
       * </pre>
       */
      setValue: function(value, ignoreReadonly) {
         if (!this._options.readOnly || ignoreReadonly) {
            FieldText.superclass.setValue.apply(this, arguments);
            if (this._options.autoHeight) {
               this._inputControl.trigger('autosize.resize');
            }
         }
      },
      /**
       *
       * Установить фокус на контрол.
       * @param {Boolean} active
       * Возможные значения:
       * <ol>
       *    <li>true - перевести фокус на контрол. Если фокус ранее находился на другом элементе, то произойдёт событие {@link onFocusIn}.
       *    Если фокус был на данном контроле, то откроется всплывающая подсказка.</li>
       *    <li>false - убрать фокус с контрола. Произойдёт событие onFocusOut.</li>
       * </ol>
       * @example
       * При готовности контрола перевести на него фокус.
       * <pre>
       *    control.subscribe('onReady', function() {
       *       if (!this.isActive()) this.setActive(true);
       *    });
       * </pre>
       * @see isActive
       * @see onFocusIn
       * @see onFocusOut
       */
      setActive: function(active){
         FieldText.superclass.setActive.apply(this, arguments);
         // для установки курсора в конец поля ввода,
         // при появлении из "редактирования по месту"
         if ((cConstants.browser.isMacOSDesktop || cConstants.browser.isIE) && active) {
            this._inputControl
               .focus()
               .val("")
               .val(this._curval);
         }
      },
      /**
       *
       * Установить минимальное количество отображаемых строк.
       * Метод позволяет изменить минимальное количество отображаемых строк текстового поля, установленное опцией {@link minLinesCount}.
       * @param {Number} count Количество строк.
       * @example
       * Проверим минимальное количество отображаемых строк: не превышает ли оно двух. Если превышает, то установим значение в 2 строки.
       * <pre>
       *    var field = this.getTopParent().getChildControlByName('demoFieldText');
       *    if (field.getMinVisibleLines() > 2) {
       *       //устанавливаем минимальное количество отображаемых строк
       *       field.setMinVisibleLines(2);
       *    }
       * </pre>
       * @see minLinesCount
       * @see maxLinesCount
       * @see getMinVisibleLines
       * @see getMaxVisibleLines
       * @see setMaxVisibleLines
       */
      setMinVisibleLines: function(count) {
         if (this._options.autoHeight === true && typeof count === 'number') {
            if (count > this._options.maxLinesCount) {
               this._options.maxLinesCount = count;
               this._inputControl.data('maxLinesCount', this._options.maxLinesCount);
            }
            this._options.minLinesCount = count;
            this._inputControl.data('minLinesCount', this._options.minLinesCount);
            this._inputControl.trigger('autosize.resize');
         }
      },
      /**
       *
       * Установить максимальное количество отображаемых строк.
       * Метод позволяет изменить максимальное количество отображаемых строк текстового поля, установленное опцией {@link maxLinesCount}.
       * @param {Number} count Количество строк.
       * @example
       * Проверим максимальное количество отображаемых строк: не превышает ли оно пяти. Если превышает, то установим значение в 5 строк.
       * <pre>
       *    var field = this.getTopParent().getChildControlByName('demoFieldText');
       *    if (field.getMaxVisibleLines() > 5) {
       *       //устанавливаем максимальное количество отображаемых строк
       *       field.setMaxVisibleLines(5);
       *    }
       * </pre>
       * @see minLinesCount
       * @see maxLinesCount
       * @see getMinVisibleLines
       * @see getMaxVisibleLines
       * @see setMinVisibleLines
       */
      setMaxVisibleLines: function(count) {
         if (this._options.autoHeight === true && typeof count === 'number') {
            if (count < this._options.minLinesCount) {
               this._options.minLinesCount = count;
               this._inputControl.data('minLinesCount', this._options.minLinesCount);
            }
            this._options.maxLinesCount = count;
            this._inputControl.data('maxLinesCount', this._options.maxLinesCount);
            this._inputControl.trigger('autosize.resize');
         }
      },
      /**
       *
       * Получить минимальное количество отображаемых строк.
       * @returns {Number} Возвращает минимальное количество отображаемых строк текстового поля, заданных либо опцией {@link minLinesCount},
       * либо методом {@link setMinVisibleLines}.
       * @example
       * Проверим минимальное количество отображаемых строк: не превышает ли оно двух. Если превышает, то установим значение в 2 строки.
       * <pre>
       *    var field = this.getTopParent().getChildControlByName('demoFieldText');
       *    //получаем минимальное количество отображаемых строк
       *    if (field.getMinVisibleLines() > 2) {
       *       field.setMinVisibleLines(2);
       *    }
       * </pre>
       * @see minLinesCount
       * @see maxLinesCount
       * @see getMaxVisibleLines
       * @see setMaxVisibleLines
       * @see setMinVisibleLines
       */
      getMinVisibleLines: function() {
         if (this._options.autoHeight === true) {
            return this._options.minLinesCount;
         }
      },
      /**
       *
       * Получить максимальное количество отображаемых строк.
       * @returns {Number} Возвращает максимальное количество отображаемых строк текстового поля, заданных либо опцией {@link maxLinesCount},
       * либо методом {@link setMaxVisibleLines}.
       * @example
       * Проверим максимальное количество отображаемых строк: не превышает ли оно пяти. Если превышает, то установим значение в 5 строк.
       * <pre>
       *    var field = this.getTopParent().getChildControlByName('demoFieldText');
       *    //получаем максимальное количество отображаемых строк
       *    if (field.getMaxVisibleLines() > 5) {
       *       field.setMaxVisibleLines(5);
       *    }
       * </pre>
       * @see minLinesCount
       * @see maxLinesCount
       * @see getMinVisibleLines
       * @see setMaxVisibleLines
       * @see setMinVisibleLines
       */
      getMaxVisibleLines: function() {
         if (this._options.autoHeight === true) {
            return this._options.maxLinesCount;
         }
      },

      _textAreaResize : function() {
         this._notifyOnSizeChanged(this, this);
      },
      _setValueInternal: function() {
         FieldText.superclass._setValueInternal.apply(this, arguments);
         if (this._options.autoHeight) {
            this._inputControl.trigger('autosize.resize');
         }
         if (!this._firstSetValue) {
            this._container.removeClass('ws-invisible');
            this._firstSetValue = true;
         }
      },
      setEditAtPlace: function () {
         FieldText.superclass.setEditAtPlace.apply(this, arguments);
         if (this._options.autoHeight && !this._editAtPlace) { // bugfix: ресайз области при показе во всплывающей панели
            this._inputControl.trigger('autosize.resize');
         }
      },

      /**
       * Обновление значения в текстовом поле при его изменении извне
       * @param {*} value новое значение
       * @private
       */
      _updateInPlaceValue: function (value) {
         if (this._editAtPlace) {
            if (this._options.editAtPlaceTooltip && !value) {
               value = this._options.editAtPlaceTooltip;
               this._editAtPlaceElement.addClass('editAtPlace-empty');
            } else {
               this._editAtPlaceElement.removeClass('editAtPlace-empty');
            }
            this._editAtPlaceHasAuto = !!value && (this._textAlign !== 'right');
            this.getContainer()
               .toggleClass('ws-editAtPlace-empty', !value)
               .toggleClass('ws-editAtPlace-autowidth', this._editAtPlaceHasAuto);
            var text = '';
            (value||'').split('\n').forEach(function (s) {
               text = text + '<div>' + escapeHtml(s.replace(/&/g, '&amp;').replace(/\s\s/g, ' &nbsp;')) + (s ? '' : '&nbsp;') + '</div>';
               // вставляем &nbsp; в div с пустой строкой, чтобы у него была ненулевая высота при отображении
            });
            this._editAtPlaceElementInner.html(text || '&nbsp;');
            if (!this._options.tooltip) {
               this._editAtPlaceElement.attr('title', value);
            }
         }
      },
      _setEditAtPlaceStyles: function() {
         this._editAtPlaceElementInner.css({
            'lineHeight': this._container.css('line-height')
         });
      },
      _firstSelect : function(){
         return true;
      },
      _dotTplFn: dotTplFn,
      _getInputControl: function() {
         return this._container.find("textarea");
      },
      /**
       * Обработка клавиш. В многострочном поле enter должен служить только одной причине
       * @param {Event} event Объект события
       */
      _keyboardHover: function(event){
         var key = event.which;
         if(event.shiftKey && key != cConstants.key.up && key != cConstants.key.down || event.altKey || event.ctrlKey) {
            //shift + key_up/key_down - выделение текста, поэтому эту комбинацию не прокидываем дальше
            return true;
         }
         event.stopPropagation();
         return true;
      },
      destroy: function() {
         this._inputControl instanceof $ && this._inputControl.trigger('autosize.destroy');
         FieldText.superclass.destroy.apply(this, arguments);
      }
   });

   return FieldText;

});
