/**
 * Created with JetBrains PhpStorm.
 * User: aa.adilov
 * Date: 19.11.12
 * Time: 16:59
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/DataViewAbstract/plugins/Print-plugin', [
   'SBIS3.CONTROLS/Utils/InformationPopupManager',
   'Lib/Control/Control',
   'Core/pathResolver',
   'Deprecated/ReaderSBIS',
   'Core/helpers/Array/clone',
   'Core/helpers/Hcontrol/saveToFile',
   'Core/core-clone',
   'Deprecated/core-attach',
   'Core/core-merge',
   'Transport/ReportPrinter',
   'Transport/RecordSetToXMLSerializer',
   'Deprecated/Record',
   'Deprecated/RecordSet',
   'Core/PrintDialogHTMLView',
   'Core/IoC',
   'Core/Context',
   'Core/Deferred',
   'Core/CommandDispatcher',
   'Core/constants',
   'Deprecated/Controls/DataViewAbstract/DataViewAbstract',
   'Lib/Control/Dialog/Dialog',
   'Lib/Control/LoadingIndicator/LoadingIndicator',
   'Core/helpers/Object/isEmpty',
   'Deprecated/res/wsmodules/ValidateCountDialog/ValidateCountDialog',
   'Deprecated/res/wsmodules/SelectColumnsDialog/SelectColumnsDialog',
   'i18n!Deprecated/Controls/DataViewAbstract/plugins/Print-plugin'
], function(
   InformPopManager,
   CControl,
   pResolver,
   ReaderSBIS,
   cloneArray,
   cSaveToFile,
   coreClone,
   cAttach,
   cMerge,
   ReportPrinter,
   RecordSetToXMLSerializer,
   dTransportRecord,
   dTransportRecordSet,
   PrintDialogHTMLView,
   IoC,
   cContext,
   cDeferred,
   CommandDispatcher,
   cConstants,
   DataViewAbstract,
   Dialog,
   LoadingIndicator,
   ObjIsEmpty
) {

   var MAX_VALUE = 10000;  //На списочных методах есть ограничение в 10000, синхронизируем наше ограничение и ограничение бл.

   /**
    * @class Deprecated/Controls/DataViewAbstract/plugins/Print-plugin
    * @extends Deprecated/Controls/DataViewAbstract/DataViewAbstract
    * @author Крайнов Д.О.
    * @plugin
    * @public
    * @deprecated
    */
   DataViewAbstract.PrintPlugin = DataViewAbstract.extendPlugin(/** @lends Deprecated/Controls/DataViewAbstract/plugins/Print-plugin.prototype */{
   /**
    * @event onPrepareReportData При подготовке данных отчета
    * Происходит для печати записи и реестра перед преобразованием печатаемых данных в XML.
    * @param {Core/EventObject} eventObject Дескриптор события.
    * @param {String} idReport Название отчёта, который собираемся печатать.
    * @param {dTransportRecordSet} data Набор данных, которые собираемся печатать.
    * @returns Можно передать:
    * <ol>
    *    <li>False - отмена печати, механизм печати завершает работу;</li>
    *    <li>асинхронное событие - ждем его успешного завершения и считаем, что его результат (dTransportRecord|dTransportRecordSet|Array) - те данные, которые нам нужно преобразовать в XML;</li>
    *    <li>dTransportRecord|dTransportRecordSet|Array - считаем результатом события те данные, которые нам нужно преобразовать в XML;</li>
    *    <li>Любой другой результат - продолжаем печать стандартным образом.</li>
    * </ol>
    * @example
    * <pre>
    *    dataView.subscribe('onPrepareReportData', function(event, report, data){
    *       if(report == "Печать")
    *          event.setResult(this.getRecordSet().getRecords());
    *    });
    * </pre>
    */
      /**
     * @event onSelectReportTransform При выборе XSL-трансформации отчета
     * Происходит перед применением указанной в конфигурации табличного браузера xslt-трансформации для печатаемого отчета к сериализованным в XML данным.
     * @param {Core/EventObject} eventObject Дескриптор события.
     * @param {String} idReport Название отчета, который собираемся печатать.
     * @param {Array} data Набор данных, которые собираемся печатать.
     * @param {String} transform Имя файла xslt-трансформации, которую собираемся применять.
     * @param {Boolean} forList Запущена ли печать отчёта записи или реестра.
     * @returns Можно вернуть:
     * <ol>
     *    <li>String - считаем результат события именем xslt-трансформации, которую необходимо применить;</li>
     *    <li>Любой другой результат - продолжаем печать стандартным образом.</li>
     * </ol>
     * @example
     * <pre>
     *    dataView.subscribe('onSelectReportTransform', function(event, report, data, transform){
     *       if(data.length > 1)
     *          event.setResult("xsl/myTransform.xsl");
     *    });
     * </pre>
     */
      /**
     * @event onBeforeShowPrintReports Перед построением списка отчетов для печати
     * Происходит перед тем, как на экран будет выведен список возможных для печати отчетов.
     * @param {Core/EventObject} eventObject Дескриптор события.
     * @param {Array} reports Список названий отчетов, которые собираемся выводить.
     * @param {Array} data Набор данных, которые собираемся печатать.
     * @param {Boolean} forList.
     * @returns Можно вернуть:
     * <ol>
     *    <li>False - отмена печати, механизм печати завершает работу;</li>
     *    <li>String - считаем, что пришедшая строка - название единственного отчета, который нужно напечатать, запускается печать отчета с указанным именем;</li>
     *    <li>Array - считаем пришедший массив новым набором названий отчетов для печати;<>
     *    <li>Любой другой результат - запускаем печать стандартным образом.</li>
     * </ol>
     * @example
     * <pre>
     *    dataView.subscribe('onBeforeShowPrintReports', function(event, reports, data, forList){
    *       if(data.length > 1)
    *          event.setResult("Отчет для записи");
    *    });
     * </pre>
     */
      /**
     * @event onBeforeTransform Перед xslt-трансформацией
     * Происходит перед xslt-трансформацией отчета.
     *
     * @param {Object}   eventObject Дескриптор события, описание в классе Core/Abstract
     * @param {Document} xml         XML-документ
     * @param {Document} xsl         XSL-документ
     */
   /**
    * @event onPrepareReportName Событие перед подготовкой имени файла отчёта
    * Происходит перед подготовкой имени файла отчёта.
    *
    * @param {Core/EventObject} eventObject Дескриптор события, описание в классе Core/Abstract
    * @param {String} fileType Тип файла
    * @param {String} idReport Идентификатор отчёта
    */
   /**
    * @event onBeforeShowColumnsDialog Перед отображением диалога со списком выгружаемых колонок
    * Происходит перед отображением диалога со списком выгружаемых колонок
    *
    * @param {Object}   eventObject Дескриптор события, описание в классе Core/Abstract
    * @returns Можно вернуть:
    * <ol>
    *    <li>Array - считаем пришедший массив новым набором колонок, используемым при выгрузке</li>
    *    <li>Любой другой результат - запускаем печать стандартным образом.</li>
    * </ol>
    */
      $withoutCondition: [ 'init', 'setUseDefaultPrint' ],
      $protected: {
         _options: {
         /**
          * @cfg {Object} Список отчетов для печати записи
          *
          * Список названий отчетов и соответствующих им xslt-преобразований для одной или нескольких записей.
          * @example
          * <pre>
          *    "reports": {
          *    "Первый отчет для записи" : "Abonenty/xslt/default-record-transform-1.xsl",
          *    "Второй отчет для записи" : "xsl!SBIS3.NAMESPACE.Module/resources/xsl/reestr"
          *    }
          * </pre>
          * @group Reports
          * @editor ReportsEditor
          */
            reports: {},
            /**
          * @cfg {String} Метод БЛ, который будет выполняться для формирования списка при сохранении
          */
            savePrepareMethod: '',
            /**
          * @cfg {String} Списочный метод БЛ, который будет использоваться при сохранении в Excel
          */
            saveToExcelListMethod: '',
            /**
          * @cfg {Object} Список отчетов для печати реестра
          *
          * Список названий отчетов и соответствующих им xslt-преобразований для печати реестра записей.
          * @example
          * <pre>
          *    "reports": {
          *    "Первый отчет для реестра" : "Abonenty/xslt/default-list-transform-1.xsl",
          *    "Второй отчет для реестра" : "xsl!SBIS3.NAMESPACE.Module/resources/xsl/reestr"
          *    }
          * </pre>
          * @group Reports
          * @editor ReportsEditor
          */
            reportsForList: {},
            /**
          * @cfg {String} Ориентация страницы при выгрузке в PDF
          * @remark (Только для метода PDF.Сохранить)
          * @typedef {string} DispositionType
          * @variant portrait  портретная (по умолчанию)
          * @variant landscape  альбомная
          */
            PDFOrientation : 'portrait' //'landscape'
         },
         _menuButtons: {
            'print' : [rk('Печать реестра') + ' (Ctrl+P)', 'sprite:icon-16 icon-Print icon-primary', 'print'],
            'printRecord' : [rk('Печать записи') + ' (F4)', 'sprite:icon-16 icon-Print icon-primary', 'printRecord']
         },
         _printMenu: null,                //Список отчетов для печати
         _needPrint: true,
         _reportPrinter: null,            //класс печати
         _useDefaultPrint: false,         // признак использования дефолтной печати
         _loadIndicator: undefined
      },
      $condition: function(){
         return this._useDefaultPrint || !ObjIsEmpty(this._options.reports || {}) || !ObjIsEmpty(this._options.reportsForList || {});
      },
      $constructor: function(){
         this._convertReportsPath(this._options.reports);
         this._convertReportsPath(this._options.reportsForList);
         if (this._options.display.rowOptions) {
            delete this._menuButtons.printRecord;
         }
         this._publish('onPrepareReportData', 'onSelectReportTransform', 'onBeforeShowPrintReports', 'onBeforeTransform', 'onPrepareReportName', 'onBeforeShowColumnsDialog');
         this._reportPrinter = new ReportPrinter({ columns: this._columnMap, titleColumn: this._options.display.titleColumn});
         this._keysWeHandle[cConstants.key.f4] = true;
         this._keysWeHandle[cConstants.key.p] = true;
         if (!ObjIsEmpty(this._options.reports || {})) {
            this._notify('onNewAction', {
               title: rk('Печать записи') + ' (F4)',
               icon: 'sprite:icon-16 icon-Print icon-primary',
               name: 'printRecord',
               callback: 'printRecord',
               isMainOption: this._isMainRowOption({name: 'printRecord'}),
               weight: 70
            });
         }
         CommandDispatcher.declareCommand(this, 'print', this.showReportsListForList);
         CommandDispatcher.declareCommand(this, 'printRecord', this.showReportsListForRecord);
      },
      _resolveReportPath: function(path) {
         var newPath,
            expansionAndPath = path.split('!');
         newPath = expansionAndPath[1] + '.' + expansionAndPath[0];
         return pResolver.resolveComponentPath(newPath);
      },
      _convertReportsPath: function(reports) {
         if (!ObjIsEmpty(reports || {})) {
            for (var key in reports) {
               if (reports.hasOwnProperty(key)) {
                  var
                     value = reports[key];
                  if ((/^.*!.*$/).test(value)) {
                     value = this._resolveReportPath(value);
                  }
               }
            }
         }
      },
      _drawToolBar: function(){
         var self = this;
         this._toolbarReady.addCallback(function(toolbar){
            if(self.getReports(true).length !== 0 || (!self._options.display.rowOptions && self.getReports(false).length !== 0)){
               var onSubMenuActivated = function(){
                  if (this.hasButton('menu')) {
                     this.getButton('menu').subscribe('onActivated', function(){
                        self._addSubMenuForToolbarElement('print', this.getId() + '_print', true);
                        if (!self._options.display.rowOptions) {
                           self._addSubMenuForToolbarElement('printRecord', this.getId() + '_printRecord', false);
                        }
                     });
                  }
               };
               try{
                  onSubMenuActivated.apply(toolbar, []);
               }catch(e){
                  toolbar.subscribe('onAfterLoad', onSubMenuActivated);
               }
            }
            return toolbar;
         });
      },
      _initActionsFlags: function(){
         var self = this;
         this._actions = this._actions || {};
         this._actions.print = $.proxy(self._showReportsListForList, self);
         this._actions.printRecord = !ObjIsEmpty(this._options.reports || {}) && function(row, isRowOptions, event){
            var record;
            if(row instanceof Object && 'jquery' in row){
               if(self._printMenu !== null && self._printMenu.isShow()){
                  self._createPrintMenu([]);
               } else {
                  record = self._currentRecordSet.getRecordByPrimaryKey(row.attr('rowkey'));
                  self._showReportsListForRecord(record, row, event);
               }
            }
            else{
               self._showReportsListForRecord();
            }
         };
      },
      _createRowOptionsSubMenu: function(actionName, menuElement){
         if(actionName == 'printRecord'){
            var rowkey = this._rowOptionsHoverRow.attr('rowkey');
            if(!this._isIdEqual(rowkey, this._rootNode)){
               var record = this.getRecordSet().getRecordByPrimaryKey(rowkey),
                  subMenu = this._prepareReports(false, record);
               if(subMenu === false){
                  this._needPrint = false;
               } else if(typeof(subMenu) == 'string'){
                  this._needPrint = subMenu;
                  subMenu = false;
               }
               if(subMenu){
                  menuElement.subMenu = subMenu;
               }
            }
         }
      },
      _addSubMenuForToolbarElement: function(elementName, elementId, forList, menu, record){
         var toolbarMenu = menu ? menu : this._toolbar.getMenu();
         if (toolbarMenu.hasSubMenu(elementId)) {
            toolbarMenu.destroySubMenu(elementId);
         }
         if(toolbarMenu.isVisible()){
            var result = this._prepareReports(forList, forList ? false : ( record ? record : this.getActiveRecord() ), elementName);
            if(result && ( result.constructor === Array || typeof(result) == 'string')){
               toolbarMenu.showItem(elementName);
               if(result.constructor === Array){
                  toolbarMenu.addSubMenu(elementName, result);
                  this._needPrint = false;
               } else {
                  this._needPrint = result;
               }
            } else {
               this._needPrint = false;
               if (!forList) {
                  toolbarMenu.hideItem(elementName);
               }
            }
         }
      },
      _prepareReports: function(forList, record, elementName){
         var subMenu = null,
            data = !this.hasSelectedRecords() ? ( record ? record : this.getActiveRecord()) : this.getSelection(),
            reports = this._notify('onBeforeShowPrintReports', this.getReports(forList), data, forList),
            self = this;
         if(reports === false){
            subMenu = false;
         } else {
            var reportsList;
            if(reports instanceof Array){
               reportsList = reports;
            } else{
               reportsList = this.getReports(forList);
            }
            if(reportsList.length == 1){
               subMenu = reportsList[0];
            } else {
               subMenu = [];
               for(var j = 0, l = reportsList.length; j < l; j++ ){
                  subMenu.push({
                     caption: reportsList[j],
                     id: self.getId() + '_' + elementName + reportsList[j],
                     handlers: {
                        onActivated: function(event, element){
                           self.printReport(element.caption, forList, self.getActiveRecord());
                        }
                     }
                  });
               }
            }
         }
         return subMenu;
      },
      _keyboardHover: function(e, res){
         var needShowPrintMenu = true;
         if(this._printMenu !== null && this._printMenu.isShow()){
            this._createPrintMenu([]);
            needShowPrintMenu = e.which !== cConstants.key.f4 && !(e.ctrlKey && e.which === cConstants.key.p);
         }
         if(this.isActive() && !e.altKey && !e.shiftKey && ( !e.ctrlKey && e.which === cConstants.key.f4 || (e.ctrlKey && e.which === cConstants.key.p) )){
            if(needShowPrintMenu && (!ObjIsEmpty(this._options.reports || {}) && e.which === cConstants.key.f4 || e.which !== cConstants.key.f4)){
               this._showReportsList(e, e.which !== cConstants.key.f4);
               return false;
            }
         }
         return res;
      },
      /**
    * Вызывает построение списка отчетов для реестра
    * @param {dTransportRecord} [record] Запись
    * @param {Object} [row] Строка в DOM-дереве
    * @param [event]
    */
      _showReportsListForList: function(){
         if (this._needPrint === true) {
            this._showReportsList(this._createFakeEvent(), true);
         } else if(typeof(this._needPrint) == 'string') {
            this.printReport(this._needPrint, true, null);
         }
      },
      showReportsListForList: function(){
         this._showReportsListForList();
      },
      /**
    * Вызывает построение списка отчетов для записи
    * @param {dTransportRecord}  [record]   Запись
    * @param {Object}            [row]      Строка в DOM-дереве
    */
      _showReportsListForRecord: function(record, row, event){
         if (this._needPrint === true) {
            this._showReportsList(typeof(event) == 'object' ? event : this._createFakeEvent(), false, record, row);
         } else if(typeof(this._needPrint) == 'string') {
            this.printReport(this._needPrint, false, record);
         }
      },
      showReportsListForRecord: function(record, row, event){
         this._showReportsListForRecord(record, row, event);
      },
      /**
    * выводит если нужно список отчетов или отправляет отчет на печать
    * @param {Event} e событие
    * @param {Boolean} isReportsForList печатать отчеты для реестра или для записи
    * @param {dTransportRecord}  [record] Запись
    * @param {Object}            [row]    Строка из DOM-дерева
    */
      _showReportsList: function(e, isReportsForList, record, row){
         var data = null, self = this, reports;
         if (!isReportsForList) {
            data = record ? record : (!this.hasSelectedRecords() ? this.getActiveRecord() : this.getSelection());
         }
         reports = this._notify('onBeforeShowPrintReports', this.getReports(isReportsForList), data, isReportsForList);
         if(reports !== false){
            var reportsList;
            if(reports instanceof Array){
               reportsList = reports;
               if (reports.length == 1) {
                  reports = reports[0];
               }
            } else{
               reportsList = typeof(reports) === 'string' ? [] : '';
            }
            this._createPrintMenu(reportsList, isReportsForList).addCallback(function(instance){
               if(self._printMenu === null){
                  if(!reports || reports === true){ // если не можем рассматривать то, что вернули из события как список отчетов, ищем среди описанных
                     var list = self._options[isReportsForList ? 'reportsForList' : 'reports'];
                     for(var report in list){ // если здесь найдется элемент, то он один
                        if(list.hasOwnProperty(report)){
                           reports = report;
                        }
                     }
                  }
                  reports = reports === true ? undefined : reports;
                  self.printReport(reports, isReportsForList);
               } else {
                  var activeElement = row ? row : (self._activeElement ? self._activeElement : self._body.find('tr').eq(0)),
                     offset = {},
                     block,
                     point;

                  if (self._options.display.rowOptions) {
                     block = self._rowOptionsButtons.printRecord;

                     if (!block || !block.is(':visible')) {
                        block = activeElement;
                     }
                  } else {
                     block = activeElement;
                  }

                  point = block.offset();

                  if (isReportsForList) {
                     offset.left = point.left + block.width() - self._printMenu.getMenuWidth();
                  } else {
                     offset.left = point.left;
                  }

                  offset.top = point.top + block.height();

                  try{
                     self._printMenu.show(offset);
                  } catch(error){
                     self._printMenu.subscribe('onReady', function(){
                        self._printMenu.show(offset);
                     });
                  }
               }
               return instance;
            });
         }
      },
      /**
    *
    * Возвращает массив названий отчетов, возможных для печати реестра или записи.
    * @param {Boolean} isReportsForList Возвращать названия отчётов для записи или для реестра.
    * @return {Array} Массив названий отчетов.
    * @example
    * <pre>
    *    dataView.getReports(false);
    * </pre>
    */
      getReports: function(isReportsForList){
         return Object.keys((isReportsForList ? this._options.reportsForList : this._options.reports) || {});
      },
      /**
    * Создает меню для выбора из списка отчетов, возможных для печати
    * @return {Core/Deferred}
    */
      _createPrintMenu:function(reportsList, isReportsForList){
         var self = this,
            reports = [],
            declaredReportsList;
         if(!reportsList || !(reportsList instanceof Array)){
            reportsList = [];
            declaredReportsList = isReportsForList ? this._options.reportsForList : this._options.reports;
            for(var i in declaredReportsList){
               if(declaredReportsList.hasOwnProperty(i)){
                  reportsList.push(i);
               }
            }
         }
         for(var k = 0, l = reportsList.length; k < l; k++){
            reports[k] = {
               caption: reportsList[k],
               id: reportsList[k],
               handlers: {
                  onActivated: function(id, elem){
                     self.printReport(elem.caption, isReportsForList);
                  }
               }
            };
         }
         if(self._printMenu !== null){
            self._printMenu.destroy();
            self._printMenu = null;
         }
         if(reports.length > 1){
            return cAttach.attachInstance('Deprecated/Controls/Menu/Menu', {
               data: reports
            }).addCallback(function(instance){
               self._printMenu = instance;
               return instance;
            });
         } else {
            return new cDeferred().callback();
         }
      },
      _getCurrentTransform: function(idReport, isReportsForList){
         return idReport ?
            (isReportsForList ? this._options.reportsForList[idReport] : this._options.reports[idReport]) :
            'default-list-transform.xsl';
      },
      _getPreparedData: function (data, doPreparation, allowShowDialog, printCurPage, noIndicator) {
         var defResult = new cDeferred(),
            self = this;
         if (doPreparation) {
            this._prepareReportDataForList(allowShowDialog, printCurPage, noIndicator).addCallback(function (dataForList) {
               var needRS;
               if (dataForList instanceof dTransportRecord) {
                  dataForList = [dataForList];
                  needRS = true;
               } else if (dataForList instanceof Array) {
                  needRS = true;
               }
               if (needRS) {
                  dataForList = self._transformToRS(dataForList);
               }
               if (dataForList instanceof dTransportRecordSet) {
                  defResult.callback(dataForList);
               }
            }).addErrback(function(error){
               $('body').toggleClass('ws-progress', false);
               InformPopManager.showMessageDialog({
                  status: 'error',
                  message: error,
                  opener: self
               });
            });
         } else {
            if (!noIndicator) {
               this._createLoadIndicator(rk('Печать записей...'));
            }
            defResult.callback(data);
         }
         return defResult;
      },
      _saveTo: function(idReport, isReportForList, fileType) {
         var self = this,
            title = rk('Что сохранить в') + ' ' + fileType;

         this._validateRecordCount(title, fileType).addCallback(function(records) {
            self._prepareDataToSave(fileType, idReport, isReportForList, records);
         });
      },
      /**
    *
    * Сохранить реестр или отмеченные записи в pdf.
    * Запускает сохранение указанного отчета из списка отчетов реестра или отчетов записи.
    * @param {String}   idReport         Название сохраняемого отчета
    * @param {Boolean}  isReportForList  Признак того, что сохраняем отчет для записи или для реестра
    */
      saveToPDF: function(idReport, isReportForList) {
         this._saveTo(idReport, isReportForList, 'PDF');
      },
      /**
    *
    * Сохранить реестр или отмеченные записи в excel.
    * Запускает сохранение указанного отчета из списка отчетов реестра или отчетов записи.
    * @param {String}   idReport         Название сохраняемого отчета
    * @param {Boolean}  isReportForList  Признак того, что сохраняем отчет для записи или для реестра
    */
      saveToExcel: function(idReport, isReportForList) {
         this._saveTo(idReport, isReportForList, 'EXCEL');
      },
      /**
    *
    * Сохранить выбранные колонки реестра или отмеченных записей в excel.
    * Запускает сохранение выбранных колонок по дефолтному отчету реестра.
    */
      saveColumnsToExcel: function() {
         var selected = this.getSelection(true),
            records = selected.length ? selected : this.getRecordSet().getRecords();

         this._createSaveColumnsDialog(records);
      },
      _prepareHTMLForColumns: function() {
         var html = '<table class="ws-select-columns-table">',
            render = function(column) {
               var title = column.title || column.field
               return [
                  '<tr class="ws-selected-columns-tr ws-select-columns-tr-checked" userTitle="', title,'" field="', column.field, '">',
                  '<td>', title, '</td>',
                  '<td class="ws-selected-columns-right">',
                  '<span class="ws-select-columns-checkbox ws-select-columns-checked"></span>',
                  '</td>',
                  '</tr>'
               ].join('');
            },
            fields = this._notify('onBeforeShowColumnsDialog');
         if (!fields) {
            fields = this.getFields(true);
         }
         for (var key in fields) {
            if (fields.hasOwnProperty(key)) {
               html += render(fields[key]);
            }
         }
         html += '</table>';

         return html;
      },
      _createSaveColumnsDialog: function(records) {
         var self = this;

         new Dialog({
            template: 'Deprecated/res/wsmodules/SelectColumnsDialog/SelectColumnsDialog',
            resizable: false,
            opener: self,
            handlers: {
               'onAfterLoad': function() {
                  var dialog = this;
                  $('.ws-selectColumnsDialog-data', this.getContainer).html(self._prepareHTMLForColumns());

                  this.getChildControlByName('okButton').subscribe('onClick', function() {
                     var columns = [],
                        titles = [],
                        processData,
                        tr = $.makeArray(this.getParent()._container.find('.ws-select-columns-tr-checked')),
                        options;

                     for (var i = 0, l = tr.length; i < l; i++) {
                        columns.push($(tr[i]).attr('field'));
                        titles.push($(tr[i]).attr('userTitle'));
                     }

                     options = {
                        fileType: 'EXCEL',
                        columns: columns,
                        titles: titles
                     };
                     processData = function(data) {
                        self._saveToFile(options, undefined, data || records);
                     };
                     self._onPrepareReportDataHandler(processData, undefined, records);
                     dialog.close();
                  });

                  this._container.find('.ws-select-columns-checkbox').bind('click', function() {

                     var checkbox = $(this),
                        tr = checkbox.closest('tr'),
                        className = 'ws-select-columns-checked',
                        trClass = 'ws-select-columns-tr-checked';

                     if (checkbox.hasClass(className)) {
                        checkbox.removeClass(className);
                        tr.removeClass(trClass);
                     } else {
                        checkbox.addClass(className);
                        tr.addClass(trClass);
                     }
                  });
               },
               'onAfterShow' : function() {
                  this.moveWindowToCenter();
               }
            }
         });
      },

      _saveToFile: function(options, idReport, data, isReportsForList) {
         var readerParams = this.getDataSource().readerParams,
            listMethod = readerParams ? readerParams.queryName : 'Список',
            isSaveColumns = options.columns && options.columns.length > 0,
            fileName = idReport ? idReport : (isSaveColumns ? 'Выбранные столбцы' : 'Как на экране'),
            xsl,
            fileType = options.fileType,
            userSaveToExcelListMethod = fileType === 'EXCEL' && typeof this._options.saveToExcelListMethod === 'string' && this._options.saveToExcelListMethod.length,
            object = fileType,
            methodName = fileType === 'PDF' ?
               (typeof this._options.savePrepareMethod === 'string' && this._options.savePrepareMethod.length ?
                  this._options.savePrepareMethod :
                  'Сохранить') :
               (idReport && !userSaveToExcelListMethod && data ?
                  'СохранитьПоHTML' :
                  ((isReportsForList || userSaveToExcelListMethod) && !data ?
                     'Сохранить' :
                     'СохранитьВыборочно')),
            filter = this.getQuery(),
            rp = this._reportPrinter,
            uniqueToken = ('' + Math.random()).substr(2)* 1,
            self = this,
            rootNode,
            xmlDoc,
            xslDoc,
            params,
            column,
            columns;


         xsl = this._notify('onPrepareReportName', fileType, idReport);
         if (!xsl) {
            xsl = this._getCurrentTransform(idReport, isReportsForList);
         }

         if (object === 'EXCEL') {
            object = 'Excel';
         }

         if (this.isHierarchyMode()) {
            rootNode = this._currentRootId;
         }
         if (fileType === 'EXCEL' && (!idReport || userSaveToExcelListMethod)) {
            if (isReportsForList && !data) {
               params = {
                  'ИмяМетода': userSaveToExcelListMethod ?
                     this._options.saveToExcelListMethod :
                     (readerParams ? readerParams.linkedObject + '.' + listMethod : ''),
                  'Фильтр': ReaderSBIS.prototype.prepareFilter(filter),
                  'Сортировка': ReaderSBIS.prototype._prepareSorting(filter)
               };
            } else {
               params = {
                  'Записи': data ? (data instanceof Array ? this._serializeRecords(data) : data) : this.getRecordSet()
               };
            }
            if (isSaveColumns) {
               params['Поля'] = options.columns;
               params['Заголовки'] = options.titles;
            } else {
               params['Поля'] = this.getFields();
               params['Заголовки'] = this.getColumnsTitle(true);
            }
         }
         if (params && !ObjIsEmpty(params)) {
            params['Название'] = fileName;
            params.fileDownloadToken = uniqueToken;
         }
         if (fileType === 'PDF' || (fileType === 'EXCEL' && idReport !== undefined && !userSaveToExcelListMethod)) {
            data = this._transformToRS(data);
            xsl = this._getTransform(idReport, data, xsl, isReportsForList, fileType);
            xslDoc = new IoC.resolve('IXMLDocument', {name: xsl}).getDocument();
            xmlDoc = RecordSetToXMLSerializer.serialize(data, rp.getColumns(), rp.getTitleColumn(), rootNode);

            xslDoc.addCallback(function (xslDocument) {
               columns = self._notify('onBeforeTransform', xmlDoc, xslDocument);
               //если изменили набор выгружаемых колонок, пересоздадим xml документ с новым набором колонок
               if (columns instanceof Array) {
                  rp.setColumns(columns);
                  xmlDoc = RecordSetToXMLSerializer.serialize(data, columns, rp.getTitleColumn(), rootNode);
               }
               rp.prepareReport(data, xslDocument, rootNode, xmlDoc).addCallback(function(reportText){
                  var extraParam = {};
                  if (object === 'PDF' && methodName === 'Сохранить') {
                     extraParam['ОриентацияСтраниц'] = self._options.PDFOrientation === 'portrait' ? 1 : 2;
                  }
                  self._checkSaveIndicator(object, methodName,
                     cMerge({
                        'html': reportText,
                        'Название': fileName,
                        'fileDownloadToken': uniqueToken
                     }, extraParam),
                     fileType);
               });
            });
         } else if (params && !ObjIsEmpty(params) && object && methodName) {
            if (!isSaveColumns) {
               columns = this._notify('onBeforeTransform');
            }
            if (columns instanceof Array && columns.length) {
               params['Поля'] = [];
               params['Заголовки'] =[];
               for (var j = 0; j < columns.length; j++) {
                  if (columns[j]) {
                     params['Поля'][j] = columns[j].field;
                     params['Заголовки'][j] = columns[j].title;
                  }
               }
            }
            this._checkSaveIndicator(object, methodName, params, fileType);
         }
         this.removeSelection();
      },
      _checkSaveIndicator: function(object, methodName, params, fileType){
         var self = this,
            saveToFile = function () {
               cSaveToFile(object, methodName, params).addBoth(function(e){
                  self._destroyLoadIndicator();
                  if (e && e.message) {
                     IoC.resolve('ILogger').log( rk('Ошибка выгрузки в') + ' '  + object +': ' + e.message);
                  }
                  return e;
               });
            };
         if (CControl.ControlStorage.containsByName('ws-load-indicator')) {
            saveToFile();
         } else {
            this._createLoadIndicator(rk('Подождите, идет выгрузка данных в') + ' ' + fileType);
            saveToFile();
         }
      },
      _prepareDataToSave: function(fileType, idReport, isReportsForList, records) {
         var selectedRecords = this.getSelection(true),
            data = records || records === false ? records : (selectedRecords.length ? selectedRecords : this.getRecordSet().getRecords()),
            self = this,
            options;

         options = {
            fileType: fileType
         };

         this._createLoadIndicator(rk('Подождите, идет выгрузка данных в') + ' ' + fileType);

         if (!records) {
            self._saveToFile(options, idReport, data, isReportsForList);
         } else {

            this._getPreparedData(data, false, false, undefined, true).addCallback(function (preparedData) {

               data = preparedData;

               var processData = function(eventResult) {
                  if (eventResult instanceof dTransportRecord) {
                     eventResult = [eventResult];
                  }
                  if (eventResult instanceof dTransportRecordSet) {
                     eventResult = eventResult.getRecords();
                  }
                  if (eventResult instanceof Array) {
                     data = eventResult;
                  }
                  self._saveToFile(options, idReport, data, isReportsForList);
               };

               self._onPrepareReportDataHandler(processData, idReport, data);
            });

         }
      },
      _validateRecordCount: function(title, fileType){

         var def = new cDeferred(),
            rs = this.getRecordSet(),
            records = rs.getRecords(),
            selected = this.getSelection(true),
            self = this;

         if (selected.length > 0) {
            def.callback(selected);
         } else {
         //Показываем диалог для выбора записей, необходимых выгрузить, если есть пэйджинг и либо
         //количество записей в текущем рекордсете больше размера страницы, либо если страниц больше чем одна
            if (this.getPagingMode() && (rs.getRecordCount() >= rs.getPageSize() || this._currentRecordSet.getPageNumber() > 0 || this._currentRecordSet.hasNextPage(true))) {

               this._selectPrintPages(title, fileType).addCallback(function(res){

                  if (typeof res === 'number') {

                     if (records.length > res) {
                        records = records.slice(0, res);
                     }

                     def.callback(records);

                  } else if (res) {
                     res.handlers.onAfterLoad = function () {
                        self._destroyLoadIndicator();
                        def.callback(this.getRecords());
                     };
                     self._createLoadIndicator(rk("Подождите, идет загрузка данных"));
                     new dTransportRecordSet(res);
                  } else {
                  //Стреляем с false как признак того, что записи будут получаться с БЛ
                     def.callback(false);
                  }
                  return res;
               });

            } else {
               def.callback(records);
            }
         }

         return def;
      },
      _serializeRecords: function (records) {
         var selection = {
               s: [],
               d: []
            },
            json,
            l;
         if (records && (l = records.length) > 0) {
            for (var i = 0; i < l; i++) {
               if (records[i] instanceof dTransportRecord) {
                  if (i === 0) {
                     json = records[i].toJSON();
                     selection.s = json.s;
                     selection.d.push(json.d);
                  } else {
                     selection.d.push(records[i].getDataRow());
                  }
               }
            }
         }
         return selection;
      },
      /**
    *
    * Отправляет на печать выбранные записи.
    * Запускает печать указанного отчета из списка отчетов реестра или отчетов записи.
    * При печати записи может напечатать переданные данные, иначе будут выведены на печать отмеченные в данный момент записи.
    * @param {String}   idReport                      Название печатаемого отчета
    * @param {Boolean}  isReportsForList              Признак того, что печатаем отчет для записи или для реестра
    * @param {Array}    [data]                        Данные для печати
    * @param {Boolean}  [printCurPage]                Печатаем текущую страницу
    */
      printReport: function (idReport, isReportsForList, data, printCurPage) {
         var printData = data ? data : (isReportsForList ? this.getRecordSet() : this.getSelection()),
            transform = this._getCurrentTransform(idReport, isReportsForList),
            selectedRecords = this.getSelection(true),
            isHierarchy = this.isHierarchy(),
            doPreparation = false,
            self = this,
            allowShowDialog = true;

         $('body').toggleClass('ws-progress', true);
         if (!this._currentRecordSet.getPageNumber() && !this._currentRecordSet.hasNextPage(true)){
            printCurPage = true;
            allowShowDialog = false;
         }

         if (selectedRecords.length === 0) {
            if (this.isMinimized()) {
               printData = this._currentRecordSet.getRecords();
            } else {
               doPreparation = !!((!isHierarchy || (isHierarchy && this._turn === '')) && !this.isTree() && this.getPagingMode());
            }
         } else {
            printData = selectedRecords;
         }

         this._getPreparedData(printData, doPreparation, allowShowDialog, printCurPage).addCallback(function (preparedData) {
            printData = preparedData;
            var processData = function (eventResult) {
               if (eventResult instanceof dTransportRecord || eventResult instanceof dTransportRecordSet || eventResult instanceof Array) {
                  printData = eventResult;
               }
               self._showReport(idReport, self._transformToRS(printData), transform, isReportsForList);
            };
            self._onPrepareReportDataHandler(processData, idReport, printData);
         });
      },
      _onPrepareReportDataHandler: function (callback, idReport, data) {
         var eventResult = this._notify('onPrepareReportData', idReport, this._transformToRS(data));
         if (eventResult !== false) {
            if (eventResult instanceof cDeferred) {
               eventResult.addCallback(callback);
            } else {
               callback.apply(this, [eventResult]);
            }
         } else {
            $('body').toggleClass('ws-progress', false);
         }
      },
      _createLoadIndicator: function (message) {
         this._loadIndicator = new LoadingIndicator({
            'message': message,
            'name': 'ws-load-indicator'
         });
      },
      _destroyLoadIndicator: function ( ) {
         if (this._loadIndicator) {
            this._loadIndicator.hide();
            this._loadIndicator.destroy();
            this._loadIndicator = undefined;
         }
      },
      _transformToRS: function (object) {
         var data, l;
         if (object instanceof Array && (l = object.length) > 0) {
            var firstRecord = object[0],
               rs = firstRecord.getRecordSet();
            //получим колонки либо от рекордсета первой записи, либо сериализовав ее в json
            data = {
               s: rs ? cloneArray(rs.getColumnsForSerialize()) : firstRecord.toJSON().s,
               d: []
            };
            for (var i = 0; i < l; i++) {
               data.d.push(cloneArray(object[i].getDataRow()));
            }
            object = new dTransportRecordSet({
               readerType: 'ReaderSBIS',
               readerParams: {
                  pkColumnName: firstRecord.getKeyField(),
                  adapterType : 'TransportAdapterStatic',
                  adapterParams: {
                     data: data
                  }
               }
            });
         }
         return object;
      },
      _getTransform: function(idReport, object, xsl, isReportsForList, fileType) {
         var transform,
            res;

         fileType = fileType ? fileType.toLowerCase() : undefined;

         if (typeof idReport === 'undefined') {
            transform = cConstants.wsRoot + 'res/xsl/' + xsl;
         } else {
            res = this._notify('onSelectReportTransform', idReport, object, xsl, isReportsForList, fileType);
            if (typeof res === 'string') {
               xsl = res;
            }

            transform = cConstants.resourceRoot + xsl;
         }

         return transform;
      },
      /**
    * Сериализует данные, применяет xslt-транформацию и выводит полученный результат
    * @param {string} idReport название печатаемого отчета
    * @param {dTransportRecord | dTransportRecordSet} object данные для печати
    * @param {String} transform файл xslt-трансформации
    */
      _showReport:function(idReport, object, xsl, isReportsForList){
         var
            rp = this._reportPrinter,
            rootNode = this.isHierarchyMode() ? this._currentRootId : undefined,
            xmlDoc,
            columns,
            self = this,
            xslDoc = this._getTransform(idReport, object, xsl, isReportsForList);

         this._useKeyboard = true;
         rp.setColumns(this._columnMap);
         xmlDoc = RecordSetToXMLSerializer.serialize(object, rp.getColumns(), rp.getTitleColumn(), rootNode);
         columns = this._notify('onBeforeTransform', xmlDoc, xslDoc);
         if (columns instanceof Array) {
            rp.setColumns(columns);
            xmlDoc = RecordSetToXMLSerializer.serialize(object, rp.getColumns(), rp.getTitleColumn(), rootNode);
         }
         rp.prepareReport(object, xslDoc, rootNode, xmlDoc).addCallback(function (reportText) {
            PrintDialogHTMLView({
               caption: '',
               htmlText: reportText,
               opener: self,
               handlers: {
                  onInit: function () {
                     if (self._loadIndicator) {
                        self._loadIndicator.getWindow().moveToTop();
                     }
                  },

                  onAfterClose: function () {
                     self._destroyLoadIndicator();
                  }
               }
            }).addCallback(function (printDialog) {
               self._destroyLoadIndicator();
               printDialog.subscribe('onAfterClose', $.proxy(self._mouseMonitor, self));
               self.removeSelection();
            });
         }).addErrback(function (error) {
            InformPopManager.showMessageDialog({
               status: 'error',
               message: error,
               opener: self
            });
         }).addBoth(function () {
            $('body').toggleClass('ws-progress', false);
         });
      },
      destroy: function(){
         this._reportPrinter = null;
         this._loadIndicator = undefined;
      },
      /**
    * Запрашивает данные, необходимые для построения печати реестра записей
    * @param {Boolean} allowShowDialog показывать ли диалог с выбором страницы для печати
    * @param {Boolean} printCurPage печатать текущую страницу
    * @param {Boolean} noIndicator показывать индикатор процесса
    * @return {Core/Deferred} Асинхронный результат получения данных для отчета реестра записей
    */
      _prepareReportDataForList: function(allowShowDialog, printCurPage, noIndicator){
         if (allowShowDialog === undefined) {
            allowShowDialog = true;
         }
         var dResult = new cDeferred(),
            isHierarchy = this.isHierarchy(),
            self = this;
         if(allowShowDialog && (!isHierarchy || (isHierarchy && this._turn === '')) && this._paging){
            self._selectPrintPages("").addCallback(function(res){
               if (!noIndicator) {
                  self._createLoadIndicator(rk('Печать записей...'));
               }
               if(typeof res !== 'number'){
                  self._getData(res, dResult);
                  $('body').toggleClass('ws-progress', true);
               }else{
                  var rs = self.getRecordSet(),
                     records = [],
                     keys;
                  if (isHierarchy && !self._currentRootId) {
                     keys = rs.recordChilds(null);
                     for (var i = 0; i < res; i++) {
                        records.push(rs.getRecordByPrimaryKey(keys[i]));
                     }
                  } else {
                     records = rs.getRecords().slice(0, res);
                  }
                  dResult.callback(records);
               }
               return res;
            }).addErrback(function(){
               $('body').toggleClass('ws-progress', false);
            });
         }else {
            self._getData(self._pickDataSource(printCurPage), dResult);
         }
         return dResult;
      },
      prepareReportDataForList: function(allowShowDialog){
         return this._prepareReportDataForList(allowShowDialog);
      },
      /**
    * Отображает окно с выбором страницы для печати реестра
    * @param {String} title Заголовок окна
    * @return {Core/Deferred} Асинхронный результат получения данных
    * @private
    */
      _selectPrintPages: function(title, fileType){
         var defResult = new cDeferred(),
            ctx = cContext.createContext(this, null, this.getLinkedContext()),
            rs = this._currentRecordSet,
            currentRecordsCount = rs.getRecords().length,
            isHierarchy = this.isHierarchy(),
            self = this,
            currentValue;

         defResult.addErrback(function (e) {
            return e;
         });

         title = title || rk('Что напечатать');
         ctx.setValue('recordsCount', currentRecordsCount);
         if (isHierarchy && !this._currentRootId) {
            currentRecordsCount = rs.recordChilds(null).length;
         }
         new Dialog({
            template: 'Deprecated/res/wsmodules/ValidateCountDialog/ValidateCountDialog',
            caption: title,
            resizable: false,
            context: ctx,
            opener: this,
            handlers: {
               'onAfterLoad': function(){
                  var fieldInteger = this.getChildControlByName('recordsCount'),
                     radioButtons = this.getChildControlByName('radioButtons'),
                     dialog = this;
                  currentValue = radioButtons.getStringValue();
                  this.getChildControlByName('okButton').subscribe('onActivated', function(){
                     if(dialog.validate()){
                        var pageNumber = self.getRecordSet().getPageNumber(),
                           value = fieldInteger.getValue();
                        if(value > currentRecordsCount){
                           InformPopManager.showConfirmDialog({
                              message: rk('Операция займет продолжительное время. Провести операцию?'),
                              opener: self
                           }, function() {
                              if (currentValue === 'allRecords' && (self._options.saveToExcelListMethod && fileType === "EXCEL")) {
                                 defResult.callback(false);
                              } else {
                                 defResult.callback(self._getOperationSource(value, currentValue, pageNumber));
                              }
                           }, function() {
                              defResult.errback();
                           });
                        } else if (isHierarchy && self._currentRootId) {
                           defResult.callback(self._getOperationSource(value, currentValue, pageNumber));
                        } else if (value) {
                           defResult.callback(value);
                        } else {
                           defResult.errback();
                        }
                        dialog.close();
                     }
                  });
                  radioButtons.subscribe('onChange', function(e, item){
                     var itemName = item.toString();
                     if(itemName !== 'countRecords' && fieldInteger.isVisible()) {
                        fieldInteger.hide();
                     }
                     switch(item.toString()){
                        case 'countRecords':
                           fieldInteger.setValue(currentRecordsCount);
                           fieldInteger.show();
                           break;
                        case 'allRecords':
                           fieldInteger.setValue(MAX_VALUE);
                           break;
                        case 'currentPage':
                           fieldInteger.setValue(currentRecordsCount);
                     }
                     currentValue = this.getStringValue();
                  });
                  $('body').toggleClass('ws-progress', false);
               },
               'onAfterShow' : function() {
                  this.moveWindowToCenter();
               },
               'onAfterClose': function() {
                  if (ctx && !ctx.isDestroyed()) {
                     ctx.destroy();
                  }
               }
            }
         });
         return defResult;
      },
      _getOperationSource: function (rowsPerPage, amount, pageNumber) {
         var dataSourceCopy = cMerge({}, this.getDataSource());
         dataSourceCopy.handlers = {};
         dataSourceCopy.filterParams = this.getQuery();
         //Нам нужно запускать загрузку всегда для своего рекордсета
         dataSourceCopy.firstRequest = true;
         dataSourceCopy.filterParams.pageNum = (amount === 'allRecords' || amount === 'countRecords') && pageNumber > 0 ? 0 : pageNumber;
         dataSourceCopy.pageNum = dataSourceCopy.filterParams.pageNum;
         dataSourceCopy.filterParams.usePages = 'parts';
         dataSourceCopy.usePages = 'parts';
         dataSourceCopy.rowsPerPage = rowsPerPage;
         return dataSourceCopy;
      },
      _pickDataSource: function(printCurPage){
      //сделаем копию dataSource, чтобы в исходном ничего не затереть случайно
         var dtSource = coreClone(this._options.dataSource);
         dtSource.filterParams = this.getQuery();
         if(printCurPage){
            dtSource.filterParams.pageNum = this._currentRecordSet.getPageNumber();
         } else {
            dtSource.filterParams.pageNum = '';
            dtSource.filterParams.usePages = '';
         }
         if(this.isTree()){ // для дерева будем печатать все открытые ветки
            dtSource.filterParams[this._hierColumnParentId] = this.getOpenFolders();
         }
         if (!printCurPage) {
            dtSource.usePages = '';
         }
         dtSource.firstRequest = true;
         return dtSource;
      },
      _getData: function(dataSource, def){
         var self = this;
         return cAttach.attachInstance('Deprecated/RecordSet', cMerge(coreClone(dataSource), { firstRequest : true, handlers: null })).addCallback(function(rs){
            rs.subscribe('onAfterLoad', function(){
               def.callback(rs);
            });
         }).addErrback(function(error){
            $('body').toggleClass('ws-progress', false);
            InformPopManager.showMessageDialog({
               status: 'error',
               message: error,
               opener: self
            });
         });
      },
      _createFakeEvent: function() {
         var event;
         if( document.createEvent ) {
            event = document.createEvent('HTMLEvents');
         } else if( document.createEventObject ) {
            event = document.createEventObject();
         }
         return event;
      },
      setUseDefaultPrint: function(){
         this._useDefaultPrint = true;
      }
   });

});
