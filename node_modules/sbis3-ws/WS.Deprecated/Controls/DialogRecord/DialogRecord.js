/**
 * Модуль "Компонент SimpleDialogAbstract".
 *
 * @description
 */
define('Deprecated/Controls/DialogRecord/DialogRecord', [
   'SBIS3.CONTROLS/Utils/InformationPopupManager',
   'Core/PrintDialogHTMLView',
   'Core/helpers/Function/forAliveOnly',
   'Lib/Control/Dialog/Dialog',
   'Lib/Control/LoadingIndicator/LoadingIndicator',
   'Core/CommandDispatcher',
   'Transport/ReportPrinter',
   'Deprecated/Record',
   'Core/IoC',
   'Core/Deferred',
   'Deprecated/RecordSet',
   'Core/constants',
   'i18n!Deprecated/Controls/DialogRecord/DialogRecord'
], function(
   InformPopManager,
   showHTMLForPrint,
   forAliveOnly,
   Dialog,
   LoadingIndicator,
   CommandDispatcher,
   ReportPrinter,
   Record,
   IoC,
   Deferred,
   RecordSet,
   $const
) {

   'use strict';

   var
      logger = IoC.resolve('ILogger');

   var newContextMenu = function (items, onActivate) {
      var config = [];
      for (var k = 0, l = items.length; k < l; k++) {
         config[k] = {
            caption: items[k],
            id: items[k],
            handlers: {}
         };
         if (typeof(onActivate) === 'function') {
            config[k].handlers['onActivated'] = onActivate;
         }
      }

      var res = new Deferred();
      require(['Deprecated/core-attach'], function (attach) {
         res.dependOn(attach.attachInstance('Deprecated/Controls/Menu/Menu', {
            data: config
         }));
      });

      return res;
   };

   /**
    * Модальный диалог редактирования записи
    * @public
    * @class Deprecated/Controls/DialogRecord/DialogRecord
    * @author Крайнов Д.О.
    * @extends Lib/Control/Dialog/Dialog
    * @deprecated Используйте класс {@link SBIS3.CONTROLS/Action/List/OpenEditDialog}.
    */
   var DialogRecord = Dialog.extend(/** @lends Deprecated/Controls/DialogRecord/DialogRecord.prototype */{
      /**
       * @event onBeforeSave Перед сохранением записи
       * Событие происходит перед сохранением записи.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @returns {Core/Deferred|Boolean} Для отмены сохранения изменений на диалоге редактирования нужно вернуть
       * false/чтобы Deferred вернул false.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onBeforeSave', function(event){
       *       //кем бы ты ни был раньше, теперь ты Иванов
       *       this.getRecord().set('Фамилия', 'Иванов');
       *       event.setResult(true);
       *    });
       * </pre>
       */
      /**
       * @event onSave Для замены штатной процедуры сохранения
       * Событие, предназначенное для замены штатной процедуры сохранения.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @returns {Core/Deferred|Boolean} Обработка возвращаемых значений:
       * <ol>
       *    <li>false - отмена сохранения целиком,</li>
       *    <li>Deferred - своя процедура сохранения,</li>
       *    <li>любое другое - штатная процедура.</li>
       * </ol>
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onSave', function(event){
       *       //не будем сохранять
       *       event.setResult(false);
       *    });
       * </pre>
       */
      /**
       * @event onSuccess При успешном сохранении записи
       * Событие в случае успешного сохранения записи.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Boolean} result Результат выполнения операции.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onSuccess', function(event, result){
       *      if (result)
       *        CoreFunctions.message('Все хорошо!');
       *    });
       * </pre>
       */
      /**
       * @event onFail При неудачном сохранении записи
       * Событие, происходящее в случае неудачного сохранения записи.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Object} error Ошибка.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onFail', function(event, error){
       *       CoreFunctions.alert('Все сломалось потому, что ' + error.message);
       *    });
       * </pre>
       */
      /**
       * @event onRecordUpdate В момент отправки записи на сервер
       * Событие, происходящее в момент успешной отправки записи на сервер (когда сохранение уже произошло).
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Number} id Идентификтор созданной/редактируемой записи.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onRecordUpdate', function(event){
       *      CoreFunctions.alert('Мы начали сохранять запись. Пожалуйста, не выключайте питание компьютера!');
       *    });
       * </pre>
       */
      /**
       * @event onBeforeDelete Перед удалением записи
       * Событие, происходящее перед удалением записи с диалога редактирования.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onBeforeDelete', function(event){
       *       //Если запись изменена (а значит не сохранена), запрещаем удаление
       *       event.setResult(!this.getRecord().isChanged()); //this - контрол, на который подписались - диалог редактирования
       *    });
       * </pre>
       */
      /**
       * @event onRecordDeleted После удаления записи
       * Событие, происходящее после удаления записи.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onRecordDeleted', function(event){
       *      CoreFunctions.alert('AAA! Запись удалилась и данные не вернуть!');
       *    });
       * </pre>
       */
      /**
       * @event onBeforeShowConfirmDialog Перед показом диалога подтверждения сохранения
       * Событие срабатывает перед показом диалога подтверждения сохранения.
       * Диалог подтверждения появляется при закрытии диалога редактирования, если изменённые данные не были предварительно сохранены.
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {Deprecated/Record} record Редактируемая запись.
       * @return {Boolean} Для отмены показа диалога подтверждения сохранения нужно вернуть false, запись при этом сохранится.
       * @example
       * <pre>
       *    //btn - кнопка на диалоге редактирования
       *    btn.getTopParent().subscribe('onBeforeShowConfirmDialog', function(event, record) {
       *        event.setResult(record.isChanged())
       *     });
       * </pre>
       */
      $protected: {
         _options: {
            /**
             * @cfg {Boolean} Только для чтения
             *
             * При включении режима "Только для чтения" данные диалога редактирования доступны только на просмотр.
             * @example
             * //пользователь не может менять значения контролов на диалоге редактирования
             * <pre>
             *    <option name="readOnly">true</option>
             * </pre>
             */
            readOnly: false,
            /**
             * @cfg {Boolean} Является ли запись только что созданной
             *
             * @example
             * <pre>
             *     <option name="newRecord">true</option>
             * </pre>
             * @see newRecord
             */
            newRecord: false,
            reports: {},
            /**
              * @cfg {Boolean} Сохранять только изменённые значения
              * @example
              * <pre>
              *     <option name="diffOnly">true</option>
              * </pre>
              * @see setSaveDiffOnly
              */
            diffOnly: false, //значение по умолчанию при сохранении записи,
            /**
             * @cfg {String} Текст рядом с индикатором сохранения записи
             * @translatable
             * @example
             * <pre>
             *     <option name="indicatorSavingMessage">Занят важным делом - сохраняю ваши данные.</option>
             * </pre>
             */
            indicatorSavingMessage:  rk('Подождите, идёт сохранение')
         },
         /**
          * @cfg {Deprecated/Record} record Запись, отображаемая в диалоге
          * Все контролы, названия которых будут совпадать с полями записи, возьмут себе значения из этой записи.
          * @example
          * <pre>
          *    var recSet;
          *    helpers.newRecordSet('Абонент', 'СписокАбонентов', undefined, 'ReaderUnifiedSBIS', false).addCallback(function (recordSet) {
          *       recSet = recordSet;
          *       recordSet.createRecord({
          *          'Имя': 'Иван',
          *          'Отчество': 'Иванич',
          *          'Фамилия': 'Ивановов'
          *       });
          *    });
          *    //record: recSet.getRecords()[0];
          * </pre>
          */
         _record: null,
         _recordSaved: false,
         _loadingIndicator: undefined, //Индикатор загрузки
         _saving: false,               //Сохраняется ли в данный момент
         _reportPrinter: null,
         _printMenu: null,
         _printMenuIsShow: false,
         _lastMenuItemList: []
      },
      $constructor: function(){
         var
            declCmd = CommandDispatcher.declareCommand.bind(CommandDispatcher, this);

         declCmd('save',   this.save);
         declCmd('delete', this.delRecord);
         declCmd('print',  this.print);
         declCmd('printReport', this.printReport);

         this._publish('onBeforeDelete', 'onRecordDeleted', 'onBeforeSave', 'onSave', 'onSuccess', 'onFail',
            'onRecordUpdate', 'onBeforeShowPrintReports', 'onPrepareReportData',
            'onSelectReportTransform', 'onBeforeShowConfirmDialog');

         if(!(this._options.record instanceof Record)) {
            throw new Error('Valid record required to build DialogRecord');
         } else {
            this._options.newRecord = this._options.record.getKey() === null || this._options.newRecord;
         }

         if (this.getReports().length !== 0) {
            this._reportPrinter = new ReportPrinter({});
         }

         if(this._options.readOnly){
            var self = this;
            this._dRender.addCallback(function(){
               self._setEnabledForChildControls(false);
            });
         }

         if (this._options.isNewRecord !== undefined){
            logger.error('DialogRecord', rk('Опция isNewRecord будет удалена в 3.8.0. Вместо нее используйте опцию newRecord'));
            this._options.newRecord = this._options.isNewRecord;
         }
      },
      /**
       * Делает неизменяемыми дочерние контролы диалога
       * @param {Boolean} isEnabled
       */
      _setEnabledForChildControls: function(isEnabled){
         var childControls = this.getImmediateChildControls(),
            control;
         for(var i = 0, len = childControls.length; i < len; ++i){
            control = childControls[i];
            if (typeof(control.setReadOnly) == 'function') {
               control.setReadOnly(!isEnabled);
            } else {
               control.setEnabled(isEnabled);
            }
         }
      },
      /**
       *
       * Уничтожение диалога с откатыванием всех изменений.
       * @see close
       */
      destroy: function(){
         this.getRecord().rollback();
         DialogRecord.superclass.destroy.apply(this, arguments);
      },
      /**
       *
       * Метод удаления записи с возможностью выбора закрывать ли после диалог редактирования.
       * @param withoutClose Признак закрывать ли диалог после выполнения удаления.
       * @returns {Core/Deferred}
       * @command delete
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    this.delRecord(true);
       * </pre>
       */
      delRecord: function(withoutClose){
         var self = this,
            dResult = new Deferred(),
            result = self._notify('onBeforeDelete');
         if (result !== false) {
            InformPopManager.showConfirmDialog({
               message: typeof(result) == 'string' ? result : rk('Вы действительно хотите удалить эту запись?'),
               opener: self
            }, function() {
               dResult.dependOn(self.getRecord().destroy().addCallbacks(function(r){
                  self._recordSaved = true;
                  self._notify('onSuccess', r);
                  self._notify('onRecordDeleted');
                  if (withoutClose !== true) {
                     self.ok();
                  }
                  return r;
               }, self._processError.bind(self)));
            }, function() {
               dResult.callback();
            });
         } else {
            dResult.callback();
         }
         return dResult;
      },
      /**
       *
       * Метод получения записи из диалога редактирования.
       * @returns {Deprecated/Record} Запись данного диалога.
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    this.getRecord();
       * </pre>
       */
      getRecord: function(){
         return this.getLinkedContext().getRecord();
      },
      /**
       *
       * Сохраняет запись и закрывает диалог.
       * При выполнении команды save запускаются команды {@link updateRecord} и {@link ok}.
       * @param {Object} [options]
       * @param {Boolean} [options.notifyMe] Deferred, состояние которого будет зависеть от сохранения записи.
       * @param {Boolean} [options.withoutClose] Если установлен в true, то диалог не будет закрыт после сохранения.
       * @param {Boolean} [options.checkChanges] Если установлен в true, то сохранение пройдет с проверкой на версию изменений записи.
       * @param {Boolean} [options.diffOnly] Сохранять только измененные поля.
       * @return {Core/Deferred} Результат сохранения записи.
       * @command
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    this.save(undefined, true);
       * </pre>
       * @see isSaved
       */
      save: function(options) {
         var dResult = new Deferred(),
            notifyMe, withoutClose, checkChanges, diffOnly;

         //Подписка на ошибки
         dResult.addErrback(function (e) {
            return e;
         });

         if (options && arguments.length == 1 && !(options instanceof Deferred)){
            notifyMe = options.notifyMe;
            withoutClose = options.withoutClose;
            checkChanges = options.checkChanges;
            diffOnly = options.diffOnly;
         } else {
            notifyMe = arguments[0];
            withoutClose = arguments[1];
            checkChanges = arguments[2];
         }
         if(!this._saving){
            var self = this;
            if(this._options.readOnly){
               dResult.errback(rk('Вы пытаетесь сохранить запись, открытую только на просмотр!'));
               if (notifyMe instanceof Deferred){
                  notifyMe.errback(rk('Вы пытаетесь сохранить запись, открытую только на просмотр!'));
               }
               if(withoutClose !== true) {
                  this.ok();
               }
            }
            else{
               var dWaitPending = new Deferred();
               this.waitAllPendingOperations(dWaitPending);
               dWaitPending.addCallback(function(){
                  self._saving = true;
                  dResult.dependOn(
                     (function(dUpd){
                        if (notifyMe instanceof Deferred) {
                           return notifyMe.dependOn(dUpd);
                        } else {
                           return dUpd;
                        }
                     })(self.updateRecord({checkChanges: checkChanges, diffOnly: diffOnly}))
                        .addBoth(function(result){
                           self._saving = false;
                           return result;
                        })
                        .addCallback(function(res){
                           if (withoutClose !== true) {
                              self.ok();
                           }
                           return res;
                        })
                  );
               });
            }
         } else {
            dResult.errback(rk('Запись уже сохранена!'));
            if(notifyMe instanceof Deferred) {
               notifyMe.errback(rk('Запись уже сохранена!'));
            }
         }
         return dResult;
      },
      _processError: function(e) {
         var
            eResult = this._notify('onFail', e),
            eMessage = e && e.message;
         if(eResult || eResult === undefined) { // string, undefined
            if(typeof eResult == 'string') {
               eMessage = eResult;
            }
            if(eMessage) {
               InformPopManager.showMessageDialog({
                  status: 'error',
                  message: eMessage,
                  opener: this
               });
            }
         }
         e.processed = true;
         return e;
      },
      /**
       * Показывает индикатор загрузки
       */
      _showLoadingIndicator: forAliveOnly(function(){
         if(this._loadingIndicator && !this._loadingIndicator.isDestroyed()){
            this._loadingIndicator.show(this._options.indicatorSavingMessage);
         } else {
            this._loadingIndicator = new LoadingIndicator({
               parent: this,
               showInWindow: true,
               modal: true,
               message: this._options.indicatorSavingMessage,
               name: this.getId() + '-LoadingIndicator'
            });
         }
      }),
      /**
       * Скрывает индикатор загрузки
       */
      _hideLoadingIndicator: forAliveOnly(function(){
         if(this._loadingIndicator) {
            this._loadingIndicator.hide();
         }
      }),
      /**
       *
       * Инициирует процесс обновления записи на сервере.
       * В случае успеха выполняет {@link onRecordUpdate} + {@link onSuccess}, в случае ошибки {@link onFail}.
       * @param {Object} [options]
       * @param {Boolean} [options.checkChanges] Если установлен в true, то при сохранении записи выполнится проверка версии изменений
       * @param {Boolean} [options.diffOnly] Сохранять только измененные поля
       * @returns {Core/Deferred}
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    this.updateRecord();
       * </pre>
       * @see onSuccess
       * @see onFail
       * @see onRecordUpdate
       * @see onBeforeSave
       * @see onSave
       * @see save
       */
      updateRecord: function(options) {
         var
            dResult = new Deferred(),
            self = this,
            checkChanges = (options instanceof Object) ? options.checkChanges : arguments[0],
            diffOnly = (options instanceof Object) ? options.diffOnly : arguments[1],
            processingResult = function(param){
               if(param === false){
                  self.onBringToFront();
                  dResult.addErrback(function(res){
                     return res;
                  });
                  dResult.errback(rk('Сохранение записи отменено в обработчике на событие') + ' onBeforeSave');
               }
               else{
                  if(self.validate()) {
                     // В этой точке потенциально начались долгие асинхронные операции...
                     self._showLoadingIndicator();
                     var oSr = self._notify('onSave'),
                        record = self.getRecord();
                     if(oSr === false) {
                        dResult.errback(rk('Сохранение записи отменено в обработчике на событие') + ' onSave');
                     } else {
                        var saveDeferred = (oSr instanceof Deferred) ? oSr : record.update({
                           consistencyCheck: checkChanges || false,
                           diffOnly: (typeof diffOnly !== 'undefined') ? diffOnly : self._options.diffOnly
                        });
                        dResult.dependOn(saveDeferred.addCallbacks(function(result){
                           var key = record.getKey();
                           if(typeof(key) === 'number'){
                              self.getLinkedContext().setValue(record.getKeyField(), key);
                           }
                           self._notify('onRecordUpdate', result);
                           self._recordSaved = true;
                           self._options.newRecord = false;
                           self._notify('onSuccess', result);
                           return result;
                        }, function(error){
                           self._processError(error);
                           return error;
                        }));
                     }
                     // При любом раскладе убираем индикатор загрузки
                     dResult.addBoth(function(r){
                        self._hideLoadingIndicator();
                        return r;
                     });
                  } else {
                     dResult.errback(rk('Некорректно заполнены обязательные для заполнения поля!'));
                  }
               }
            },
            processError = function(err){
               self._processError(err);
               dResult.errback(err);
            };
         if(this._options.readOnly){
            //Логичнее кидаться errback'ом (пытались обновить запись в read-only диалоге и т д), но могут быть обработчики, которые на errback могут валить разного рода ошибки
            dResult.callback();
         }
         else{
            //Подписка на ошибки
            dResult.addErrback(function (e) {
               return e;
            });
            try{
               var oBSr = this._notify('onBeforeSave');
               if(oBSr instanceof Deferred){
                  oBSr
                     .addCallback(function(res){
                        processingResult(res);
                        return res;
                     })
                     .addErrback(function(e){
                        processError(e);
                        return e;
                     });
               }
               else{
                  processingResult(oBSr);
               }
            } catch(e){
               processError(e);
            }
         }

         return dResult;
      },
      _openConfirmDialog:function(noHide, retDeferred){
         var retResult = true,
            result = 'noButton',
            deferred = new Deferred(),
            record = this.getRecord();
         if (this._notify('onBeforeShowConfirmDialog', record) === false) {
            deferred.callback('yesButton');
         } else if (!this._options.readOnly && (record.isChanged() || this.isNewRecord())){
            retResult = false;
            InformPopManager.showConfirmDialog({
               message: rk('Сохранить изменения?'),
               details: rk('Чтобы продолжить редактирование, нажмите "Отмена".'),
               hasCancelButton: true,
               opener: this
            }, function() {
               deferred.callback('yesButton');
            }, function() {
               deferred.callback('noButton');
            }, function() {
               deferred.callback(undefined);
            });

         }
         else {
            deferred.callback(result);
         }
         return retDeferred ? deferred : retResult;
      },
      /**
       *
       * Закрытие диалога.
       * @param {Boolean} success Параметр управляет поведением при закрытии диалога. Возможные значения:
       * <ol>
       *    <li>true - закрытие без сохранения изменений;</li>
       *    <li>false - закрытие с диалогом подтверждения сохранения записи при наличии изменений.</li>
       * </ol>
       * @command
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    this.close();
       * </pre>
       */
      close: function(success){
         var self = this;
         this.waitAllPendingOperations(new Deferred().addCallback(function(){
            function close(result) {
               self._dialogRecordSuperClassClose([ result ]);
            }
            if(this.isDestroyed()) {
               return;
            }
            if(!this._options.readOnly && !success && this.getRecord().isChanged()){ // Запрашиваем подтверждение если сделали close() или cancel()
               self._openConfirmDialog(false, true).addCallback(function(result){
                  switch (result) {
                     case 'yesButton' : {
                        self.updateRecord().addCallback(close.bind(this, true));
                        break;
                     }
                     case 'noButton' : {
                        self.getRecord().rollback();
                        close(false);
                        break;
                     }
                  }
               });
            } else {
               self._dialogRecordSuperClassClose([success]);
            }
         }.bind(this)));
      },
      _dialogRecordSuperClassClose : function(){
         DialogRecord.superclass.close.apply(this, arguments[0]);
      },
      /**
       *
       * Признак была ли запись сохранена.
       * @returns {Boolean} Возможные значения:
       * <ol>
       *    <li>true - запись сохранилась успешно;</li>
       *    <li>false - запись не сохранилась.</li>
       * </ol>
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this;
       *    if (!dialog.isSaved())
       *       dialog.save();
       * </pre>
       * @see save
       */
      isSaved: function(){
         //Если запись уже была сохранена, но после этого ее изменили, вернем false
         if (this._recordSaved && this.getRecord().isChanged()){
            return false;
         }
         return this._recordSaved;
      },
      /**
       *
       * Признак режима "Только для чтения" - нельзя менять данные диалога редактирования.
       * @returns {Boolean} Возможные значения:
       * <ol>
       *    <li>true - режим "Только для чтения" включен;</li>
       *    <li>false - выключен.</li>
       * </ol>
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this;
       *    if (!dialog.isReadOnly())
       *       dialog.save();
       * </pre>
       * @see readOnly
       * @see setReadOnly
       */
      isReadOnly: function(){
         return this._options.readOnly;
      },
      /**
       *
       * Изменяет состояние режима диалога редактирования "Только для чтения".
       * @param {Boolean} isReadOnly Текущее состояние параметра "Только для чтения".
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this;
       *    dialog.setReadOnly(!dialog.isReadOnly());
       * </pre>
       */
      setReadOnly: function(isReadOnly){
         this._options.readOnly = !!isReadOnly;
         this._setEnabledForChildControls(!isReadOnly);
      },
      /**
       *
       * Признак является ли запись, редактируемая диалогом, только что созданной.
       * @returns {Boolean} Возможные значения:
       * <ol>
       *    <li>true - диалог редактирования открыт для только что созданной записи;</li>
       *    <li>false - диалог редактирования открыт для уже существующей записи.</li>
       * </ol>
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this;
       *    if (!dialog.isNewRecord())
       *       dialog.save();
       * </pre>
       */
      isNewRecord: function(){
         return this._options.newRecord;
      },
      /**
       *
       * Получение списка имён всех доступных отчетов для печати.
       * @returns {Array} Возвращает список имён отчётов для печати.
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this,
       *       reports = dialog.getReports() || [];
       *    if (reports.length > 0)
       *       dialog.printReport(reports[0]);
       * </pre>
       */
      getReports: function(){
         var reports = [];
         for(var i in this._options.reports){
            if (this._options.reports.hasOwnProperty(i) && this._options.reports[i] !== undefined) {
               reports.push(i);
            }
         }
         return reports;
      },
      _printMenuItemsIsChanged: function(newItems){
         if (this._lastMenuItemList.length !== newItems.length) {
            return true;
         }
         for(var i = 0, l = newItems.length; i < l; i++){
            if (this._lastMenuItemList[i] !== newItems[i]) {
               return true;
            }
         }
         return false;
      },
      _createPrintMenu: function(reportsList){
         var self = this;
         if (!reportsList || !(reportsList instanceof Array)) {
            reportsList = this.getReports();
         }

         if(reportsList.length > 1 && ( this._printMenu === null || this._printMenuItemsIsChanged(reportsList) )){
            this._lastMenuItemList = reportsList;
            if(self._printMenu !== null){
               self._printMenu.destroy();
               self._printMenu = null;
            }
            return newContextMenu(reportsList, function(id, elem){
               self.printReport.apply(self, [elem.caption]);
            }).addCallback(function(instance){
               self._printMenu = instance;
               return instance;
            });
         } else {
            return new Deferred().callback(this._printMenu);
         }
      },
      /**
       *
       * Показать меню со списком доступных отчетов.
       * Вызывается из команды  или метода {@link print}.
       * @param e - event
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this,
       *       reports = dialog.getReports() || [];
       *    if (reports.length > 0)
       *       dialog.showReportList();
       *
       * </pre>
       * @see print
       */
      showReportList: function(e){
         if (Object.isEmpty(this._options.reports)) {
            return;
         }
         var data = this.getRecord(),
            list = this.getReports(),
            self = this,
            reports;

         reports = this._notify('onBeforeShowPrintReports', list, data, false);
         if(reports !== false){
            var reportsList;
            if(reports instanceof Array){
               reportsList = reports;
               if(reports.length == 1) {
                  reports = reports[0];
               }
            } else {
               reportsList = typeof(reports) === 'string' ? [] : '';
            }

            this._createPrintMenu(reportsList).addCallback(function(instance){
               if(self._printMenu === null){
                  if (reports === undefined) {
                     reports = list[0];
                  }
                  if (typeof(reports) == 'string') {
                     self.printReport(reports);
                  }
               } else {
                  try{
                     self._printMenu.show(e);
                     self._printMenuIsShow = true;
                  } catch(error){
                     self._printMenu.subscribe('onReady', function(){
                        self._printMenu.show(e);
                        self._printMenuIsShow = true;
                     });
                  }
               }
               return instance;
            });
         }
      },
      /**
       *
       * Вывод заданного отчета на печать.
       * @param idReport Идентификатор отчёта печати.
       * @command
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this,
       *       reports = dialog.getReports() || [];
       *    if (reports.length > 0)
       *       dialog.printReport(reports[0]);
       *       // или
       *       dialog.sendCommand('printReport', reports[0]);
       * </pre>
       */
      printReport: function(idReport){
         if (Object.isEmpty(this._options.reports)) {
            return;
         }
         var object = this.getRecord(),
            transform = '',
            self = this,
            eventResult;
         $('body').toggleClass('ws-progress', true);
         if(self._printMenu !== null && self._printMenuIsShow){
            //self._printMenu.show();
            self._printMenu.destroy(); // это придрот =( пока не написано нормально меню...
            self._printMenu = null;
            self._printMenuIsShow = false;
         }
         if(idReport !== undefined){
            transform = this._options.reports[idReport];
            eventResult = this._notify('onPrepareReportData', idReport, object);
            if(eventResult !== false){
               if(eventResult instanceof Deferred){
                  eventResult.addCallback(function(result){
                     if (result instanceof Record || result instanceof RecordSet || result instanceof Array) {
                        self._showReport(idReport, result, transform);
                     }
                  });
               } else {
                  if (eventResult instanceof Record || eventResult instanceof RecordSet || eventResult instanceof Array) {
                     object = eventResult;
                  }
                  this._showReport(idReport, object, transform);
               }
            } else {
               $('body').toggleClass('ws-progress', false);
            }
         }
      },
      _showReport: function(idReport, object, transform){
         var eventResult = '',
            self = this;
         if(idReport !== undefined){
            eventResult = this._notify('onSelectReportTransform', idReport, object, transform);
            if (typeof(eventResult) === 'string') {
               transform = eventResult;
            }
            transform = $const.resourceRoot + transform;
            self._reportPrinter.prepareReport(object, transform).addCallback(function(reportText){
               showHTMLForPrint(reportText).addCallback(function(instance){
                  instance.subscribe('onReady', function(){
                     this.getChildControlByName('ws-dataview-print-report').subscribe('onContentSet', function(){
                        $('body').toggleClass('ws-progress', false);
                     });
                  });
               });
            }).addErrback(function(error){
               $('body').toggleClass('ws-progress', false);
               InformPopManager.showMessageDialog({
                  message: error.message
               });
            });
         }
      },
      /**
       *
       * Создание\открытие меню выбора отчетов на печать + печать выбранного отчета.
       * Если не заданы отчеты для печати, ничего не делает.
       * @param event
       * @command
       * @example
       * <pre>
       *    //this - диалог редактирования
       *    var dialog = this;
       *       dialog.print();
       *       // или
       *       dialog.sendCommand('print');
       * </pre>
       * @see showReportList
       */
      print: function(event){
         if (Object.isEmpty(this._options.reports)) {
            return;
         }
         this.showReportList(event);
      },
      _unbindBeforeUnload: function() {
         $const.$win.unbind('beforeunload', this._beforeUnload);
      },
      _beforeUnloadHandler: function() {
         //DialogRecord - компонент, который, помимо прямого использования прикладными разработчкиами в своих шаблонах, используется в нашем компоненте RecordFloatArea.
         //RecordFloatArea выполняет роль агрегатора и вызывает методы DialogRecord (с прототипа класса класса, что является крутой задумкой автора (нет)) через передачу контекста в функцию.
         //Так уж получилось, что для _beforeUnloadHandler уже забинжен контекст и передача контекста от RecordFloatArea ни к чему не приведет. А метод isRecordSaved как раз относится к
         //RecordFloatArea и не объявлен на классе DialogRecord.
         //Казалось бы, можно выпилить его насовсем отсюда, но core достаточно коварный репозиторий, чтобы делать в нем
         //очевидные и безопасные правки и не развалить все на тысячу неработающих стендов. Поэтому была добавлена проверка на наличие isRecordSaved, которая может гарантировать
         //работу метода без ошибок выполнения.
         if (!this.isDestroyed() && ((this.getRecord().isChanged() && (!this.isRecordSaved || !this.isRecordSaved())) || this._recordIsChanged)) {
            return rk('Вы покидаете редактируемый документ, все несохраненные данные будут потеряны');
         }
      },
      //Функция подписывается и отписывается на событие onbeforeunload в зависимости от того, был ли изменён документ
      subscribeOnBeforeUnload: function() {
         this._beforeUnload = this._beforeUnloadHandler.bind(this);
         $const.$win.bind('beforeunload', this._beforeUnload);
         this.subscribe('onAfterClose', this._unbindBeforeUnload);
      },
      unsubscribeOnBeforeUnload: function(){
         this.unsubscribe('onAfterClose', this._unbindBeforeUnload);
         this._unbindBeforeUnload();
      },
      /**
       * Устанавливает значение для опции {@link diffOnly}.
       * @param {Boolean} diffOnly Сохранять только изменённые значения.
       * @example
       * <pre>
       *    //this - dialogRecord
       *    this.setSaveDiffOnly(true);
       * </pre>
       * @see diffOnly
       */
      setSaveDiffOnly: function(diffOnly){
         this._options.diffOnly = !!diffOnly;
      }
   });

   return DialogRecord;
});
