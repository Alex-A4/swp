/**
 * Created with JetBrains PhpStorm.
 * User: tm.baeva
 * Date: 21.04.13
 * Time: 22:55
 * To change this template use File | Settings | File Templates.
 */
define('Deprecated/Controls/FieldString/FieldString', [
   'Core/helpers/Hcontrol/isElementVisible',
   'Core/helpers/String/escapeASCII',
   'Core/helpers/String/linkWrap',
   'Core/helpers/String/escapeHtml',
   'Core/dom/checkCapsLock',
   'Core/constants',
   'Lib/Control/Infobox/Infobox',
   'Deprecated/Controls/FieldAbstract/FieldAbstract',
   'html!Deprecated/Controls/FieldString/FieldString',
   'Core/compatibility',
   'Core/detection',
   'is!msIe?Deprecated/Controls/FieldString/resources/ext/ierange-m2-min',
   'i18n!Deprecated/Controls/FieldString/FieldString'
], function(
   isElementVisible,
   escapeASCII,
   linkWrap,
   escapeHtml,
   checkCapsLock,
   cConstants,
   Infobox,
   FieldAbstract,
   dotTplFn
) {

   'use strict';

   var escapeUnicode = function() {
      // Коды для замены utf символов аналогами из win1251
      var codeMap = {
         8210: 45,
         1105: 1105, //'ё'
         8470: 8470,  //'№'
         187: 187,//»
         171: 171//«
      };
      return function(str) {
         var L = [];
         for (var i=0; i<str.length; i++) {
            var ord = str.toString().charCodeAt(i);
            // диапозон win1251 оставляем
            if (ord < 128 || (ord >= 1025 && ord < 1104)) {
               L.push(String.fromCharCode(ord));
            } else if(ord in codeMap) { // если код входит в таблицу codeMap
               L.push(String.fromCharCode(codeMap[ord]));
            }
         }
         return L.join('')
      }
   }();

   /**
    * Строковое поле, аналог input text
    * @class Deprecated/Controls/FieldString/FieldString
    * @extends Deprecated/Controls/FieldAbstract/FieldAbstract
    * @author Крайнов Д.О.
    * @control
    * @public
    * @initial
    * <component data-component='Deprecated/Controls/FieldString/FieldString' style='width: 100px'>
    * </component>
    * @category Fields
    * @designTime actions /design/design
    * @ignoreOptions width
    * @deprecated Используйте классы {@link SBIS3.CONTROLS/TextBox} или {@link SBIS3.CONTROLS/PasswordTextBox}.
    */
   var FieldString = FieldAbstract.extend(/** @lends Deprecated/Controls/FieldString/FieldString.prototype */{
      /**
       * @event onPaste При вставке значения в поле
       * Событие, возникает в момент вставки данных в поле
       * @param {Core/EventObject} eventObject Дескриптор события.
       * @param {String} pasteData Текст, который вставляется в поле.
       * @returns {Boolean} Для отмены действия вставки нужно вернуть false.
       * @example
       * <pre>
       *    fieldString.subscribe('onPaste', function(event, data) {
       *       // разбивает data на слова и вставляет их в кмопненты fieldString
       *       var arrData = data.split(' ');
       *       for (var i in arrData) {
       *          if (self.hasChildControlByName('fstring'+i)) {
       *             ctrl.getChildControlByName('fieldString'+i).setValue(arrData[i]);
       *          }
       *          else {
       *             break;
       *          }
       *       }
       *       event.setResult(false);
       *    });
       * </pre>
       */
      $protected: {
         _tooltipContainer: null,
         _initValue: undefined,
         _infoboxTargetChangeHandler: null,
         _firefoxDelayedMaxlegth: null,
         _dataReview: undefined,
         _options: {
            wrapFiles: linkWrap.wrapFiles,
            escapeASCII: escapeASCII,
            wrapURLs: linkWrap.wrapURLs,
            escapeHtml: escapeHtml,

            /**
             * @cfg {Boolean} Отображать поле для ввода пароля
             *
             * Включает режим ввода пароля, введённые символы отображаются звёздочками.
             * @see setPassword
             */
            password: false,
            // TODO свойство подлежит удалению
            /**
             * @cfg {Boolean} Поле не может быть пустым
             *
             * @deprecated Не использовать.
             */
            canNotBeEmpty: false,
            /**
             * @cfg {Boolean} Отображать подсказку внутри поля
             *
             * Включает возможность отображения подсказки внутри поля ввода, при отсутствии в нём текста.
             * @see alwaysShowTooltipInside
             */
            tooltipInside: false,
            /**
             * @cfg {Boolean} Отображение подсказки внутри поля в активном/неактивном состоянии контрола
             *
             * При включенной опции tooltipInside, определяет возможность отображения подсказки внутри поля для неактивного контрола.
             * Возможные значения:
             * <ol>
             *    <li>true - Отображать подсказку внутри поля для контрола в любом его состоянии.</li>
             *    <li>false - Отображать подсказку внутри поля только если у контрола св-во enable=true. Для неактинвых контролов не показываем.</li>
             * </ol>
             * @see tooltipInside
             */
            alwaysShowTooltipInside: false,
            /**
             * @cfg {String} Фильтр ввода
             *
             * Каждый вводимый символ будет проверяться на соответсвие указанному в этой опции регулярному выражению.
             * Несоответсвующие символы невозможно напечатать.
             */
            inputFilter : '',
            /**
             * @cfg {Boolean} Обрезать начальные и конечные пробелы
             *
             * Включает режим обрезания начальных и конечных пробельных символов при валидации.
             */
            trim : false,
            /**
             * Позволяет в задизабленном режиме подсвечивать ссылки на файлы и URL
             * @cfg {Boolean} Подсвечивать ссылки
             *
             */
            highlightLinks: false,
            cssClass: ''
         },
         _keysWeHandle: [
            cConstants.key.del,
            cConstants.key.backspace,
            cConstants.key.left,
            cConstants.key.right,
            cConstants.key.minus,
            cConstants.key.space,
            cConstants.key.o,
            cConstants.key.m
         ]
      },
      $constructor : function(){
         var self = this;
         this._publish('onPaste');
         this._container.find('.ws-field').bind('click', function(){
            if(!self._inputClicked) {
               self._firstSelect();
            } else {
               self._inputClicked = false;
            }
         });
         this._container.find('.input-string-field').bind('change', function() {
            self._setValueInternal(self._curValue());
         });
      },
      _initEvents: function() {
         // в первую очередь нужно выполнить инициализоцию событий у родителя
         FieldString.superclass._initEvents.apply(this, arguments);
         this._infoboxTargetChangeHandler = function(event, prev){
            if (!this._options.tooltipInside && !this._options.extendedTooltip && prev && prev === this._getExtendedTooltipTarget().get(0)) {
               this._inputControl.attr('title', this.getTooltip());
            }
         }.bind(this);
         var
            self = this,
            inputControl = this._inputControl,
            moveOnFirstSelectHandler = function(){
               self._mouseDraggedThroughFirstSelect = true;
               inputControl.unbind('mousemove', moveOnFirstSelectHandler);
            };

         if (!cConstants.compatibility.placeholder && inputControl.is('input')) {
            setTimeout(function() {
               inputControl.css('line-height', self._container.height() - 2 + 'px');
            }, 0);
         }
         inputControl.bind('keypress', function(event) {
            self._handleCapsLock(event);
            return self._options.inputFilter !== '' ? self._inputFilter(event, new RegExp(self._options.inputFilter)) : true;
         }).bind('paste', function(e){
            if (!self.isEnabled() || self.isReadOnly()) {
               return;
            }
            self._pasteData = {
               clipboard: escapeUnicode(e.originalEvent.clipboardData ? e.originalEvent.clipboardData.getData('text') : window.clipboardData.getData('text')),
               curVal : self._curValue(true) || ''
            };
            var pasteClass = 'input-pasting',
               maxLength,
               pasteData = function(data) {
                  self._setValueInternal(data);
                  // метод _setValueInternal присваивает значение в _curval, но в FieldLink не делает вставку в input
                  // вставим _curval в input вручную
                  if (self._inputControl.val() != self._curval) {
                     self._inputControl.val(self._curval);
                  }
                  self._onValueChangeHandler(); // Не всегда вызывался раньше если вставлять из контекстного меню.
                  self._inputControl.toggleClass(pasteClass);
                  self._onPasteHandler();
               };

            self._inputControl.toggleClass(pasteClass);
            var userPasteResult = self._notify('onPaste', self._pasteData.clipboard);
            if (userPasteResult === false) { // вставка отменена в обработчике onPaste
               e.preventDefault();
               self._onValueChangeHandler();
               self._inputControl.toggleClass(pasteClass);
               return;
            }
            // в ie при вставке в input type='text' строка обрезается до символа переноса. Делаем как в других браузерах
            if (cConstants.browser.isIE && self._inputControl.attr('type') == 'text') {
               e.preventDefault();
               var iePasteData = self._pasteData.clipboard.replace(/\n/g,' ');
               var pos = self._getCaretPosition();
               iePasteData = self._pasteData.curVal.substr(0, pos.start) + iePasteData + self._pasteData.curVal.substr(pos.end);
               pasteData(iePasteData);
               return;
            }
            self._pasteProcessing++;
            if (self._options.maxLength){
               maxLength = self._options.maxLength;
               self._inputControl.attr('maxlength', 10000);
            }
            setTimeout(function () {
               self._pasteProcessing--;
               self._pasteData.fullVal = self._curValue(true);
               if (self._pasteProcessing) {// Обновляемся лишь в конце цепочки вставок.
                  return;
               }
               if (maxLength) {
                  self._inputControl.attr('maxlength', maxLength);
               }
               pasteData(self._isGetFullText ? self._pasteData : escapeUnicode(self._curValue() || ''));
            }, 100);
         }).bind('mousedown', function(){
            if(self._isControlActive !== true){ // попали только что, значит нужно следить за выделением мышью
               self._mouseDraggedThroughFirstSelect = false;
               inputControl.bind('mousemove', moveOnFirstSelectHandler);
            }
         }).bind('mouseup', function(){
            inputControl.unbind('mousemove', moveOnFirstSelectHandler);
         }).bind('click', function(){
            if (self._mouseDraggedThroughFirstSelect !== undefined) {
               if(self._mouseDraggedThroughFirstSelect === false) {
                  self._firstSelect();
               }
               self._mouseDraggedThroughFirstSelect = undefined;
            }
            self._inputClicked = true;
         }).bind('focus', function() {
            /**
             * Делаем подскролл для мобильной сафари.
             */
            if (cConstants.browser.isMobileSafari) {
               /**
                * Делаем небольшой таймаут для подскролла
                */
               setTimeout(function (){
                  var scroll = cConstants.$win.scrollTop(),
                     container = self._container.get(0),
                     bcr = container.getBoundingClientRect(),
                     koef = (window.innerHeight > window.innerWidth)? 0.60 : 0.39; //Для альбома и портрета коэффициенты разные.
                  if (bcr.bottom > window.innerHeight*koef) {
                     /**
                      * Делаем подскролл вверх
                      */
                     cConstants.$win.scrollTop(scroll + Math.round(window.innerHeight*koef)/2 + Math.abs(Math.round(window.innerHeight*koef) - bcr.bottom));
                  }
               }, 50);
            }
            if (self._tooltipContainer) {
               self._tooltipContainer.addClass('ws-hidden');
            }
         }).bind('blur', function(){
            Infobox.hide();
            if (self._tooltipContainer && isElementVisible(this)) {
               self._tooltipContainer.removeClass('ws-hidden');
            }
         }).bind('dragover drop', function(e){
            // Запрещаем перетаскивать элементы в contenteditable контролы
            if (!!self._inputControl.attr('contenteditable')) {
               e.preventDefault();
               return false;
            }
         });
      },

      /**
       * Функция поиска позиции курсора/выделенного текста
       * @private
       */
      _getCaretPosition: function() {
         var caretPosStart = 0,
            caretPosEnd = 0,
            ctrl = this._inputControl[0];
         // IE Support
         if (document.selection) {
            ctrl.focus();
            var sel = document.selection.createRange();
            var selText = sel.text;
            sel.moveStart('character', -ctrl.value.length);
            caretPosEnd = sel.text.length;
            caretPosStart = caretPosEnd - selText.length;
         }
         // Firefox support
         else if (ctrl.selectionStart || ctrl.selectionStart == '0') {
            caretPosStart = ctrl.selectionStart;
            caretPosEnd = ctrl.selectionEnd;
         }
         return ({
            start: caretPosStart,
            end: caretPosEnd
         });
      },

      /**
       * Функция-обработчик на завершение цепочки вставок.
       * @private
       */
      _onPasteHandler: function() {
         //Переопределить в классах-потомках
      },
      /**
       *
       * Установить режим ввода пароля и опцию {@link password}.
       * @param password {Boolean} Значение опции.
       * <ol>
       *    <li>true - включить режим ввода пароля;</li>
       *    <li>false - не включать/выключить.</li>
       * </ol>
       * @see password
       */
      setPassword: function(password) {
         password = !!password;
         this._options.password = password;
         this._inputControl.prop('type', password ? 'password' : 'text');
         this._updateInPlaceValue(this.getStringValue());
      },
      /**
      *
      * Установить отображение подсказки внутри поля.
      * @param tooltipInside {Boolean} Значение опции.
      * <ol>
      *    <li>true - включить возможность отображения подсказки внутри поля;</li>
      *    <li>false - не включать/выключить.</li>
      * </ol>
      * @see tooltipInside
      */
      setTooltipInside: function(tooltipInside) {
         tooltipInside = !!tooltipInside;
         this._options.tooltipInside = tooltipInside;
         this._setTooltip(this._options.tooltip);
      },
      /**
       * Инициализирует поле ввода
       */
      init: function(){
         FieldString.superclass.init.apply(this, arguments);
         this._initValue = this.getValue();
      },
      /**
       * Обработчик событий изменения данных внутри контрола.
       * Обычно вызывается по change и keyup
       */
      _onValueChangeHandler: function() {
         FieldString.superclass._onValueChangeHandler.apply(this, arguments);
         // убираем подсказку если виден placeholder
         if (this.isTooltipInside() && this._inputControl.attr('title') && !this._curval) {
            this._inputControl.attr('title', null);
         }
      },
      _handleCapsLock: function(event) {
         if(this.isPassword() && isNaN(parseInt(String.fromCharCode(event.which), 10))){
            if(checkCapsLock(event)){
               this._showWarning(rk('Caps-lock включен.'));
            } else{
               Infobox.hide();
            }
         }
      },
      _showWarning: function(message) {
         Infobox.show({
            control: this.getContainer(),
            message: "<p><span style='color: red;'>" + rk('Внимание:') + "</span>" + message + "</p>",
            width: 400,
            delay: 1000,
            hideDelay: 2000
         });
      },
      _inputFilter : function(e, regexp){
         e = e || window.event;
         var target = e.target || e.srcElement;
         if (target.tagName.toUpperCase() === 'INPUT') {
            var
               isIE = document.all,
               code = isIE ? e.keyCode : e.which;
            if (code < 32 || e.ctrlKey || e.altKey) {
               return true;
            }
            if (!regexp.test(String.fromCharCode(code))) {
               return false;
            }
         }
         return true;
      },
      _bindTooltipHandlers: function() {
         var self = this;
         if (this.isTooltipInside() && this._options.tooltip.length > 0) {
            this._tooltipContainer.click(function(e){
               if (self.isEnabled()) {
                  self._inputControl.focus();
               }

               /* Отменяем дефолтное поведение,
                  потому что неожиданно срабатывал focusin у соседнего контрола */
               e.preventDefault();
            });
            this._inputControl.unbind('.tooltip');
            this._inputControl.bind('keyup.tooltip blur.tooltip', function() {
               self._tooltipHandler();
            });
         }
      },
      _isEmpty: function() {
         var value = this._curValue();
         return (typeof(value) === 'undefined' || value === '' || value === null);
      },
      _tooltipHandler: function() {
         if (this.isTooltipInside() && this._options.tooltip.length > 0 && !cConstants.compatibility.placeholder) {
            if (!this._tooltipContainer) {
               this._createPlaceholder();
            }
            this._tooltipContainer.toggle(this._isEmpty() && this.isEnabled());
         }
      },
      setTooltip : function(tooltip) {
         FieldString.superclass.setTooltip.apply(this, arguments);
         this._setTooltip(tooltip);
      },
      /**
       * Функция осуществляет все внутренние операции, связанные со сменой текста тултипа но само свойство не меняется
       * @param {String} tooltip
       * @param {Boolean} keyup - применить логику, как по нажатию клавиш
       * @private
       */
      _setTooltip : function(tooltip, keyup) {
         var
            isTooltipInside = this.isTooltipInside();
         if (keyup) {
            if (isTooltipInside && !this.isPassword() && !this._options.extendedTooltip) {
               this._inputControl.attr('title', tooltip);
               this._container.attr('title', tooltip);
            }
         }
         else {
            if (!this.isPassword() && !isTooltipInside) {
               this._setTooltipInside('');
               if (!this._options.extendedTooltip) {
                  this._inputControl.attr('title', tooltip);
                  this._container.attr('title', tooltip);
               }
            } else if (isTooltipInside) {
               this._setTooltipInside(tooltip);
               if (!this._options.extendedTooltip) {
                  this._inputControl.removeAttr('title');
                  this._container.removeAttr('title');
               }
            }
         }
      },
      /**
       * Создаёт placeholder-подсказку
       * Для кроссбраузерного решения создает отдельный контейнер в тех браузерах что не поддерживают placeholder в html
       * @returns {String} Строка устанавливаемая в виде подсказки
       * @protected
       */
      _setTooltipInside: function(tooltip) {
         if (tooltip && typeof tooltip === 'string') {
            if (cConstants.compatibility.placeholder) {
               this._inputControl.attr('placeholder', tooltip);
            } else {
               if (this._tooltipContainer) {
                  this._tooltipContainer.text(tooltip).toggle(!!tooltip && this._isEmpty());
               } else {
                  this._createPlaceholder();
               }
            }
         } else {
            if (cConstants.compatibility.placeholder) {
               this._inputControl.removeAttr('placeholder');
            } else if (this._tooltipContainer) {
               this._tooltipContainer.remove();
               this._tooltipContainer = null;
            }
         }
      },
      /**
       * Переопределяем метод отображения подсказки, чтобы выключить infoBox
       * @protected
       */
      _finallyShowInfobox: function() {
         if (!this._container.find('.ws-field').hasClass('ws-hidden') || this._editAtPlace) {
            this._inputControl.attr('title', null);
            var self = this;
            Infobox.once('onChangeTarget', function () {
               if (!self.isDestroyed()) {
                  Infobox.once('onChangeTarget', self._infoboxTargetChangeHandler);
               }
            });
            FieldString.superclass._finallyShowInfobox.apply(this, arguments);
         }
      },
      _firstSelect : function(){
         this._funcFocus();
      },
      /**
       *
       * @param active
       * @param shiftKey
       * @param noFocus
       */
      setActive: function(active, shiftKey, noFocus){
         var firstSelect = this._isControlActive != active;
         if (!active && this._changed && this._options.trim) {
            var v = this.getValue();
            if (typeof v == 'string') {
               this.setValue(v.trim());
            }
         }
         FieldString.superclass.setActive.apply(this, arguments);
         if (active && this._firefoxDelayedMaxlegth) {
            // Firefox'окостыль — https://bugzilla.mozilla.org/show_bug.cgi?id=818270
            // sbisdoc://1+ОшРазраб+07.02.14+81977+2DBDF88C-35F7-4D89-A64B-3FFA3E7584F+
            var
               ml = this.getMaxLength();
            this._inputControl.attr('maxlength', (ml || 0) + 100500);
            this._inputControl.attr('maxlength', ml);
            this._firefoxDelayedMaxlegth = false;
         }
         if (active && firstSelect && !noFocus) { // noFocus - не выделяем сразу всё поле по mousedown
            this._firstSelect();
         }
      },
      /**
       * Возвращает объект для фокуса
       * @return {jQuery}
       * @private
       */
      _getElementToFocus: function(){
         return this.isReadOnly() ? this._container : this._inputControl;
      },
      /**
       * Создаёт элемент, имитирующий placeholder для ие
       * @protected
       */
      _createPlaceholder: function(){
         // Обработка свойства tooltipInside. Отображение подсказки в поле ввода.
         if (this.isTooltipInside() && this._options.tooltip.length > 0) {
            if (!cConstants.compatibility.placeholder) {
               this._tooltipContainer = $(['<div class="ws-tooltip-container">', this._options.tooltip, '</div>'].join(''));
               this._inputControl.after(this._tooltipContainer);
               // Логвиненко: для FieldRichEditor добавил выражение parseInt(this._inputControl.parent().css('padding-left'), 10), чтобы placeholder был с отступом
               this._tooltipContainer.css('left', this._inputControl.position().left || parseInt(this._inputControl.parent().css('padding-left'), 10) || parseInt(this._inputControl.css('padding-left'), 10));
               this._bindTooltipHandlers();
               this._tooltipHandler();
            }
         }
      },
      _bindInternals : function(){
         var self = this;
         this._inputControl = this._getInputControl();
         if (!this.isPassword() && this._options.highlightLinks) {
            this._dataReview = this._container.find('.input-string-data-review');
         }
         this._inputControl.bind('keyup', function(){
            // ставим title в input при вводе значения
            self._setTooltip(self._curValue(), true);
         });
         this._createPlaceholder();
      },
      _getInputControl: function() {
         return this._container.find('.input-string-field');
      },
      _dotTplFn: dotTplFn,
      /**
       * Значение пустого поля
       * Разрешает, какое значение примет поле при своём пустом здачении ("", null и т.п.).
       * @param            value Текущее предлагаемое значение
       * @returns {null|*}       Пустое значение для данного значения
       * @protected
       */
      _resolveEmptyValue: function(value){
         return this._initValue === null ? null : value;
      },
      /**
       * возвращает текущее текстовое значение.
       * @return {String|*} текущее текстовое значение
       */
      _curValue : function(){
         var val = this._inputControl.val();
         return !val ? this._resolveEmptyValue(val) : val;
      },
      _filterValue : function(v){
         var
            reg = new RegExp(this._options.inputFilter),
            r = [];
         for (var i = 0, l = v.length; i < l; i++){
            if (reg.test(v.charAt(i))) {
               r.push(v.charAt(i));
            }
         }
         return r.join('');
      },
      /**
       * Обработка строчного значения
       * @param {String} value входное значение
       * @returns {String} value обработанное значение на выходе
       * @protected
       */
      _valueInternalProcessing: function(value) {
         if (value === null || value === undefined) {
            value = '';
         }
         if (typeof value !== 'string') {
            value = value + '';
         }
         if (this._options.inputFilter) {
            value = this._filterValue(value);
         }
         if (this._options.trim) {
            value = value.trim();
         }
         if (this._options.maxLength && value.length > this._options.maxLength) {
            value = value.substr(0, this._options.maxLength);
         }
         return value;
      },
      _setValueInternal: function(value){
         var isPassword = this.isPassword();
         value = this._valueInternalProcessing(value);
         (this._inputControl.val() != value) && this._inputControl.val(value);
         this._inputControl.attr('value', value);
         if (!isPassword && this._options.highlightLinks && this._dataReview) {
            //экранируем скрипты до того как будем искать внутри ссылки, чтобы не попортить результат, там ведь html
            this._dataReview.html(linkWrap.wrapFiles(linkWrap.wrapURLs(escapeHtml(value))));
         }
         this._setTooltip(value, true);
         FieldString.superclass._setValueInternal.apply(this, [value]);
         this._tooltipHandler();
      },
      _updateSelfContextValue: function(value) {
         this._updateDataReview(value);
         FieldString.superclass._updateSelfContextValue.apply(this, arguments);
      },
      _updateDataReview: function(value) {
         if (!this.isPassword() && this._options.highlightLinks && this._dataReview) {
            this._dataReview.html(linkWrap.wrapFiles(linkWrap.wrapURLs(escapeHtml(value))));
         }
      },

      /**
       * Возвращает дефолтное значение
       * @returns {String}
       * @private
       */
      _getDefaultValue: function(){
         var check = function(value){
               if(value && typeof(value) === 'string'){
                  return value;
               }
               return '';
            },
            value = this._options.value;

         return check(typeof(value) === 'function' ? value.call(this) : value);
      },
      _funcFocus : function(){
         if (this._needFocusOnActivated() && this.isEnabled()) {
            if (document.selection) {
               if(document.selection.type !== 'None') {
                  var r = this._inputControl.get(0).createTextRange();
                  //особая уличная магия для ие для работы выделения. подробности вот тут http://stackoverflow.com/questions/130186/ie-textrange-select-method-not-working-properly
                  if(r.select && r.boundingWidth > 0){
                     setTimeout(function() {
                        r.select();
                     }.bind(this), 0);
                  }
               } else {
                  setTimeout(function() {
                     this._inputControl.select();
                  }.bind(this), 0);
               }
            } else {
               setTimeout(function() {
                  this._inputControl.select();
               }.bind(this), 0);
            }
         }
      },
      /**
       * @return {Boolean}
       * @protected
       */
      _canValidate: function() {
         return this.isVisible() && (FieldString.superclass._canValidate.apply(this, arguments) || this._options.canNotBeEmpty);
      },
      _invokeValidation: function() {
         var v = this.getValue();
         if (this._options.trim && typeof v == "string"){
            this.setValue(v.trim());
         }
         var parentResult = FieldString.superclass._invokeValidation.apply(this, arguments);
         if (this._options.canNotBeEmpty && this._isEmpty()) {
            parentResult.result = false;
            parentResult.errors.push(this._options.errorMessageFilling);
         }
         return parentResult;
      },
      _setEnabled : function(enabled){
         if (!this.isPassword() && this._options.highlightLinks && this._dataReview) {
            this._inputControl.toggleClass('ws-hidden', !enabled);
            this._dataReview.toggleClass('ws-hidden', enabled);
         }
         if (!this._options.alwaysShowTooltipInside) {
            this._setTooltip(enabled ? this._options.tooltip : '');
         }
         FieldString.superclass._setEnabled.apply(this, arguments);
      },
      _setDisableAttr: function(enabled) {
         if (!enabled) {
            this._container.toggleClass('readonly', true);
            this._inputControl.attr('readonly', 'readonly');
         } else if (!this._options.readOnly) {
            this._container.toggleClass('readonly', false);
            this._inputControl.removeAttr('readonly');
         }
      },
      /**
       *
       * Устанавливает опцию readOnly
       * @param readOnly значение опции
       */
      setReadOnly: function(readOnly) {
         this._options.readOnly = readOnly;
         if (readOnly) {
            this._container.toggleClass('readonly',true);
            this._inputControl.attr('readonly', 'readonly');
         }
         else
         if (this.isEnabled()) {
            this._container.toggleClass('readonly', false);
            this._inputControl.removeAttr('readonly');
         }
      },
      _keyboardHover: function(event){
         event.stopImmediatePropagation();
         return true;
      },
      /**
       *
       * Получить количество знаков установленной максимальной длины ввода.
       * @return {Number} Текущее ограничение макс. длины.
       */
      getMaxLength: function() {
         return this._options.maxLength;
      },
      /**
       *
       * Изменить максимальную длину ввода.
       * @param maxLen количество знаков для максимальной длины.
       */
      setMaxLength: function (maxLen){
         if (maxLen < 0) {
            return;
         }
         this._options.maxLength = maxLen;
         this._inputControl.attr('maxlength', maxLen);
         if(cConstants.browser.firefox && !isElementVisible(this._inputControl)) {
            this._firefoxDelayedMaxlegth = true;
         }
      },
      _handleInPlaceTooltip: function(value) {
         FieldString.superclass._handleInPlaceTooltip.call(this, this.isPassword() ? '' : value);
      },
      /**
       * Обновление значения в текстовом поле при его изменении извне
       * @param {*} value новое значение
       * @private
       */
      _updateInPlaceValue: function (value) {
         if (this._editAtPlace && this.isPassword() && this._editAtPlaceElement) {
            value = value.replace(/./g, cConstants.browser.webkit ? String.fromCharCode(8226) : String.fromCharCode(9679));
            FieldString.superclass._updateInPlaceValue.apply(this, [value]);
         } else {
            FieldString.superclass._updateInPlaceValue.apply(this, arguments);
         }
      },
      destroy: function() {
         if(!this._isDestroyed){
            Infobox.unsubscribe('onChangeTarget', this._infoboxTargetChangeHandler);
         }
         this._inputControl.unbind('keyup');
         FieldString.superclass.destroy.apply(this, arguments);
         this._infoboxTargetChangeHandler = null;
      },
	  /**
       *
       * Установить, что поле не может быть пустым.
       * @param {Boolean} required Обязательно ли для заполнения.
       * Возможные значения:
       * <ol>
       *    <li>true - поле обязательно к заполнению;</li>
       *    <li>false - поле может быть пустым.</li>
       * </ol>
       * @example
       * Если поле может быть пустым, то запретить эту возможность:
       * <pre>
       *     if(!this.isRequired()) {
       *        //устанавливаем, что поле обязательно к заполнению
       *        this.setRequired(true)
       *     }
       * </pre>
       * @see isRequired
       */
      setRequired: function(required) {
         required = !!required;
         this._options.canNotBeEmpty = required;
      },
      /**
       *
       * Признак обязательно ли для заполнения поле.
       * @returns {Boolean} Возможные значения:
       * <ol>
       *    <li>true - поле обязательно к заполнению;</li>
       *    <li>false - поле может быть пустым.</li>
       * </ol>
       * @example
       * Если поле может быть пустым, то запретить эту возможность:
       * <pre>
       *     //проверяем может ли поле быть пустым
       *     if(!this.isRequired()) {
       *        this.setRequired(true)
       *     }
       * </pre>
       * @see setRequired
       */
      isRequired: function() {
         return this._options.canNotBeEmpty;
      },
      /**
       * Установка строки регулярного выражения для InputFilter
       * @param {String} inputFilter строка регулярного выражения
       * @example
       * <pre>
       *    fieldString.setInputFilter('[0-9]');
       * </pre>
       */
      setInputFilter: function(inputFilter) {
         if (typeof inputFilter === 'string') {
            this._options.inputFilter = inputFilter;
         }
      },
      /**
       * Возвращает строку регулярного выражение в InputFilter
       * @returns {String}
       * @public
       */
      getInputFilter: function() {
         return this._options.inputFilter;
      },
      /**
       *
       * Отображается ли подсказка внутри поля
       * @returns {Boolean}
       * @public
       */
      isTooltipInside: function() {
         return this._options.tooltipInside;
      },
      /**
       *
       * Включён ли режим ввода пароля
       * @returns {Boolean}
       * @public
       */
      isPassword: function() {
         return this._options.password;
      }
   });

   return FieldString;

});
