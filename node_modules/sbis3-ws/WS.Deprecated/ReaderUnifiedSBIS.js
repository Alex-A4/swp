define('Deprecated/ReaderUnifiedSBIS', [
   'Core/core-merge',
   'require',
   'Core/Deferred',
   'Core/constants',
   'Deprecated/ReaderSBIS'
], function(
   cMerge,
   require,
   Deferred,
   _const,
   ReaderSBIS
) {
   var ReaderUnifiedSBIS;

   /**
    * @class Deprecated/ReaderUnifiedSBIS
    * @extends Deprecated/ReaderSBIS
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   ReaderUnifiedSBIS = ReaderSBIS.extend(/** @lends Deprecated/ReaderUnifiedSBIS.prototype */{
      $protected: {
         _options: {
            /**
             * @cfg {String} Тип парсера
             */
            parserType: 'ParserSBIS',
            /**
             * @cfg {String} Название объекта БЛ, с которым выполняется работа
             */
            linkedObject: '',
            dbScheme: '',
            /**
             * @cfg {Deprecated/TransportAdapterAbstract} Тип адаптора транспорта
             */
            adapterType: 'TransportAdapterRPCJSON',
            /**
             * @cfg {String} Имя выборки
             */
            queryName: 'Список',
            /**
             * @cfg {String} Имя метода, который будет вызываться для чтения записей
             */
            readMethodName: 'Прочитать',
            /**
             * @cfg {String} Имя метода, который будет вызываться для создания записей
             */
            createMethodName: 'Создать',
            /**
             * @cfg {String} Имя метода, который будет вызываться для сохранения записей в базе
             */
            updateMethodName: 'Записать',
            /**
             * @cfg {String} Имя метода, который будет вызываться для удаления записей в базе
             */
            destroyMethodName: 'Удалить',
            /**
             * @cfg {String} Имя метода, который будет вызываться для копирования записей
             */
            copyMethodName: 'Копировать',
            /**
             * @cfg {String} Имя метода, который будет вызываться для объединения записей
             */
            mergeMethodName: 'Объединить',
            /**
             * @cfg {String} Адрес сервера БЛ
             */
            otherUrl: false,
            /**
             * @cfg {String} Имя метода, передаваемое в метод Прочитать
             */
            queryNameForRead: null
         }
      },
      $constructor: function() {
         this._options.adapterParams = cMerge({
            //         serviceUrl: 'http://ea1-iis2.corp.tensor.ru:83/sbis-rpc-service.dll',
            // временно изменено, так как нужно, чтобы работали наши демки
            serviceUrl: this._options.otherUrl ? this._options.otherUrl : _const.defaultServiceUrl,
            createMethodName: this._options.dbScheme + this._options.linkedObject + "." + this._options.createMethodName,
            listMethodName: this._options.dbScheme + this._options.linkedObject + '.' + this._options.queryName,
            updateMethodName: this._options.dbScheme + this._options.linkedObject + '.' + this._options.updateMethodName,
            destroyMethodName: this._options.dbScheme + this._options.linkedObject + '.' + this._options.destroyMethodName,
            mergeMethodName: this._options.dbScheme + this._options.linkedObject + '.' + this._options.mergeMethodName,
            copyMethodName: this._options.dbScheme + this._options.linkedObject + '.' + this._options.copyMethodName,
            readMethodName: this._options.dbScheme + this._options.linkedObject + "." + this._options.readMethodName
         }, this._options.adapterParams || {});
      },
      getAdapter: function(method, args) {

         function reduceSlaveObjects(objects, toObjectName) {
            if (Array.isArray(objects)) {
               return Object.keys(objects.reduce(function (memo, o) {
                  memo[toObjectName(o)] = 1;
                  return memo;
               }, {}));
            } else {
               return [toObjectName(objects)];
            }
         }

         var
            obj,
            config,
            methodMap = {
               'read': '.Прочитать',
               'copy': '.Копировать',
               'destroy': '.Удалить',
               'update': '.Записать',
               'merge': '.Объединить'
            };
         switch (method) {
            case 'copy':
            case 'read':
               obj = this._extractObjectName(args[0]);
               break;
            case 'destroy':
               // удаление всегда работает с массивом ключей, поэтому возьмем первый ключ и по нему решим какой объект удаляется
               obj = this._extractObjectName(Array.isArray(args[0]) ? args[0][0] : args[0]);
               break;
            case 'update':
               obj = this._extractObjectName(args[0].getKey());
               break;
            case 'merge':
               var oMaster = this._extractObjectName(args[0]);
               var oSlaveObjects = reduceSlaveObjects(args[1], this._extractObjectName);
               // Если разных типов сливаемых объектов много или он один, но не совпадает с основным типом
               if (oSlaveObjects.length == 1 && oMaster == oSlaveObjects[0]) {
                  obj = oMaster;
               } else {
                  return {
                     merge: function() {
                        return Deferred.fail(rk('Невозможно объединить записи различных типов') + ' (' + oMaster + ' ' + rk('и') + ' ' + oSlaveObjects + ')');
                     }
                  }
               }
               break;
         }
         if (obj) {
            config = cMerge({}, this._options.adapterParams);
            // ВСЕ методы работы с записью перепишем на новый объект, не только запрашиваемый
            if (this._options.linkedObject != obj) {
               for (var mtd in methodMap) {
                  if (methodMap.hasOwnProperty(mtd)) {
                     config[mtd + 'MethodName'] = obj + methodMap[mtd];
                  }
               }
            }
            config['objectName'] = obj;

            var Adapter = require.defined('Deprecated/' + this._options.adapterType) ? require('Deprecated/' + this._options.adapterType) : null;
            if (Adapter) {
               return new Adapter(config);
            } else {
               throw new Error("Adapter type is not specified");
            }
         }
         return ReaderUnifiedSBIS.superclass.getAdapter.apply(this, arguments);
      }
   });

   return ReaderUnifiedSBIS;
});