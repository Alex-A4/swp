define('Deprecated/SerializatorSBIS', [
   'Deprecated/Enum',
   'Deprecated/RecordTypes',
   'Core/core-instance',
   'Core/helpers/Object/sortedPairs',
   'Deprecated/helpers/String/parseComplexKey'
], function(Enum, RecordTypes, cInstance, sortedPairs, parseComplexKey) {
   var SerializatorSBIS;

   /**
    * Сериализатор данных для ReaderUnifiedSBIS
    *
    * @author Бегунов А.В.
    * @class Deprecated/SerializatorSBIS
    * @public
    * @deprecated
    */
   SerializatorSBIS = /** @lends Deprecated/SerializatorSBIS.prototype */{
      /**
       * Метод для сериализации
       * @param {Deprecated/Record|Deprecated/RecordSet} row сериализуемые данные
       * @param {Object} [options]
       * @param {Boolean} [options.diffOnly] Сериализовать только измененные поля
       */
      serialize: function(row, options) {
         var retval;
         if (cInstance.instanceOfModule(row, 'Deprecated/RecordSet') || cInstance.instanceOfModule(row, 'Deprecated/Record')) {
            retval = row.toJSON(options);
         } else {
            throw new TypeError(rk("Попытка сериализации неподдерживаемого типа"));
         }
         return retval;
      },
      /*
       * Получение данных как от БЛ из старого формата описания. момент создания записи или рекордсета через new
       */
      serializeData: function(data, columns) {
         var retval = {"d": [], "s": []},
             colType, colDef;
         columns = this.serializeCols(columns);
         retval.s = columns;
         for (var i = 0, cnt = columns.length; i < cnt; i++) {
            colDef = columns[i];
            colType = typeof(colDef.t) == 'object' ? colDef.t.n : colDef.t;
            // Заполнение структуры сериализуемой записи
            if (colType == 'Перечисляемое'){
               if (data[i] instanceof Enum) {
                  retval.s[i].t.s = data[i].getValues();
               }
            }
            else if(colType == 'Флаги') {
               if (!cInstance.instanceOfModule(data[i], 'Deprecated/Record'))
                  data[i] = null; //чтобы если значение не валидно, то гарантированно ушел null
            }

            if (cInstance.instanceOfModule(data[i], 'Deprecated/Record') || cInstance.instanceOfModule(data[i], 'Deprecated/RecordSet')) {
               if (colType === 'Флаги') {
                  /**
                   * Ожидается, что флаги в структуре и в данных переданы в одлинаковом порядке.
                   * Поэтому сначала мы собираем сопоставление индекса флага и его названия
                   * Потом сортируем по индексу
                   * и собираем отдельно данные, отдельно структуру по уже упорядоченному набору
                   */
                  var dt = [],
                      s = {},
                      t = data[i].getColumns();
                  for (var x = 0, l = t.length; x < l; x++) {
                     s[data[i].getColumnIdx(t[x])] = t[x];
                  }

                  var sorted = sortedPairs(s), rO = data[i].toObject();
                  s = {};
                  for (var y = 0, ly = sorted.keys.length; y < ly; y++) {
                     s[sorted.keys[y]] = sorted.values[y];
                     dt.push(rO[sorted.values[y]]);
                  }
                  retval.d.push(dt);
                  retval.s[i].t.s = s;
               } else {
                  retval.d.push(this.serialize(data[i]));
               }
            }
            else {
               if (colDef.s && colDef.s == "Иерархия") {
                  if (!(colDef.n.substr(colDef.n.length - 1, 1) in {"@": true, "$": true})) {
                     retval.d.push(
                        SerializatorSBIS.serializeHierarchyIdentity(data[i])
                     );
                  } else {
                     retval.d.push(data[i]);
                  }
               } else if (colType == "Связь") {
                  retval.d.push(data[i] === null || data[i] == "null" ? null : parseInt(data[i], 10));
               }
               else if (colType == "Массив") {
                  if (data && (data[i] instanceof Array || data[i] === null)) {
                     retval.d.push(data[i]);
                  } else {
                     retval.d.push([]);
                  }
               }
               else if (data[i] instanceof Date) {
                  if (colType == 'Дата') {
                     retval.d.push(data[i].toSQL());
                  } else if (colType == 'Дата и время') {
                     retval.d.push(data[i].toSQL(true));
                  } else {
                     retval.d.push(data[i].toSQL(false));
                  }
               } else if (data[i] instanceof Enum) {
                  var eV = data[i].getCurrentValue();
                  retval.d.push(eV === null ? null : parseInt(eV, 10));
               } else if (colType == 'Идентификатор') {
                  retval.d.push(SerializatorSBIS.serializeHierarchyIdentity(data[i]));
               } else if (colType == 'Число целое') {
                  retval.d.push((typeof(data[i]) == 'number') ? data[i] : (isNaN(parseInt(data[i], 10)) ? null : parseInt(data[i], 10)));
               } else {
                  retval.d.push(data[i] !== undefined ? data[i] : null);
               }
            }
         }
         return retval;
      },
      serializeCols: function(columns) {
         var result = [];
         for (var t in columns) {
            if (columns.hasOwnProperty(t)) {
               var
                  column = columns[t],
                  type = column.type;

               if (column.s && column.s == RecordTypes.FIELD_TYPE_HIERARCHY) {
                  result.push({
                     n: column.title,
                     t: column.type,
                     s: column.s
                  });
               }
               else if (type == RecordTypes.FIELD_TYPE_ENUM || type == "Флаг") {
                  result.push({
                     n: column.title,
                     t: {
                        n: type,
                        s: column.s
                     }
                  });
               }
               else if (type == RecordTypes.FIELD_TYPE_ARRAY || type == RecordTypes.FIELD_TYPE_LINK) {
                  result.push({
                     n: column.title,
                     t: {
                        n: type,
                        t: type == RecordTypes.FIELD_TYPE_LINK ? column.table : column.arrayType
                     }
                  });
               }
               else if (type == RecordTypes.FIELD_TYPE_FLAGS) {
                  result.push({
                     n: column.title,
                     t: {
                        n: type,
                        s: column.s
                     }
                  });
               }
               else if (type == RecordTypes.FIELD_TYPE_MONEY && column.p) {
                  result.push({
                     n: column.title,
                     t: {
                        n: type,
                        p: column.p
                     }
                  });
               }
               else {
                  result.push({
                     n: column.title,
                     t: type
                  });
               }
            }
         }
         return result;
      },
      /**
       * Сериализует иерархию
       *
       * @param identity
       * @returns {Array}
       */
      serializeHierarchyIdentity: function(identity) {
         var retval;

         if (identity === null) { // Null - превратим в [ null ]
            retval = [null];
         } else if (identity instanceof Array) { // Если пришел массив, удостоверимся что первый его элемент - число
            if (typeof identity[0] == 'string') {
               var nK = parseInt(identity[0], 10);
               if (!isNaN(nK)) {
                  var nA = identity.slice();
                  nA[0] = nK;
                  return nA;
               } else {
                  return identity;
               }
            }
            return identity;
         }
         else if (typeof identity == 'string') { // Если пришла строка - сделаем массив и сделаем числовой ключ
            var parsedIdentity = parseComplexKey(identity);
            identity = [parseInt(parsedIdentity.objKey, 10)];
            if (parsedIdentity.objName) {
               identity.push(parsedIdentity.objName);
            }
            retval = identity;
         }
         else // Это просто число - обернем в массив
         {
            retval = [identity];
         }

         return retval;
      },
      getColumnConfigByType: function(name, type, details) {
         var config = {
                cols: [],
                data: []
             },
             colType;
         switch (type) {
            case RecordTypes.FIELD_TYPE_QUERY:
            case RecordTypes.FIELD_TYPE_RECORD:
            case RecordTypes.FIELD_TYPE_INTEGER:
            case RecordTypes.FIELD_TYPE_STRING:
            case RecordTypes.FIELD_TYPE_TEXT:
            case RecordTypes.FIELD_TYPE_DOUBLE:
            case RecordTypes.FIELD_TYPE_MONEY:
            case RecordTypes.FIELD_TYPE_DATE:
            case RecordTypes.FIELD_TYPE_DATETIME:
            case RecordTypes.FIELD_TYPE_TIME:
            case RecordTypes.FIELD_TYPE_BOOLEAN:
            case RecordTypes.FIELD_TYPE_IDENTITY:
            case RecordTypes.FIELD_TYPE_BINARY:
            case RecordTypes.FIELD_TYPE_UUID:
            case RecordTypes.FIELD_TYPE_RPCFILE:
            case RecordTypes.FIELD_TYPE_TIME_INTERVAL:
               config.cols.push({
                  t: type,
                  n: name
               });
               break;
            case RecordTypes.FIELD_TYPE_LINK:
            case RecordTypes.FIELD_TYPE_ARRAY:
               if (details) {
                  colType = {
                     n: type,
                     t: details
                  };
                  config.cols.push({
                     t: colType,
                     n: name
                  });
               } else {
                  return false;
               }
               break;
            case RecordTypes.FIELD_TYPE_ENUM:
            case RecordTypes.FIELD_TYPE_FLAGS:
               if (details) {
                  colType = {
                     n: type,
                     s: details
                  };
                  config.cols.push({
                     t: colType,
                     n: name
                  });
               } else {
                  return false;
               }
               break;
            case RecordTypes.FIELD_TYPE_HIERARCHY:
               config.cols.push({
                  s: "Иерархия",
                  t: "Идентификатор",
                  n: name
               });
               config.cols.push({
                  s: "Иерархия",
                  t: "Логическое",
                  n: name + "@"
               });
               config.cols.push({
                  s: "Иерархия",
                  t: "Логическое",
                  n: name + "$"
               });
               break;
            default:
               return false;
         }

         switch (type) {
            case RecordTypes.FIELD_TYPE_QUERY:
            case RecordTypes.FIELD_TYPE_RECORD:
               config.data.push({
                  s: [],
                  d: []
               });
               break;
            case RecordTypes.FIELD_TYPE_IDENTITY:
               config.data.push([null]);
               break;
            case RecordTypes.FIELD_TYPE_ARRAY:
            case RecordTypes.FIELD_TYPE_FLAGS:
               if (details) {
                  config.data.push([]);
               } else {
                  return false;
               }
               break;
            case RecordTypes.FIELD_TYPE_HIERARCHY:
               config.data.push([null]);
               config.data.push(false);
               config.data.push(false);
               break;
            default:
               config.data.push(null);
         }
         return config;
      }
   };

   return SerializatorSBIS;
});
