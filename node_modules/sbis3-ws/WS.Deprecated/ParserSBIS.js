define('Deprecated/ParserSBIS', [
   'require',
   'Deprecated/Enum',
   'Deprecated/ParserAbstract',
   'Core/helpers/Object/sortedPairs',
   'Deprecated/helpers/parseIdentity'
], function(require, Enum, ParserAbstract, sortedPairs, parseIdentity) {
   var ParserSBIS;

   /**
    * Парсер данных формата SBIS
    * @class Deprecated/ParserSBIS
    * @extends Deprecated/ParserAbstract
    * @author Бегунов А.В.
    * @public
    * @deprecated
    */
   ParserSBIS = ParserAbstract.extend(/** @lends Deprecated/ParserSBIS.prototype */{
      $constructor: function() {
         this._publish('onDataParsed', 'onNewData');
      },
      _columnsParseFnc: function(data) {
         var pk, idx = 0;
         if (Object.prototype.hasOwnProperty.call(data, 's')) {
            for (var i = 0; i < data.s.length; i++) {
               if (!data.s.hasOwnProperty(i))
                  continue;
               if ('k' in data && data.k == data.s[i].n)
                  pk = idx;
               idx++;
            }
            if (pk === undefined && data.k == '-1') {
               pk = -1;
            }
            return {
               settings: data.s,
               pk: pk || 0
            }
         }
      },
      /**
       * Парсинг строк
       * @param {Object} data строка полученная от транспорта
       * @return {Array} строка
       */
      _dataParser: function(data) {
         var notlist = false,
             checkData = data.d[0];
         // Если к нам пришел похожий на дело пакет, но в нем нет структуры - это пустой контейнер.
         if(data.s && data.s.length === 0) {
            // Если мы разбирали Record то он получит пустой row,
            // если же RecordSet то этот возврат никого не волнует, главное что не случится ни одного onNewRecord
            return [];
         }
         if (typeof data.s[0].t == 'object') {
            if (data.s[0].t.n == 'Массив' || data.s[0].t.n == 'Флаги')
               checkData = checkData && checkData[0] || null;
         } else if (data.s[0].t == "Идентификатор") {
            checkData = checkData && checkData[0] === null ? [null] : ( checkData && checkData[0] || null );
            // Вот тут мы ловим то, что БЛ нам почему-то null в поле Идентификатор отдает как просто null, а не массив
            // И если первое поле пустой массив
         }

         if (checkData !== undefined && !(checkData instanceof Array)) {
            notlist = true;
            data.d = [data.d];
         }

         for (var i = 0, l = data.d.length; i < l; i++) {
            var row = [];
            for (var j = 0, len = data.d[i].length; j < len; j++) {
               var curDataType = data.s[j].s && data.s[j].s === "Иерархия" ? data.s[j] : data.s[j].t,
                   curData = data.d[i][j],
                   Record = require('Deprecated/Record');

               if (typeof(curDataType) === "object" && curDataType !== null) {
                  var type = curDataType.n;
                  if (curDataType.s && curDataType.s === "Иерархия") {
                     type = "Иерархия";
                  } else {
                     for (var y in curDataType) {
                        var hardTypes = {"Флаги": 0, "Запись": 0, "Связь": 0, "Перечисляемое": 0, "Массив": 0};
                        if (y in hardTypes)
                           type = y;
                     }
                  }

                  var typeDef = curDataType.s || curDataType[type];

                  if (type == "Флаги") {
                     var
                        st = {},
                        pairs = sortedPairs(typeDef),
                        fData = [];

                     for (var pI = 0, pL = pairs.keys.length; pI < pL; pI++) {
                        st[pairs.values[pI]] = {
                           type: "Логическое",
                           title: pairs.values[pI],
                           index: pairs.keys[pI]
                        };
                        fData[pairs.keys[pI]] = curData === null ? null : curData[pI];
                     }

                     row.push(new Record({
                        row: fData,
                        colDef: st,
                        parentRecordSet: null,
                        pkValue: null
                     }));
                  }
                  else if (type === "Связь" || type === "Массив") {
                     row.push(curData);
                  }
                  else if (type === "Перечисляемое") {
                     row.push(new Enum({
                        availableValues: typeDef,
                        currentValue: curData
                     }));
                  }
                  else if (type == "Иерархия") {
                     row.push(!(curDataType.n.substr(curDataType.n.length - 1, 1) in {"@": true, "$": true}) ?
                           parseIdentity(curData) : curData);
                  }
                  else if (type === "Запись") {
                     var
                        childData = {
                           d: curData,
                           s: typeDef
                        };

                     row.push(new Record({
                        row: this._dataParser(childData),
                        colDef: this._transformColumns(typeDef)
                     }));
                  }
               }
               else if (curDataType === "Идентификатор") {
                  row.push(parseIdentity(curData));
               }
               else if (curDataType === "Запись") {
                  if (curData !== null) {
                     var s = this._columnsParseFnc(curData);
                     row.push(new Record({
                        row: this._dataParser(curData),
                        colDef: this._transformColumns(s.settings)
                     }));
                  } else
                     row.push(null);
               }
               else if ((curDataType in {
                      "Дата": 0,
                      "Время": 0,
                      "Дата и время": 0,
                      "timestamp": 0,
                      "date": 0
                   }) && curData !== null) {
                  var
                     date = Date.fromSQL(curData),
                     serializeMode = undefined;

                  switch (curDataType) {
                     case "Дата и время":
                        serializeMode = true;
                        break;
                     case "Время":
                        serializeMode = false;
                        break;
                  }
                  date.setSQLSerializationMode(serializeMode);
                  row.push(date);
               }
               else if (curDataType == 'Выборка') {
                  if (curData !== null) {
                     var RecordSet = require('Deprecated/RecordSet');

                     row.push(new RecordSet({
                        readerType: 'ReaderSBIS',
                        readerParams: {
                           adapterType: 'TransportAdapterStatic',
                           adapterParams: {
                              data: {
                                 d: curData.d,
                                 s: curData.s
                              }
                           }
                        }
                     }));
                  } else {
                     row.push(null);
                  }
               }
               else {
                  row.push(curData);
               }
            }
            if (notlist) {
               data.d = data.d[0];
               return row;
            }
            else {
               this._notify('onNewRecord', row);
            }
         }
      },
      parseData : function(data, notColumnParse){
         this._notify('onParseData', data);
         //if(notColumnParse === true)Если не надо парсить колонки
         this._notify('onSettingsParsed', data.s, this._columnsParseFnc(data).pk);
         if (data.p)
            this._notify('onWayExists', data.p);
         if (data.r)
            this._notify('onResults', this.readRecord(data.r));
         this._notify('onDataParsed', data.d);
      },
      getParsedData: function(data) {
         return this._dataParser(data);
      },
      readRecord: function(data) {
         if (!data || typeof data !== 'object')
            return null;
         var config = {
            columns: data.s,
            row: data.d,
            pk: this._columnsParseFnc(data).pk
         };
         if (data.objectName) {
            config.objectName = data.objectName;
         }
         return config;
      }
   });

   return ParserSBIS;
});
