define('Vdom/Utils/Functional', [], function() {

   'use strict';

   /**
    * Преобразуем аргументы вызова функции к честному массиву
    * @param argumentsObj
    * @returns {Array}
    */
   function argumentsToArray(argumentsObj) {
      var
         ln = argumentsObj.length,
         args = new Array(ln), i;

      if (typeof ln !== 'number') {
         throw new Error('argumentsToArray - wrong arg');
      }

      for (i = 0; i !== ln; i++) {
         args[i] = argumentsObj[i];
      }
      return args;
   }

   /**
    * Собирает результаты вызовов прокидывая их в вызов следующей фукнкции
    * @param fn1 - функция 1
    * @param fn2 - функция 2
    * @returns {Function}
    */
   function composeWithResultApply(fn1, fn2) {
      var
         functions = Array.isArray(fn1) ? fn1 : argumentsToArray(arguments),
         funcsLn = functions.length;

      return function() {
         var
            res = functions[funcsLn - 1].apply(this, arguments), i;

         for (i = funcsLn - 2; i >= 0; i--) {
            res = res instanceof Array ? functions[i].apply(this, res) : functions[i].call(this, res);
         }

         return res;
      };
   }

   /**
    * Осуществляет поиск функции через проход по прототипам вверх
    * Вызывает callback для этих методов начиная с базового класса
    * @param classFn - класс
    * @param funcName - имя функции
    * @param reduceFn - callback
    * @param memo
    * @returns {*}
    */
   function reduceHierarchyFunctions(classFn, funcName, reduceFn, memo) {
      var
         proto = classFn.prototype,
         result = memo, funcs = [], i, func;

      while (proto && proto.constructor) {
         if (proto.hasOwnProperty(funcName) && typeof proto[funcName] === 'function') {
            func = proto[funcName];
            if (func) {
               funcs.push(func);
            }
         }
         proto = proto.constructor.superclass;
      }

      for (i = funcs.length - 1; i !== -1; i--) {
         result = reduceFn(result, funcs[i]);
      }

      return result;
   }

   /**
    * Возвращает функцию вызывающую последовательно все методы от предка до текщуего класса
    * @param classFn - класс
    * @param funcName - имя функции
    * @returns {Function}
    */
   function composeHierarchyFunctions(classFn, funcName) {
      var
         funcs = getHierarchyFunctions(classFn, funcName);

      return composeWithResultApply(funcs);
   }

   /**
    * Возвращает список всех функций по иерархии
    * @param classFn - класс
    * @param funcName - имя метода
    * @returns {*}
    */
   function getHierarchyFunctions(classFn, funcName) {
      var
         funcs = reduceHierarchyFunctions(classFn, funcName, function(result, fn) {
            result.unshift(fn);
            return result;
         }, []);

      return funcs;
   }

   function assert(cond, msg) {
      var message;
      if (!cond) {
         message = typeof msg == 'function' ? msg() : msg;
         throw new Error(message || 'assert');
      }
   }

   return {
      composeWithResultApply: composeWithResultApply,
      argumentsToArray: argumentsToArray,
      getHierarchyFunctions: getHierarchyFunctions,
      composeHierarchyFunctions: composeHierarchyFunctions,
      reduceHierarchyFunctions: reduceHierarchyFunctions,
      assert: assert
   };
});
