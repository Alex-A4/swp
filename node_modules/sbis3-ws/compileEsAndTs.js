"use strict";

const fs = require('fs');
const typescript = require('typescript');
const path = require('path');
const esprima = require('esprima');
const escodegen = require('escodegen');
const {traverse} = require('estraverse');
const modules = ['Core', 'View'];

const compilerOptions = {
   module: typescript.ModuleKind.AMD,
   target: typescript.ScriptTarget.ES5,
   alwaysStrict: true,
   lib: ['es5', 'es2015', 'scripthost'],
   allowJs: true,
   importHelpers: true,
   moduleResolution: typescript.ModuleResolutionKind.Classic
};


function recursiveReadDir(folder, cb) {
   const files = fs.readdirSync(folder);
   files.map((file) => {
      const filePath = path.join(folder, file);
      const stats = fs.statSync(filePath);
      if (stats.isDirectory()) {
         recursiveReadDir(filePath, cb);
      } else if (filePath.endsWith('.es')) {
         cb(filePath, stats.mtime.getTime());
      }
   })
}

function normalizeDependencies(code, moduleName) {
   const ast = esprima.parse(code);
   traverse(ast, {
      enter(node) {
         // узел непосредственно дефайна модуля
         if (node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'define') {
            node.arguments.forEach((argument, index) => {
               switch (argument.type) {
                  case 'ArrayExpression':
                     for (let i = 0; i < argument.elements.length; i++) {
                        const dependency = argument.elements[i].value;

                        let newDependency = dependency;
                        if (newDependency.endsWith('.es')) {
                           newDependency = newDependency.replace(/\.es$/, '');
                        }
                        if (newDependency.startsWith('.')) {
                           newDependency = unixifyPath(path.join(moduleName, '..', newDependency));
                        }
                        if (newDependency !== dependency) {
                           argument.elements[i] = {
                              type: 'Literal',
                              value: `${newDependency}`,
                              raw: `"${newDependency}"`
                           };
                        }
                     }
                     break;
                  case 'Literal':

                     // убеждаемся что это действительно название модуля, а не callback в виде литерала
                     if (index === 0) {
                        const newModuleName = unixifyPath(argument.value);
                        argument.value = `${newModuleName}`;
                        argument.raw = `'${newModuleName}'`;
                     }
                     break;
                  default:
                     break;
               }
            });

            this.break();
         }
      }
   });
   return escodegen.generate(ast);
}

function unixifyPath(filePath) {
   if (!filePath || typeof filePath !== 'string') {
      return '';
   }

   return path
      .normalize(filePath)
      .replace(/\\/g, '/')
      .replace(/\/\//g, '/');
}

/**
 * Компилирует ES6+ и TS в ES5
 * @returns {string}
 */
function compileEsAndTs() {
   modules.forEach(name => {
      recursiveReadDir(path.join(__dirname, name), filePath => {
         let text = fs.readFileSync(filePath, 'utf8');
         const moduleName = path.relative(__dirname, filePath).replace(/\.(es|ts)$/, ''),
            result = typescript.transpileModule(text, {
               compilerOptions,
               moduleName,
               fileName: filePath
            });
         fs.writeFileSync(filePath.replace(/\.(es|ts)$/, '.js'), normalizeDependencies(result.outputText), 'utf8')
      });
   });
}

compileEsAndTs();




